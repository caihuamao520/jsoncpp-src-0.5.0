; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat


PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ ; `string'
PUBLIC	??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ ; `string'
PUBLIC	??_C@_03FFDNHNKN@rue?$AA@			; `string'
PUBLIC	??_C@_04KCECFHEP@alse?$AA@			; `string'
PUBLIC	??_C@_03KNPGGKC@ull?$AA@			; `string'
PUBLIC	??_C@_01EEMJAFIK@?6?$AA@			; `string'
PUBLIC	??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ ; `string'
PUBLIC	??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ ; `string'
PUBLIC	??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ ; `string'
PUBLIC	??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ ; `string'
PUBLIC	??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ ; `string'
PUBLIC	??_C@_01GEODFPGF@?8?$AA@			; `string'
PUBLIC	??_C@_03DLDNIBIK@?$CFlf?$AA@			; `string'
PUBLIC	??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ ; `string'
PUBLIC	??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ ; `string'
PUBLIC	??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ ; `string'
PUBLIC	??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ ; `string'
PUBLIC	??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ ; `string'
PUBLIC	??_C@_02KAOAMBHJ@?$CK?5?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@	; `string'
PUBLIC	??_C@_04JBAOJHKB@See?5?$AA@			; `string'
PUBLIC	??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	__TI2?AVruntime_error@std@@
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
PUBLIC	__CTA2?AVruntime_error@std@@
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z:PROC
EXTRN	__imp___invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp____stdio_common_vsscanf:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	__imp____std_terminate:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	__imp____std_exception_copy:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xout_of_range@std@@YAXPBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	___report_rangecheckfailure:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp____std_exception_destroy:PROC
EXTRN	@__security_check_cookie@4:PROC
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_scanf_options'::`2'::_OptionsStorage
_BSS	ENDS
CONST	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DD FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD FLAT:??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@exception@std@@8
rdata$r	ENDS
;	COMDAT __CTA2?AVruntime_error@std@@
xdata$x	SEGMENT
__CTA2?AVruntime_error@std@@ DD 02H
	DD	FLAT:__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
	DD	FLAT:__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	ENDS
;	COMDAT __CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVexception@std@@@8??0exception@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0exception@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2IB DD 0ffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DD FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DD	FLAT:??_Eruntime_error@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT __CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12
xdata$x	SEGMENT
__CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QAE@ABV01@@Z12 DD 00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	0cH
	DD	FLAT:??0runtime_error@std@@QAE@ABV01@@Z
xdata$x	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DD FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DD	FLAT:??_Eexception@std@@UAEPAXI@Z
	DD	FLAT:?what@exception@std@@UBEPBDXZ
CONST	ENDS
;	COMDAT __TI2?AVruntime_error@std@@
xdata$x	SEGMENT
__TI2?AVruntime_error@std@@ DD 00H
	DD	FLAT:??1runtime_error@std@@UAE@XZ
	DD	00H
	DD	FLAT:__CTA2?AVruntime_error@std@@
xdata$x	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD FLAT:??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD FLAT:??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD FLAT:??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 00H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVruntime_error@std@@@8
	DD	FLAT:??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 00H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVexception@std@@@8
	DD	FLAT:??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@ DB 'deque<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04JBAOJHKB@See?5?$AA@
CONST	SEGMENT
??_C@_04JBAOJHKB@See?5?$AA@ DB 'See ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
CONST	SEGMENT
??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@ DB ' for detail.', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KAOAMBHJ@?$CK?5?$AA@
CONST	SEGMENT
??_C@_02KAOAMBHJ@?$CK?5?$AA@ DB '* ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
CONST	SEGMENT
??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@ DB 'Line %d, Column '
	DB	'%d', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: hexadecimal digit expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
CONST	SEGMENT
??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@ DB 'Bad unicode'
	DB	' escape sequence in string: four digits expected.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
CONST	SEGMENT
??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@ DB 'expecting '
	DB	'another \u token to begin the second half of a unicode surrog'
	DB	'ate pair', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
CONST	SEGMENT
??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@ DB 'additional si'
	DB	'x characters expected to parse unicode surrogate pair.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@ DB 'Bad escape '
	DB	'sequence in string', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
CONST	SEGMENT
??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@ DB 'Empty esc'
	DB	'ape sequence in string', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03DLDNIBIK@?$CFlf?$AA@
CONST	SEGMENT
??_C@_03DLDNIBIK@?$CFlf?$AA@ DB '%lf', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01GEODFPGF@?8?$AA@
CONST	SEGMENT
??_C@_01GEODFPGF@?8?$AA@ DB '''', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
CONST	SEGMENT
??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@ DB ''' is not a number.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
CONST	SEGMENT
??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@ DB 'Mi'
	DB	'ssing '','' or '']'' in array declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
CONST	SEGMENT
??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@ DB 'Missin'
	DB	'g ''}'' or object member name', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
CONST	SEGMENT
??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@ DB 'Mi'
	DB	'ssing '','' or ''}'' in object declaration', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
CONST	SEGMENT
??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@ DB 'Missing '
	DB	''':'' after object member name', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01EEMJAFIK@?6?$AA@
CONST	SEGMENT
??_C@_01EEMJAFIK@?6?$AA@ DB 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KNPGGKC@ull?$AA@
CONST	SEGMENT
??_C@_03KNPGGKC@ull?$AA@ DB 'ull', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04KCECFHEP@alse?$AA@
CONST	SEGMENT
??_C@_04KCECFHEP@alse?$AA@ DB 'alse', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFDNHNKN@rue?$AA@
CONST	SEGMENT
??_C@_03FFDNHNKN@rue?$AA@ DB 'rue', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
CONST	SEGMENT
??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@ DB 'Syntax err'
	DB	'or: value, object or array expected.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
CONST	SEGMENT
??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@ DB 'A valid JS'
	DB	'ON document must be either an array or an object value.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@$$QAV012@@Z	; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z	; Json::Reader::ErrorInfo::operator=
PUBLIC	??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ; std::move<Json::Reader::ErrorInfo &>
PUBLIC	??$swap@PAVValue@Json@@X@std@@YAXAAPAVValue@Json@@0@Z ; std::swap<Json::Value *,void>
PUBLIC	??$_Copy_unchecked1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Ptr_copy_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Ptr_copy_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ; std::swap<Json::Reader::ErrorInfo,void>
PUBLIC	??$_Copy_unchecked1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Ptr_copy_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Ptr_copy_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
PUBLIC	??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
PUBLIC	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
PUBLIC	??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
PUBLIC	??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
PUBLIC	??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
PUBLIC	??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
PUBLIC	??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
PUBLIC	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
PUBLIC	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
PUBLIC	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
PUBLIC	??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
PUBLIC	??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
PUBLIC	??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
PUBLIC	??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z	; Json::Reader::ErrorInfo::operator=
PUBLIC	??$construct@PAVValue@Json@@ABQAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value * const &>
PUBLIC	??$_Move_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_backward_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Ptr_move_cat@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::_Ptr_move_cat<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Copy_memmove@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00@Z ; std::_Copy_memmove<Json::Value * * *,Json::Value * * *>
PUBLIC	??$_Move_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_backward_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Ptr_move_cat@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::_Ptr_move_cat<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Copy_memmove@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00@Z ; std::_Copy_memmove<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
PUBLIC	??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Copy_unchecked@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ; std::_Copy_unchecked<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Copy_unchecked@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::_Copy_unchecked<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct<Json::Reader::ErrorInfo>
PUBLIC	??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>
PUBLIC	??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
PUBLIC	??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
PUBLIC	??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
PUBLIC	??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
PUBLIC	?_Rechecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV12@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Rechecked
PUBLIC	?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked
PUBLIC	?_Rechecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV12@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Rechecked
PUBLIC	?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked
PUBLIC	??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
PUBLIC	??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
PUBLIC	??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
PUBLIC	??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
PUBLIC	??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
PUBLIC	??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
PUBLIC	??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
PUBLIC	??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
PUBLIC	??_GErrorInfo@Reader@Json@@QAEPAXI@Z		; Json::Reader::ErrorInfo::`scalar deleting destructor'
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z		; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	??$construct@PAVValue@Json@@ABQAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@ABQAV34@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>
PUBLIC	??$_Move_no_deprecate1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Move_no_deprecate1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Move_backward_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_backward_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Uninitialized_copy_al_unchecked1@PAPAVValue@Json@@PAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked1<Json::Value * *,Json::Value * *,std::allocator<Json::Value * *> >
PUBLIC	??$_Ptr_copy_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAPAVValue@Json@@0@Z ; std::_Ptr_copy_cat<Json::Value * *,Json::Value * *>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ; std::allocator<char>::construct<char *,char * &>
PUBLIC	??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z	; std::allocator<char>::destroy<char *>
PUBLIC	??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo>
PUBLIC	??$_Move_no_deprecate1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Move_no_deprecate1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Move_backward_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_backward_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Uninitialized_copy_al_unchecked1@PAVErrorInfo@Reader@Json@@PAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_copy_al_unchecked1<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Ptr_copy_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@0@Z ; std::_Ptr_copy_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
PUBLIC	??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo *>
PUBLIC	??$forward@ABQAVValue@Json@@@std@@YAABQAVValue@Json@@ABQAV12@@Z ; std::forward<Json::Value * const &>
PUBLIC	??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value *>
PUBLIC	??$_Rechecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YAAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@AAV10@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Rechecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??$_Rotate_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::_Rotate_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Copy_no_deprecate1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Copy_no_deprecate1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy<Json::Value *>
PUBLIC	??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ; std::allocator<Json::Value *>::destroy<Json::Value * *>
PUBLIC	??$_Rechecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@AAV10@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Rechecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??$_Rotate_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::_Rotate_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Copy_no_deprecate1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Copy_no_deprecate1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>
PUBLIC	??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z ; std::allocator<Json::Reader::ErrorInfo>::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
PUBLIC	??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??$?8PAVValue@Json@@PAV01@@std@@YA_NABV?$allocator@PAVValue@Json@@@0@0@Z ; std::operator==<Json::Value *,Json::Value *>
PUBLIC	??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z		; std::operator==<char,char>
PUBLIC	??$?8VErrorInfo@Reader@Json@@V012@@std@@YA_NABV?$allocator@VErrorInfo@Reader@Json@@@0@0@Z ; std::operator==<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
PUBLIC	??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<char> >::operator=
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >
PUBLIC	??4?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAU01@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::operator=
PUBLIC	?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??4?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAU01@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::operator=
PUBLIC	?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$construct@PAVValue@Json@@ABQAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>
PUBLIC	??$_Move_no_deprecate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_no_deprecate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Move_backward1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Move_backward1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??$_Destroy_range1@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Json::Value * *>,Json::Value * * *>
PUBLIC	??$_Uninitialized_default_fill_n1@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_default_fill_n1<Json::Value * * *,unsigned int,std::allocator<Json::Value * *> >
PUBLIC	??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z ; std::_Rechecked<Json::Value * * *,Json::Value * * *>
PUBLIC	??$_Uninitialized_copy_al_unchecked@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_copy_al_unchecked<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
PUBLIC	??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ; std::_Unchecked<Json::Value * * *>
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Value *> > >
PUBLIC	??$_Pocma@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Value *> > >
PUBLIC	??$?0PAVValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value *>
PUBLIC	??$forward@V?$allocator@PAVValue@Json@@@std@@@std@@YA$$QAV?$allocator@PAVValue@Json@@@0@AAV10@@Z ; std::forward<std::allocator<Json::Value *> >
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$?0VErrorInfo@Reader@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Reader::ErrorInfo>
PUBLIC	??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$forward@AAPAD@std@@YAAAPADAAPAD@Z		; std::forward<char * &>
PUBLIC	??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ; std::allocator_traits<std::allocator<char> >::destroy<char *>
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>
PUBLIC	??$_Move_no_deprecate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_no_deprecate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Move_backward1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Move_backward1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??$_Destroy_range1@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo * *>
PUBLIC	??$_Uninitialized_default_fill_n1@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_default_fill_n1<Json::Reader::ErrorInfo * *,unsigned int,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z ; std::_Rechecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
PUBLIC	??$_Uninitialized_copy_al_unchecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_copy_al_unchecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ; std::_Unchecked<Json::Reader::ErrorInfo * *>
PUBLIC	??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
PUBLIC	??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
PUBLIC	??$forward@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>
PUBLIC	??$emplace_back@ABQAVValue@Json@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::emplace_back<Json::Value * const &>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1><std::_Wrap_alloc<std::allocator<Json::Value *> > >
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<Json::Value *> > >
PUBLIC	??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>
PUBLIC	??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Copy_no_deprecate@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ; std::_Copy_no_deprecate<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$?8V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ; std::operator==<std::allocator<Json::Value *>,std::allocator<Json::Value *> >
PUBLIC	??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value *>
PUBLIC	??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value * *>
PUBLIC	??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
PUBLIC	??$forward@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<Json::Value *> > &>
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	??$_Pocma@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	??$forward@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@YA$$QAV?$allocator@VErrorInfo@Reader@Json@@@0@AAV10@@Z ; std::forward<std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator==<std::allocator<char>,std::allocator<char> >
PUBLIC	??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<Json::Reader::ErrorInfo const &>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Copy_no_deprecate@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::_Copy_no_deprecate<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$?8V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ; std::operator==<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??$construct@VErrorInfo@Reader@Json@@$$V@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>
PUBLIC	??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
PUBLIC	??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z ; std::forward<Json::Reader::ErrorInfo const &>
PUBLIC	??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
PUBLIC	??$_Unchecked@PBD@std@@YAPBDPBD@Z		; std::_Unchecked<char const *>
PUBLIC	??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
PUBLIC	??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > &>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
PUBLIC	??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
PUBLIC	??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@XZ	; std::allocator<Json::Value *>::allocator<Json::Value *>
PUBLIC	?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPBD0Urandom_access_iterator_tag@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
PUBLIC	?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_front
PUBLIC	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
PUBLIC	??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Deque_val<std::_Deque_simple_types<Json::Value *> >
PUBLIC	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
PUBLIC	??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
PUBLIC	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
PUBLIC	??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$addressof@D@std@@YAPADAAD@Z			; std::addressof<char>
PUBLIC	??$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Json::Value * *>,Json::Value * * *>
PUBLIC	??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,std::allocator<Json::Value * *> >
PUBLIC	??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1><>
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@ABU10@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Value *> > >
PUBLIC	??$_Pocma@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Value *> > >
PUBLIC	??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Json::Value *> > &>
PUBLIC	??$?0V?$allocator@PAVValue@Json@@@std@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAV?$allocator@PAVValue@Json@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> ><std::allocator<Json::Value *> >
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>
PUBLIC	??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
PUBLIC	??$_Unfancy@D@std@@YAPADPAD@Z			; std::_Unfancy<char>
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$addressof@PAD@std@@YAPAPADAAPAD@Z		; std::addressof<char *>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
PUBLIC	??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
PUBLIC	??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>
PUBLIC	??$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo * *>
PUBLIC	??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
PUBLIC	??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
PUBLIC	??$addressof@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAV123@@Z ; std::addressof<Json::Reader::ErrorInfo *>
PUBLIC	??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>
PUBLIC	??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@X@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > ><std::_Wrap_alloc<std::allocator<Json::Value *> >,void>
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<Json::Value *> > &>
PUBLIC	??$forward@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@0@AAV10@@Z ; std::forward<std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>
PUBLIC	??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::forward<Json::Value *>
PUBLIC	??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
PUBLIC	??$?9V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ; std::operator!=<std::allocator<Json::Value *>,std::allocator<Json::Value *> >
PUBLIC	??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value *>
PUBLIC	??$_Unfancy@PAVValue@Json@@@std@@YAPAPAVValue@Json@@PAPAV12@@Z ; std::_Unfancy<Json::Value *>
PUBLIC	??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value * *>
PUBLIC	??$addressof@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAV12@@Z ; std::addressof<Json::Value * *>
PUBLIC	??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::_Wrap_alloc<std::allocator<Json::Value * *> ><std::_Wrap_alloc<std::allocator<Json::Value *> > &>
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1><>
PUBLIC	??$_Pocca@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@ABU10@@Z ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	??$_Pocma@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	??$?0V?$allocator@VErrorInfo@Reader@Json@@@std@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> ><std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
PUBLIC	??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
PUBLIC	??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ; std::operator!=<std::allocator<char>,std::allocator<char> >
PUBLIC	??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@X@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,void>
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>
PUBLIC	??$forward@V?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAV?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAV10@@Z ; std::forward<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
PUBLIC	??$?9V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ; std::operator!=<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??$emplace_back@$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>
PUBLIC	??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
PUBLIC	??$_Unfancy@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@PAV123@@Z ; std::_Unfancy<Json::Reader::ErrorInfo>
PUBLIC	??$move@AAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@0@AAV10@@Z ; std::move<std::deque<Json::Value *,std::allocator<Json::Value *> > &>
PUBLIC	??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ; std::move<Json::Value * &>
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?0PBDX@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0ABV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char const *,void>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ; std::allocator<Json::Value *>::max_size
PUBLIC	?max_size@?$allocator@D@std@@QBEIXZ		; std::allocator<char>::max_size
PUBLIC	?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ; std::allocator<Json::Reader::ErrorInfo>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::max_size
PUBLIC	?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Compat
PUBLIC	?allocate@?$allocator@D@std@@QAEPADI@Z		; std::allocator<char>::allocate
PUBLIC	?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ; std::allocator_traits<std::allocator<char> >::max_size
PUBLIC	??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Value *>::allocator<Json::Value *>
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::max_size
PUBLIC	?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::allocate
PUBLIC	??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
PUBLIC	??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Setcont
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_second
PUBLIC	?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z ; std::pointer_traits<std::_Container_proxy *>::pointer_to
PUBLIC	??0?$allocator@D@std@@QAE@ABV01@@Z		; std::allocator<char>::allocator<char>
PUBLIC	?deallocate@?$allocator@D@std@@QAEXPADI@Z	; std::allocator<char>::deallocate
PUBLIC	?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::max_size
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
PUBLIC	?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::deallocate
PUBLIC	?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::deallocate
PUBLIC	?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ; std::allocator<Json::Value *>::allocate
PUBLIC	?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter
PUBLIC	?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
PUBLIC	?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front
PUBLIC	?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Alloc_proxy
PUBLIC	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myproxy
PUBLIC	?_Swap_all@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXAAV12@@Z ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Swap_all
PUBLIC	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Get_data
PUBLIC	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Get_data
PUBLIC	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myoff
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SA?AV?$allocator@PAVValue@Json@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<Json::Value *> >::select_on_container_copy_construction
PUBLIC	?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::allocator<Json::Value * *>::deallocate
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::allocate
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
PUBLIC	??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-=
PUBLIC	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
PUBLIC	??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_first
PUBLIC	?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myproxy
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
PUBLIC	?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo *>::allocate
PUBLIC	??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
PUBLIC	??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_second
PUBLIC	?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ; std::pointer_traits<char *>::pointer_to
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
PUBLIC	?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ; std::_Wrap_alloc<std::allocator<char> >::address
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::allocator<Json::Reader::ErrorInfo>::allocate
PUBLIC	?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter
PUBLIC	?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
PUBLIC	?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
PUBLIC	?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
PUBLIC	?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
PUBLIC	?_Assign_rv@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Assign_rv
PUBLIC	?_Assign_rv@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAV12@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Assign_rv
PUBLIC	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
PUBLIC	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
PUBLIC	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
PUBLIC	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
PUBLIC	?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase
PUBLIC	?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::clear
PUBLIC	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
PUBLIC	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getblock
PUBLIC	??0?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	?_Copy_alloc@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Copy_alloc
PUBLIC	?_Move_alloc@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Move_alloc
PUBLIC	?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Free_proxy
PUBLIC	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Orphan_all
PUBLIC	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
PUBLIC	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
PUBLIC	?_Map@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAPAPAVValue@Json@@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Map
PUBLIC	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mapsize
PUBLIC	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myoff
PUBLIC	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mysize
PUBLIC	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mysize
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::select_on_container_copy_construction
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value *> >::deallocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::deallocate
PUBLIC	??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
PUBLIC	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
PUBLIC	??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
PUBLIC	?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Free_proxy
PUBLIC	?_Swap_all@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXAAV12@@Z ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Swap_all
PUBLIC	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Get_data
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::deallocate
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA?AV?$allocator@VErrorInfo@Reader@Json@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::deallocate
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
PUBLIC	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
PUBLIC	??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
PUBLIC	?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Compat
PUBLIC	?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Setcont
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_second
PUBLIC	??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::~_Deque_val<std::_Deque_simple_types<Json::Value *> >
PUBLIC	??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::~_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
PUBLIC	??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
PUBLIC	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
PUBLIC	?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
PUBLIC	?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	?_Assign_rv@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Assign_rv
PUBLIC	?_Assign_rv@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEX$$QAV12@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Assign_rv
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
PUBLIC	?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
PUBLIC	?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
PUBLIC	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
PUBLIC	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
PUBLIC	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=
PUBLIC	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
PUBLIC	??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=
PUBLIC	?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
PUBLIC	?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
PUBLIC	?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
PUBLIC	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
PUBLIC	??1?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::~_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEII@Z ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getblock
PUBLIC	??0?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	??1?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::~_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
PUBLIC	?_Copy_alloc@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Copy_alloc
PUBLIC	?_Move_alloc@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Move_alloc
PUBLIC	?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Orphan_all
PUBLIC	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
PUBLIC	?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
PUBLIC	?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Get_data
PUBLIC	?_Map@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAPAVErrorInfo@Reader@Json@@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Map
PUBLIC	?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mapsize
PUBLIC	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myoff
PUBLIC	?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myoff
PUBLIC	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mysize
PUBLIC	?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mysize
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate
PUBLIC	?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
PUBLIC	??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	??0?$allocator@D@std@@QAE@XZ			; std::allocator<char>::allocator<char>
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=
PUBLIC	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
PUBLIC	??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=
PUBLIC	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
PUBLIC	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
PUBLIC	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
PUBLIC	?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
PUBLIC	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
PUBLIC	?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
PUBLIC	??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
PUBLIC	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=
PUBLIC	??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=
PUBLIC	?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
PUBLIC	?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
PUBLIC	?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
PUBLIC	?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
PUBLIC	??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
PUBLIC	??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
PUBLIC	??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
PUBLIC	??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
PUBLIC	?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Json::Reader::getFormatedErrorMessages
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
PUBLIC	?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ; Json::Reader::getLocationLineAndColumn
PUBLIC	?getNextChar@Reader@Json@@AAEDXZ		; Json::Reader::getNextChar
PUBLIC	?currentValue@Reader@Json@@AAEAAVValue@2@XZ	; Json::Reader::currentValue
PUBLIC	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
PUBLIC	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
PUBLIC	??1ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::~ErrorInfo
PUBLIC	??0ErrorInfo@Reader@Json@@QAE@XZ		; Json::Reader::ErrorInfo::ErrorInfo
PUBLIC	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
PUBLIC	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
PUBLIC	?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeCodePoint
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
PUBLIC	?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeString
PUBLIC	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeDouble
PUBLIC	?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::decodeNumber
PUBLIC	?readArray@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readArray
PUBLIC	?readObject@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readObject
PUBLIC	?readString@Reader@Json@@AAE_NXZ		; Json::Reader::readString
PUBLIC	?readNumber@Reader@Json@@AAEXXZ			; Json::Reader::readNumber
PUBLIC	?readCppStyleComment@Reader@Json@@AAE_NXZ	; Json::Reader::readCppStyleComment
PUBLIC	?readCStyleComment@Reader@Json@@AAE_NXZ		; Json::Reader::readCStyleComment
PUBLIC	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
PUBLIC	?readComment@Reader@Json@@AAE_NXZ		; Json::Reader::readComment
PUBLIC	?match@Reader@Json@@AAE_NPBDH@Z			; Json::Reader::match
PUBLIC	?skipSpaces@Reader@Json@@AAEXXZ			; Json::Reader::skipSpaces
PUBLIC	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z	; Json::Reader::readToken
PUBLIC	?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ; Json::Reader::expectToken
PUBLIC	?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ; Json::Reader::skipCommentTokens
PUBLIC	?readValue@Reader@Json@@AAE_NXZ			; Json::Reader::readValue
PUBLIC	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z	; Json::Reader::parse
PUBLIC	?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
PUBLIC	?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ; Json::Reader::parse
PUBLIC	??0Reader@Json@@QAE@ABVFeatures@1@@Z		; Json::Reader::Reader
PUBLIC	??0Reader@Json@@QAE@XZ				; Json::Reader::Reader
PUBLIC	?strictMode@Features@Json@@SA?AV12@XZ		; Json::Features::strictMode
PUBLIC	?all@Features@Json@@SA?AV12@XZ			; Json::Features::all
PUBLIC	??0Features@Json@@QAE@XZ			; Json::Features::Features
PUBLIC	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
PUBLIC	??4Reader@Json@@QAEAAV01@$$QAV01@@Z		; Json::Reader::operator=
PUBLIC	??4Reader@Json@@QAEAAV01@ABV01@@Z		; Json::Reader::operator=
PUBLIC	??0Reader@Json@@QAE@$$QAV01@@Z			; Json::Reader::Reader
PUBLIC	??0Reader@Json@@QAE@ABV01@@Z			; Json::Reader::Reader
PUBLIC	??1Reader@Json@@QAE@XZ				; Json::Reader::~Reader
PUBLIC	??_FValue@Json@@QAEXXZ				; Json::Value::`default constructor closure'
PUBLIC	??4StaticString@Json@@QAEAAV01@$$QAV01@@Z	; Json::StaticString::operator=
PUBLIC	??4StaticString@Json@@QAEAAV01@ABV01@@Z		; Json::StaticString::operator=
PUBLIC	?c_str@StaticString@Json@@QBEPBDXZ		; Json::StaticString::c_str
PUBLIC	??BStaticString@Json@@QBEPBDXZ			; Json::StaticString::operator char const *
PUBLIC	??0StaticString@Json@@QAE@PBD@Z			; Json::StaticString::StaticString
PUBLIC	??0runtime_error@std@@QAE@ABV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??1runtime_error@std@@UAE@XZ			; std::runtime_error::~runtime_error
PUBLIC	??_Gruntime_error@std@@UAEPAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z	; std::_Container_base12::_Swap_all
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??1_Container_base12@std@@QAE@XZ		; std::_Container_base12::~_Container_base12
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	?_Adopt@_Iterator_base0@std@@QAEXPBX@Z		; std::_Iterator_base0::_Adopt
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHABD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?to_char_type@?$char_traits@D@std@@SADABH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?assign@?$char_traits@D@std@@SAXAADABD@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAPADPADID@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::move
PUBLIC	?copy@?$char_traits@D@std@@SAPADPADPBDI@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SAIPBD@Z		; std::char_traits<char>::length
PUBLIC	??3@YAXPAX0@Z					; operator delete
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??_Gexception@std@@UAEPAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UBEPBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UAE@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QAE@ABV01@@Z			; std::exception::exception
PUBLIC	??0exception@std@@QAE@QBD@Z			; std::exception::exception
PUBLIC	_sscanf
PUBLIC	__vsscanf_l
PUBLIC	_sprintf
PUBLIC	__vsprintf_l
PUBLIC	__vsnprintf_l
PUBLIC	___local_stdio_scanf_options
PUBLIC	___local_stdio_printf_options
PUBLIC	??4Features@Json@@QAEAAV01@$$QAV01@@Z		; Json::Features::operator=
PUBLIC	??4Features@Json@@QAEAAV01@ABV01@@Z		; Json::Features::operator=
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@41dfffffffc00000
PUBLIC	__real@41efffffffe00000
PUBLIC	__real@c1e0000000000000
PUBLIC	__xmm@41f00000000000000000000000000000
EXTRN	??_Eexception@std@@UAEPAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UAEPAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__dtoui3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
EXTRN	__tls_array:DWORD
EXTRN	__tls_index:DWORD
;	COMDAT __xmm@41f00000000000000000000000000000
CONST	SEGMENT
__xmm@41f00000000000000000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 00H, 00H, 00H, 00H, 00H, 00H, 0f0H, 'A'
CONST	ENDS
;	COMDAT __real@c1e0000000000000
CONST	SEGMENT
__real@c1e0000000000000 DQ 0c1e0000000000000r	; -2.14748e+09
CONST	ENDS
;	COMDAT __real@41efffffffe00000
CONST	SEGMENT
__real@41efffffffe00000 DQ 041efffffffe00000r	; 4.29497e+09
CONST	ENDS
;	COMDAT __real@41dfffffffc00000
CONST	SEGMENT
__real@41dfffffffc00000 DQ 041dfffffffc00000r	; 2.14748e+09
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0Reader@Json@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Reader@Json@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0Reader@Json@@QAE@$$QAV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@$$QAV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Reader@Json@@QAE@$$QAV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@$$QAV01@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4Reader@Json@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??4Reader@Json@@QAEAAV01@$$QAV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??4Reader@Json@@QAEAAV01@$$QAV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4Reader@Json@@QAEAAV01@$$QAV01@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4Reader@Json@@QAEAAV01@$$QAV01@@Z$84
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4Reader@Json@@QAEAAV01@$$QAV01@@Z$166
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??4Reader@Json@@QAEAAV01@$$QAV01@@Z$222
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0Reader@Json@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Reader@Json@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0Reader@Json@@QAE@ABVFeatures@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0Reader@Json@@QAE@ABVFeatures@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?readValue@Reader@Json@@AAE_NXZ DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?readValue@Reader@Json@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?readValue@Reader@Json@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$1
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$32
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	00H
	DD	FLAT:__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$35
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$1
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$2
	DD	01H
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$81
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$3
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$4
	DD	04H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$5
	DD	00H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$6
	DD	06H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$7
	DD	07H
	DD	FLAT:__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$8
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z$41
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z
	DD	02H
	DD	FLAT:__tryblocktable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$126
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$127
__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$126 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$0
__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$127 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$2
__catchsym$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z
	DD	02H
	DD	FLAT:__tryblocktable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$161
	DD	02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$162
__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$161 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$0
__catchsym$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$162 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$48
__catchsym$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$48 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z$41
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$26
__tryblocktable$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$27
__catchsym$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$27 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z$42
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z$62
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z$2
xdata$x	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4Features@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4Features@Json@@QAEAAV01@ABV01@@Z PROC		; Json::Features::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	mov	ax, WORD PTR [eax]
	mov	WORD PTR [ecx], ax
	mov	eax, ecx
	pop	ebp
	ret	4
??4Features@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::Features::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4Features@Json@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4Features@Json@@QAEAAV01@$$QAV01@@Z PROC		; Json::Features::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR ___that$[ebp]
	movzx	eax, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al
	movzx	eax, BYTE PTR [edx+1]
	mov	BYTE PTR [ecx+1], al
	mov	eax, ecx
	pop	ebp
	ret	4
??4Features@Json@@QAEAAV01@$$QAV01@@Z ENDP		; Json::Features::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_scanf_options
_TEXT	SEGMENT
___local_stdio_scanf_options PROC			; COMDAT

; 83   :     static unsigned __int64 _OptionsStorage;
; 84   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_scanf_options@@9@4_KA ; `__local_stdio_scanf_options'::`2'::_OptionsStorage

; 85   : }

	ret	0
___local_stdio_scanf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__Locale$dead$ = 12					; size = 4
__ArgList$ = 16						; size = 4
__vsnprintf_l PROC					; COMDAT
; __Buffer$ = ecx
; __BufferCount$dead$ = edx

; 1385 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	ecx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1391 : }

	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Locale$dead$ = 8					; size = 4
__ArgList$ = 12						; size = 4
__vsprintf_l PROC					; COMDAT
; __Buffer$ = ecx
; __Format$ = edx

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	edx
	push	-1
	push	ecx
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsscanf_l
_TEXT	SEGMENT
__Locale$dead$ = 8					; size = 4
__ArgList$ = 12						; size = 4
__vsscanf_l PROC					; COMDAT
; __Buffer$ = ecx
; __Format$ = edx

; 2166 : {

	push	ebp
	mov	ebp, esp

; 2167 :     return __stdio_common_vsscanf(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	edx
	push	-1
	push	ecx
	call	___local_stdio_scanf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2168 :         _CRT_INTERNAL_LOCAL_SCANF_OPTIONS,
; 2169 :         _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 2170 : }

	pop	ebp
	ret	0
__vsscanf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sscanf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sscanf	PROC						; COMDAT

; 2261 : {

	push	ebp
	mov	ebp, esp

; 2167 :     return __stdio_common_vsscanf(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_scanf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsscanf
	add	esp, 28					; 0000001cH

; 2262 :     int _Result;
; 2263 :     va_list _ArgList;
; 2264 :     __crt_va_start(_ArgList, _Format);
; 2265 :     _Result = _vsscanf_l(_Buffer, _Format, NULL, _ArgList);
; 2266 :     __crt_va_end(_ArgList);
; 2267 :     return _Result;
; 2268 : }

	pop	ebp
	ret	0
_sscanf	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@QBD@Z
_TEXT	SEGMENT
__InitData$ = -8					; size = 8
__Message$ = 8						; size = 4
??0exception@std@@QAE@QBD@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 53   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 54   :         __std_exception_data _InitData = { _Message, true };

	mov	eax, DWORD PTR __Message$[ebp]
	xorps	xmm0, xmm0
	push	esi
	mov	esi, ecx
	mov	DWORD PTR __InitData$[ebp], eax
	lea	edx, DWORD PTR [esi+4]
	mov	BYTE PTR __InitData$[ebp+4], 1

; 55   :         __std_exception_copy(&_InitData, &_Data);

	push	edx
	lea	eax, DWORD PTR __InitData$[ebp]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	movq	QWORD PTR [edx], xmm0
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 56   :     }

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0exception@std@@QAE@QBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Other$ = 8						; size = 4
??0exception@std@@QAE@ABV01@@Z PROC			; std::exception::exception, COMDAT
; _this$ = ecx

; 66   :     {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0
	lea	eax, DWORD PTR [esi+4]

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR __Other$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8

; 68   :     }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0exception@std@@QAE@ABV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UAE@XZ
_TEXT	SEGMENT
??1exception@std@@UAE@XZ PROC				; std::exception::~exception, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx

; 85   :     }

	ret	0
??1exception@std@@UAE@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UBEPBDXZ
_TEXT	SEGMENT
?what@exception@std@@UBEPBDXZ PROC			; std::exception::what, COMDAT
; _this$ = ecx

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	ecx, DWORD PTR [ecx+4]
	mov	eax, OFFSET ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
	test	ecx, ecx
	cmovne	eax, ecx

; 90   :     }

	ret	0
?what@exception@std@@UBEPBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gexception@std@@UAEPAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN6@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN6@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gexception@std@@UAEPAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT
; __Size$dead$ = ecx
; __Where$ = edx

; 88   :         (void)_Size;
; 89   :         return _Where;

	mov	eax, edx

; 90   :     }

	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??3@YAXPAX0@Z
_TEXT	SEGMENT
??3@YAXPAX0@Z PROC					; operator delete, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 94   :         return;
; 95   :     }

	ret	0
??3@YAXPAX0@Z ENDP					; operator delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT
; __First$ = ecx

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN3@length
	xor	eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	ret	0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

	lea	edx, DWORD PTR [ecx+1]
	npad	5
$LL5@length:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL5@length
	sub	ecx, edx
	mov	eax, ecx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 530  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@copy
	mov	eax, ecx

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	pop	ebp
	ret	0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	push	edx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	pop	ebp
	ret	0
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT
; __First1$ = ecx
; __First2$ = edx

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 553  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@move
	mov	eax, ecx

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

	pop	ebp
	ret	0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	push	edx
	push	ecx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

	pop	ebp
	ret	0
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT
; __First$ = ecx
; __Count$ = edx

; 559  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[ebp]
	push	edx
	push	eax
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 561  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 565  : 		_Left = _Right;

	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [ecx], al

; 566  : 		}

	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADABH@Z
_TEXT	SEGMENT
?to_char_type@?$char_traits@D@std@@SADABH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT
; __Meta$ = ecx

; 583  : 		return ((_Elem)_Meta);

	mov	al, BYTE PTR [ecx]

; 584  : 		}

	ret	0
?to_char_type@?$char_traits@D@std@@SADABH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHABD@Z
_TEXT	SEGMENT
?to_int_type@?$char_traits@D@std@@SAHABD@Z PROC		; std::char_traits<char>::to_int_type, COMDAT
; __Ch$ = ecx

; 589  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [ecx]

; 590  : 		}

	ret	0
?to_int_type@?$char_traits@D@std@@SAHABD@Z ENDP		; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z
_TEXT	SEGMENT
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 594  : 		{	// test for metacharacter equality

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	sete	al

; 595  : 		return (_Left == _Right);
; 596  : 		}

	ret	0
?eq_int_type@?$char_traits@D@std@@SA_NABH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 606  : 		return (EOF);

	or	eax, -1

; 607  : 		}

	ret	0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$dead$ = ecx

; 55   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 67   : 		: _Mycont(0), _Myfirstiter(0)

	mov	DWORD PTR [ecx], 0

; 69   : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0

; 81   : 		}

	mov	eax, ecx
	ret	0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT
; _this$dead$ = ecx

; 95   : 		_Orphan_all();
; 96   : 		}

	ret	0
??1_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::~_Container_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0

; 115  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 119  : 		{	// copy an iterator

	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Right$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN15@Iterator_b

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN15@Iterator_b

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN15@Iterator_b:

; 120  : 		*this = _Right;
; 121  : 		}

	mov	eax, ecx
	pop	ebp
	ret	4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 124  : 		{	// assign an iterator

	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [ecx], eax
	je	SHORT $LN12@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)

	test	eax, eax
	je	SHORT $LN12@operator

; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN12@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN12@operator:

; 129  : 		else
; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);
; 133  : 			_Orphan_me();
; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}
; 136  : 
; 137  : 		return (*this);

	mov	eax, ecx

; 138  : 		}

	pop	ebp
	ret	4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$dead$ = ecx

; 142  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 143  : 		_Lockit _Lock(_LOCK_DEBUG);
; 144  : 		_Orphan_me();
; 145  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 146  : 		}

	ret	0
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 149  : 		{	// adopt this iterator by parent

	push	ebp
	mov	ebp, esp

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Parent$[ebp]
	test	eax, eax
	je	SHORT $LN3@Adopt

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@Adopt:

; 173  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 174  : 			}
; 175  : 		}

	pop	ebp
	ret	4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN3@Getcont

; 185  : 		}

	ret	0
$LN3@Getcont:

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 185  : 		}

	ret	0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 216  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 217  : 	if (_Myproxy != 0)
; 218  : 		{	// proxy allocated, drain it
; 219  : 		_Lockit _Lock(_LOCK_DEBUG);
; 220  : 
; 221  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;
; 222  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)
; 223  : 			(*_Pnext)->_Myproxy = 0;
; 224  : 		_Myproxy->_Myfirstiter = 0;
; 225  : 		}
; 226  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 227  : 	}

	ret	0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z PROC	; std::_Container_base12::_Swap_all, COMDAT
; _this$ = ecx

; 230  : 	{	// swap all iterators

	push	ebp
	mov	ebp, esp

; 231  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 232  : 	_Lockit _Lock(_LOCK_DEBUG);
; 233  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 234  : 
; 235  : 	_Container_proxy *_Temp = _Myproxy;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	esi, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [esi], edx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN2@Swap_all

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], ecx
$LN2@Swap_all:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN3@Swap_all

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], esi
$LN3@Swap_all:
	pop	esi

; 243  : 	}

	pop	ebp
	ret	4
?_Swap_all@_Container_base12@std@@QAEXAAU12@@Z ENDP	; std::_Container_base12::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Try_aligned_allocation$dead$ = 8			; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT
; __Count$ = ecx
; __Sz$ = edx

; 48   : 	{	// allocate storage for _Count elements of size _Sz

	push	esi
	mov	esi, edx

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

	xor	eax, eax
	pop	esi

; 87   : 	}

	ret	0
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	esi
	cmp	eax, ecx
	jae	SHORT $LN3@Allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN12@Allocate:
$LN3@Allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, esi

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	ja	SHORT $LN6@Allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN13@Allocate:
$LN6@Allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H
	pop	esi

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 85   : 		}
; 86   : 	return (_Ptr);

	mov	eax, ecx

; 87   : 	}

	ret	0
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax
	pop	esi

; 87   : 	}

	ret	0
$LN11@Allocate:
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Sz$ = 8						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT
; __Ptr$ = ecx
; __Count$ = edx

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, edx

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	esi, eax
	jbe	SHORT $LN2@Deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN12@Deallocate:
$LN2@Deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	imul	esi, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	esi, 4096				; 00001000H
	pop	esi
	jb	SHORT $LN3@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN13@Deallocate:
$LN4@Deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN5@Deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN14@Deallocate:
$LN5@Deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN6@Deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN15@Deallocate:
$LN6@Deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN7@Deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@Deallocate:
$LN7@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	DWORD PTR __Sz$[ebp], ecx

; 133  : 	}

	pop	ebp

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	jmp	??3@YAXPAX@Z				; operator delete
$LN11@Deallocate:
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??_Gruntime_error@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gruntime_error@std@@UAEPAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	add	esp, 4
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN9@scalar
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN9@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gruntime_error@std@@UAEPAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??1runtime_error@std@@UAE@XZ
_TEXT	SEGMENT
??1runtime_error@std@@UAE@XZ PROC			; std::runtime_error::~runtime_error, COMDAT
; _this$ = ecx

; 84   :         __std_exception_destroy(&_Data);

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], OFFSET ??_7exception@std@@6B@
	push	eax
	call	DWORD PTR __imp____std_exception_destroy
	pop	ecx
	ret	0
??1runtime_error@std@@UAE@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_exception.h
;	COMDAT ??0runtime_error@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0runtime_error@std@@QAE@ABV01@@Z PROC			; std::runtime_error::runtime_error, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	xorps	xmm0, xmm0

; 65   :         : _Data()

	lea	eax, DWORD PTR [esi+4]

; 66   :     {
; 67   :         __std_exception_copy(&_Other._Data, &_Data);

	push	eax
	mov	DWORD PTR [esi], OFFSET ??_7exception@std@@6B@
	movq	QWORD PTR [eax], xmm0
	mov	eax, DWORD PTR ___that$[ebp]
	add	eax, 4
	push	eax
	call	DWORD PTR __imp____std_exception_copy
	add	esp, 8
	mov	DWORD PTR [esi], OFFSET ??_7runtime_error@std@@6B@
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0runtime_error@std@@QAE@ABV01@@Z ENDP			; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\include\json\value.h
;	COMDAT ??0StaticString@Json@@QAE@PBD@Z
_TEXT	SEGMENT
_czstring$ = 8						; size = 4
??0StaticString@Json@@QAE@PBD@Z PROC			; Json::StaticString::StaticString, COMDAT
; _this$ = ecx

; 67   :       {

	push	ebp
	mov	ebp, esp

; 66   :          : str_( czstring )

	mov	eax, DWORD PTR _czstring$[ebp]
	mov	DWORD PTR [ecx], eax

; 68   :       }

	mov	eax, ecx
	pop	ebp
	ret	4
??0StaticString@Json@@QAE@PBD@Z ENDP			; Json::StaticString::StaticString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\include\json\value.h
;	COMDAT ??BStaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
??BStaticString@Json@@QBEPBDXZ PROC			; Json::StaticString::operator char const *, COMDAT
; _this$ = ecx

; 72   :          return str_;

	mov	eax, DWORD PTR [ecx]

; 73   :       }

	ret	0
??BStaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::operator char const *
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\include\json\value.h
;	COMDAT ?c_str@StaticString@Json@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@StaticString@Json@@QBEPBDXZ PROC			; Json::StaticString::c_str, COMDAT
; _this$ = ecx

; 77   :          return str_;

	mov	eax, DWORD PTR [ecx]

; 78   :       }

	ret	0
?c_str@StaticString@Json@@QBEPBDXZ ENDP			; Json::StaticString::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4StaticString@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4StaticString@Json@@QAEAAV01@ABV01@@Z PROC		; Json::StaticString::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4StaticString@Json@@QAEAAV01@ABV01@@Z ENDP		; Json::StaticString::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??4StaticString@Json@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4StaticString@Json@@QAEAAV01@$$QAV01@@Z PROC		; Json::StaticString::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___that$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??4StaticString@Json@@QAEAAV01@$$QAV01@@Z ENDP		; Json::StaticString::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
;	COMDAT ??_FValue@Json@@QAEXXZ
_TEXT	SEGMENT
??_FValue@Json@@QAEXXZ PROC				; Json::Value::`default constructor closure', COMDAT
; _this$ = ecx

; 269  :    : type_( type )

	mov	BYTE PTR [ecx+8], 0

; 270  :    , allocated_( 0 )

	and	DWORD PTR [ecx+8], -257			; fffffeffH

; 271  :    , comments_( 0 )

	mov	DWORD PTR [ecx+12], 0
	ret	0
??_FValue@Json@@QAEXXZ ENDP				; Json::Value::`default constructor closure'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??1Reader@Json@@QAE@XZ PROC				; Json::Reader::~Reader, COMDAT
; _this$ = ecx
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+104]
	lea	esi, DWORD PTR [edi+84]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN9@Reader

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN9@Reader:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN97@Reader
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN97@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	lea	esi, DWORD PTR [edi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN110@Reader

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN110@Reader:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN198@Reader
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN198@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1244 : 		_Tidy();

	lea	ecx, DWORD PTR [edi+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1244 : 		_Tidy();

	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [edi+20]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [edi+20], 0

; 1244 : 		_Tidy();

	mov	ecx, edi
	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [edi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [edi], 0
	pop	edi
	pop	esi
	ret	0
??1Reader@Json@@QAE@XZ ENDP				; Json::Reader::~Reader
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0Reader@Json@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Reader@Json@@QAE@ABV01@@Z PROC			; Json::Reader::Reader, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 32   : 		: c(_Right.c)

	mov	edi, DWORD PTR ___that$[ebp]
	push	edi
	call	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
	lea	eax, DWORD PTR [edi+20]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	ecx, DWORD PTR [esi+20]
	call	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	lea	ecx, DWORD PTR [esi+40]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH
	lea	edx, DWORD PTR [edi+40]

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN128@Reader
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN129@Reader
$LN128@Reader:
	mov	eax, ecx
$LN129@Reader:

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR [esi+84]
	mov	eax, DWORD PTR [edi+64]
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], eax
	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+72], eax
	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], eax
	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], eax
	lea	eax, DWORD PTR [edi+84]
	push	-1
	push	0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	ax, WORD PTR [edi+108]
	mov	WORD PTR [esi+108], ax
	mov	al, BYTE PTR [edi+110]
	mov	BYTE PTR [esi+110], al
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 20					; 00000014H
	jmp	??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
__unwindfunclet$??0Reader@Json@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 40					; 00000028H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0Reader@Json@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@ABV01@@Z ENDP			; Json::Reader::Reader
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ??0Reader@Json@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??0Reader@Json@@QAE@$$QAV01@@Z PROC			; Json::Reader::Reader, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 74   : 		: c(_STD move(_Right.c))

	mov	esi, DWORD PTR ___that$[ebp]
	push	esi
	call	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
	lea	eax, DWORD PTR [esi+20]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	ecx, DWORD PTR [edi+20]
	call	??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
	lea	eax, DWORD PTR [esi+40]
	push	eax
	lea	ecx, DWORD PTR [edi+40]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [esi+64]
	lea	ecx, DWORD PTR [edi+84]
	mov	DWORD PTR [edi+64], eax
	mov	eax, DWORD PTR [esi+68]
	mov	DWORD PTR [edi+68], eax
	mov	eax, DWORD PTR [esi+72]
	mov	DWORD PTR [edi+72], eax
	mov	eax, DWORD PTR [esi+76]
	mov	DWORD PTR [edi+76], eax
	mov	eax, DWORD PTR [esi+80]
	mov	DWORD PTR [edi+80], eax
	lea	eax, DWORD PTR [esi+84]
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ax, WORD PTR [esi+108]
	mov	WORD PTR [edi+108], ax
	mov	al, BYTE PTR [esi+110]
	mov	BYTE PTR [edi+110], al
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@$$QAV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??0Reader@Json@@QAE@$$QAV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@$$QAV01@@Z ENDP			; Json::Reader::Reader
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4Reader@Json@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4Reader@Json@@QAEAAV01@ABV01@@Z PROC			; Json::Reader::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 43   : 		c = _Right.c;

	mov	edi, DWORD PTR ___that$[ebp]
	mov	esi, ecx
	push	edi
	call	??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=
	lea	eax, DWORD PTR [edi+20]
	push	eax
	lea	ecx, DWORD PTR [esi+20]
	call	??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=
	lea	eax, DWORD PTR [edi+40]
	lea	ecx, DWORD PTR [esi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	cmp	ecx, eax
	je	SHORT $LN6@operator

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN6@operator:
	mov	eax, DWORD PTR [edi+64]
	lea	ecx, DWORD PTR [esi+84]
	mov	DWORD PTR [esi+64], eax
	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], eax
	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+72], eax
	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], eax
	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], eax
	lea	eax, DWORD PTR [edi+84]

; 1024 : 		if (this != &_Right)

	cmp	ecx, eax
	je	SHORT $LN137@operator

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN137@operator:
	mov	ax, WORD PTR [edi+108]
	mov	WORD PTR [esi+108], ax
	mov	al, BYTE PTR [edi+110]
	mov	BYTE PTR [esi+110], al
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??4Reader@Json@@QAEAAV01@ABV01@@Z ENDP			; Json::Reader::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4Reader@Json@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??4Reader@Json@@QAEAAV01@$$QAV01@@Z PROC		; Json::Reader::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4Reader@Json@@QAEAAV01@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1106 : 		if (this != &_Right)

	mov	edi, DWORD PTR ___that$[ebp]
	cmp	esi, edi
	je	SHORT $LN10@operator

; 1107 : 			{	// different, assign it
; 1108 : 			_Tidy();

	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [esi], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [edi], edx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN213@operator

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], esi
$LN213@operator:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN214@operator

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], edi
$LN214@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1120 : 		this->_Map() = _Right._Map();

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 1121 : 		this->_Mapsize() = _Right._Mapsize();

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax

; 1122 : 		this->_Myoff() = _Right._Myoff();

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax

; 1123 : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], eax

; 1124 : 
; 1125 : 		_Right._Map() = _Mapptr();

	mov	DWORD PTR [edi+4], 0

; 1126 : 		_Right._Mapsize() = 0;

	mov	DWORD PTR [edi+8], 0

; 1127 : 		_Right._Myoff() = 0;

	mov	DWORD PTR [edi+12], 0

; 1128 : 		_Right._Mysize() = 0;

	mov	DWORD PTR [edi+16], 0
$LN10@operator:
	lea	ebx, DWORD PTR [edi+20]
	lea	ecx, DWORD PTR [esi+20]

; 1106 : 		if (this != &_Right)

	cmp	ecx, ebx
	je	SHORT $LN327@operator

; 1107 : 			{	// different, assign it
; 1108 : 			_Tidy();

	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	eax, DWORD PTR [ebx]
	lea	edx, DWORD PTR [esi+20]
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [ebx], ecx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN530@operator

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], edx
$LN530@operator:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN531@operator

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], ebx
$LN531@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1120 : 		this->_Map() = _Right._Map();

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edx+4], eax

; 1121 : 		this->_Mapsize() = _Right._Mapsize();

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+8], eax

; 1122 : 		this->_Myoff() = _Right._Myoff();

	mov	eax, DWORD PTR [ebx+12]
	mov	DWORD PTR [edx+12], eax

; 1123 : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [edx+16], eax

; 1124 : 
; 1125 : 		_Right._Map() = _Mapptr();

	mov	DWORD PTR [ebx+4], 0

; 1126 : 		_Right._Mapsize() = 0;

	mov	DWORD PTR [ebx+8], 0

; 1127 : 		_Right._Myoff() = 0;

	mov	DWORD PTR [ebx+12], 0

; 1128 : 		_Right._Mysize() = 0;

	mov	DWORD PTR [ebx+16], 0
$LN327@operator:
	lea	ecx, DWORD PTR [edi+40]
	lea	ebx, DWORD PTR [esi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 929  : 		if (this != &_Right)

	cmp	ebx, ecx
	je	SHORT $LN645@operator

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN651@operator

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [ebx]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
	lea	ecx, DWORD PTR [edi+40]
$LN651@operator:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ebx+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ebx+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN739@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN740@operator
$LN739@operator:
	mov	eax, ebx
$LN740@operator:

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	push	ecx
	mov	ecx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN645@operator:
	mov	eax, DWORD PTR [edi+64]
	lea	ecx, DWORD PTR [edi+84]
	mov	DWORD PTR [esi+64], eax
	lea	ebx, DWORD PTR [esi+84]
	mov	eax, DWORD PTR [edi+68]
	mov	DWORD PTR [esi+68], eax
	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+72], eax
	mov	eax, DWORD PTR [edi+76]
	mov	DWORD PTR [esi+76], eax
	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [esi+80], eax

; 929  : 		if (this != &_Right)

	cmp	ebx, ecx
	je	SHORT $LN869@operator

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [ebx+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN875@operator

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [ebx]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
	lea	ecx, DWORD PTR [edi+84]
$LN875@operator:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ebx+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ebx+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN963@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN964@operator
$LN963@operator:
	mov	eax, ebx
$LN964@operator:

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	push	ecx
	mov	ecx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN869@operator:
	mov	ax, WORD PTR [edi+108]
	mov	WORD PTR [esi+108], ax
	mov	al, BYTE PTR [edi+110]
	mov	BYTE PTR [esi+110], al
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4Reader@Json@@QAEAAV01@$$QAV01@@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??4Reader@Json@@QAEAAV01@$$QAV01@@Z$84:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??4Reader@Json@@QAEAAV01@$$QAV01@@Z$166:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??4Reader@Json@@QAEAAV01@$$QAV01@@Z$222:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??4Reader@Json@@QAEAAV01@$$QAV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4Reader@Json@@QAEAAV01@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4Reader@Json@@QAEAAV01@$$QAV01@@Z ENDP		; Json::Reader::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx

; 1244 : 		_Tidy();

	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi
	ret	0
??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::~stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ??0Features@Json@@QAE@XZ
_TEXT	SEGMENT
??0Features@Json@@QAE@XZ PROC				; Json::Features::Features, COMDAT
; _this$ = ecx

; 20   :    : allowComments_( true )

	mov	WORD PTR [ecx], 1

; 23   : }

	mov	eax, ecx
	ret	0
??0Features@Json@@QAE@XZ ENDP				; Json::Features::Features
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?all@Features@Json@@SA?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?all@Features@Json@@SA?AV12@XZ PROC			; Json::Features::all, COMDAT

; 28   : {

	push	ebp
	mov	ebp, esp

; 20   :    : allowComments_( true )

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	WORD PTR [eax], 1

; 29   :    return Features();
; 30   : }

	pop	ebp
	ret	0
?all@Features@Json@@SA?AV12@XZ ENDP			; Json::Features::all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?strictMode@Features@Json@@SA?AV12@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?strictMode@Features@Json@@SA?AV12@XZ PROC		; Json::Features::strictMode, COMDAT

; 35   : {

	push	ebp
	mov	ebp, esp

; 36   :    Features features;
; 37   :    features.allowComments_ = false;

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	WORD PTR [eax], 256			; 00000100H

; 38   :    features.strictRoot_ = true;
; 39   :    return features;
; 40   : }

	pop	ebp
	ret	0
?strictMode@Features@Json@@SA?AV12@XZ ENDP		; Json::Features::strictMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?in@Json@@YA_NDDDDD@Z
_TEXT	SEGMENT
_c2$dead$ = 8						; size = 1
_c3$dead$ = 12						; size = 1
_c4$dead$ = 16						; size = 1
?in@Json@@YA_NDDDDD@Z PROC				; Json::in, COMDAT
; _c$ = cl
; _c1$dead$ = dl

; 49   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

	cmp	cl, 46					; 0000002eH
	je	SHORT $LN3@in
	cmp	cl, 101					; 00000065H
	je	SHORT $LN3@in
	cmp	cl, 69					; 00000045H
	je	SHORT $LN3@in
	cmp	cl, 43					; 0000002bH
	je	SHORT $LN3@in
	xor	al, al

; 50   : }

	ret	0
$LN3@in:

; 49   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

	mov	al, 1

; 50   : }

	ret	0
?in@Json@@YA_NDDDDD@Z ENDP				; Json::in
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?in@Json@@YA_NDDDDDD@Z
_TEXT	SEGMENT
_c2$dead$ = 8						; size = 1
_c3$dead$ = 12						; size = 1
_c4$dead$ = 16						; size = 1
_c5$dead$ = 20						; size = 1
?in@Json@@YA_NDDDDDD@Z PROC				; Json::in, COMDAT
; _c$ = cl
; _c1$dead$ = dl

; 55   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

	cmp	cl, 46					; 0000002eH
	je	SHORT $LN3@in
	cmp	cl, 101					; 00000065H
	je	SHORT $LN3@in
	cmp	cl, 69					; 00000045H
	je	SHORT $LN3@in
	cmp	cl, 43					; 0000002bH
	je	SHORT $LN3@in
	cmp	cl, 45					; 0000002dH
	je	SHORT $LN3@in
	xor	al, al

; 56   : }

	ret	0
$LN3@in:

; 55   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

	mov	al, 1

; 56   : }

	ret	0
?in@Json@@YA_NDDDDDD@Z ENDP				; Json::in
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?containsNewLine@Json@@YA_NPBD0@Z
_TEXT	SEGMENT
?containsNewLine@Json@@YA_NPBD0@Z PROC			; Json::containsNewLine, COMDAT
; _begin$ = ecx
; _end$ = edx

; 63   :    for ( ;begin < end; ++begin )

	cmp	ecx, edx
	jae	SHORT $LN3@containsNe
$LL4@containsNe:

; 64   :       if ( *begin == '\n'  ||  *begin == '\r' )

	mov	al, BYTE PTR [ecx]
	cmp	al, 10					; 0000000aH
	je	SHORT $LN9@containsNe
	cmp	al, 13					; 0000000dH
	je	SHORT $LN9@containsNe

; 63   :    for ( ;begin < end; ++begin )

	inc	ecx
	cmp	ecx, edx
	jb	SHORT $LL4@containsNe
$LN3@containsNe:

; 66   :    return false;

	xor	al, al

; 67   : }

	ret	0
$LN9@containsNe:

; 65   :          return true;

	mov	al, 1

; 67   : }

	ret	0
?containsNewLine@Json@@YA_NPBD0@Z ENDP			; Json::containsNewLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -20					; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; Json::codePointToUTF8, COMDAT
; ___$ReturnUdt$ = ecx
; _cp$ = edx

; 70   : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, edx
	mov	esi, ecx
	mov	DWORD PTR ___$ReturnUdt$[ebp], esi
	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [esi+16], 0

; 497  : 		_Myres(0)

	mov	DWORD PTR [esi+20], 0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN112@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN113@codePointT
$LN112@codePointT:
	mov	eax, esi
$LN113@codePointT:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 102  :    return result;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	DWORD PTR $T1[ebp], 1
	cmp	ebx, 127				; 0000007fH
	ja	SHORT $LN2@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, 1
	jb	SHORT $LN122@codePointT

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 1

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN144@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+1], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN123@codePointT
$LN144@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+1], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN123@codePointT
$LN122@codePointT:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	mov	eax, 1
	sub	eax, ecx
	mov	ecx, esi
	push	0
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN123@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN172@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	$LN173@codePointT
$LN172@codePointT:
	mov	eax, esi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 78   :       result[0] = static_cast<char>(cp);

	jmp	$LN173@codePointT
$LN2@codePointT:

; 79   :    } 
; 80   :    else if (cp <= 0x7FF) 

	cmp	ebx, 2047				; 000007ffH
	ja	SHORT $LN4@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, 2
	jb	SHORT $LN179@codePointT

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 2

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN201@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+2], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN180@codePointT
$LN201@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+2], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN180@codePointT
$LN179@codePointT:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	mov	eax, 2
	sub	eax, ecx
	mov	ecx, esi
	push	0
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN180@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN229@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN230@codePointT
$LN229@codePointT:
	mov	ecx, esi
$LN230@codePointT:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 83   :       result[1] = static_cast<char>(0x80 | (0x3f & cp));

	mov	al, bl
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+1], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN245@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 84   :       result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));

	shr	ebx, 6
	and	bl, 31					; 0000001fH
	or	bl, -64					; ffffffc0H
	jmp	$LN173@codePointT
$LN245@codePointT:
	shr	ebx, 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 84   :       result[0] = static_cast<char>(0xC0 | (0x1f & (cp >> 6)));

	and	bl, 31					; 0000001fH
	or	bl, -64					; ffffffc0H
	jmp	$LN173@codePointT
$LN4@codePointT:

; 85   :    } 
; 86   :    else if (cp <= 0xFFFF) 

	cmp	ebx, 65535				; 0000ffffH
	ja	$LN6@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, 3
	jb	SHORT $LN252@codePointT

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 3

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN274@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+3], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN253@codePointT
$LN274@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+3], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN253@codePointT
$LN252@codePointT:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	mov	eax, 3
	sub	eax, ecx
	mov	ecx, esi
	push	0
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN253@codePointT:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN302@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN303@codePointT
$LN302@codePointT:
	mov	ecx, esi
$LN303@codePointT:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 89   :       result[2] = static_cast<char>(0x80 | (0x3f & cp));

	mov	al, bl
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+2], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN318@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN319@codePointT
$LN318@codePointT:
	mov	ecx, esi
$LN319@codePointT:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 90   :       result[1] = 0x80 | static_cast<char>((0x3f & (cp >> 6)));

	mov	eax, ebx
	shr	eax, 6
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+1], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN334@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 91   :       result[0] = 0xE0 | static_cast<char>((0xf & (cp >> 12)));

	shr	ebx, 12					; 0000000cH
	and	bl, 15					; 0000000fH
	or	bl, -32					; ffffffe0H
	jmp	SHORT $LN173@codePointT
$LN334@codePointT:
	shr	ebx, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 91   :       result[0] = 0xE0 | static_cast<char>((0xf & (cp >> 12)));

	and	bl, 15					; 0000000fH
	or	bl, -32					; ffffffe0H
	jmp	SHORT $LN173@codePointT
$LN6@codePointT:

; 92   :    }
; 93   :    else if (cp <= 0x10FFFF) 

	cmp	ebx, 1114111				; 0010ffffH
	ja	SHORT $LN402@codePointT

; 94   :    {
; 95   :       result.resize(4);

	push	4
	mov	ecx, esi
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN350@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN351@codePointT
$LN350@codePointT:
	mov	ecx, esi
$LN351@codePointT:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 96   :       result[3] = static_cast<char>(0x80 | (0x3f & cp));

	mov	al, bl
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+3], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN366@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN367@codePointT
$LN366@codePointT:
	mov	ecx, esi
$LN367@codePointT:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 97   :       result[2] = static_cast<char>(0x80 | (0x3f & (cp >> 6)));

	mov	eax, ebx
	shr	eax, 6
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+2], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN382@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN383@codePointT
$LN382@codePointT:
	mov	ecx, esi
$LN383@codePointT:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 98   :       result[1] = static_cast<char>(0x80 | (0x3f & (cp >> 12)));

	mov	eax, ebx
	shr	eax, 12					; 0000000cH
	and	al, 63					; 0000003fH
	or	al, -128				; ffffff80H
	mov	BYTE PTR [ecx+1], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN398@codePointT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN399@codePointT
$LN398@codePointT:
	mov	eax, esi
$LN399@codePointT:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 99   :       result[0] = static_cast<char>(0xF0 | (0x7 & (cp >> 18)));

	shr	ebx, 18					; 00000012H
	and	bl, 7
	or	bl, -16					; fffffff0H
$LN173@codePointT:
	mov	BYTE PTR [eax], bl
$LN402@codePointT:

; 102  :    return result;

	mov	eax, esi

; 103  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN11@codePointT
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN11@codePointT:
	ret	0
__ehhandler$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; Json::codePointToUTF8
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ??0Reader@Json@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??0Reader@Json@@QAE@XZ PROC				; Json::Reader::Reader, COMDAT
; _this$ = ecx

; 111  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN79@Reader
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN79@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 111  : {

	lea	edi, DWORD PTR [esi+20]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 111  : {

	mov	DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [edi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [edi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [edi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN174@Reader
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN174@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], edi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 112  : }

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+60], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+56], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+104], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+100], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+84], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 20   :    : allowComments_( true )

	mov	WORD PTR [esi+108], 1

; 112  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??0Reader@Json@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@XZ ENDP				; Json::Reader::Reader
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ??0Reader@Json@@QAE@ABVFeatures@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_features$ = 8						; size = 4
??0Reader@Json@@QAE@ABVFeatures@1@@Z PROC		; Json::Reader::Reader, COMDAT
; _this$ = ecx

; 117  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN79@Reader
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN79@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 117  : {

	lea	edi, DWORD PTR [esi+20]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 117  : {

	mov	DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [edi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [edi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [edi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN174@Reader
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN174@Reader:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], edi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 116  :    : features_( features )

	mov	eax, DWORD PTR _features$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+60], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+56], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+40], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+104], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+100], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+84], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 116  :    : features_( features )

	mov	ax, WORD PTR [eax]
	mov	WORD PTR [esi+108], ax

; 118  : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0Reader@Json@@QAE@ABVFeatures@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??0Reader@Json@@QAE@ABVFeatures@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0Reader@Json@@QAE@ABVFeatures@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0Reader@Json@@QAE@ABVFeatures@1@@Z ENDP		; Json::Reader::Reader
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT
_document$ = 8						; size = 4
_root$ = 12						; size = 4
_collectComments$ = 16					; size = 1
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z PROC ; Json::Reader::parse, COMDAT
; _this$ = ecx

; 125  : {

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	mov	eax, DWORD PTR _document$[ebp]
	push	esi
	push	edi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 125  : {

	mov	edi, ecx

; 126  :    document_ = document;

	lea	esi, DWORD PTR [edi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	cmp	esi, eax
	je	SHORT $LN4@parse

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@parse:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN147@parse
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN147@parse:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 129  :    return parse( begin, end, root, collectComments );

	push	DWORD PTR _collectComments$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [edi+56]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 129  :    return parse( begin, end, root, collectComments );

	mov	ecx, edi
	push	DWORD PTR _root$[ebp]
	add	eax, esi
	push	eax
	push	esi
	call	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ; Json::Reader::parse
	pop	edi
	pop	esi

; 130  : }

	pop	ebp
	ret	12					; 0000000cH
?parse@Reader@Json@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVValue@2@_N@Z ENDP ; Json::Reader::parse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
_TEXT	SEGMENT
_doc$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_sin$ = 8						; size = 4
_root$ = 12						; size = 4
_collectComments$ = 16					; size = 1
?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z PROC ; Json::Reader::parse, COMDAT
; _this$ = ecx

; 137  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ecx, DWORD PTR _sin$[ebp]
	mov	ebx, DWORD PTR _root$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _doc$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _doc$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _doc$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 151  : 	return (getline(_STD move(_Istr), _Str, _Delim));

	push	ecx
	lea	edx, DWORD PTR _doc$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 145  :    std::string doc;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 151  : 	return (getline(_STD move(_Istr), _Str, _Delim));

	call	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 126  :    document_ = document;

	lea	esi, DWORD PTR [edi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 151  : 	return (getline(_STD move(_Istr), _Str, _Delim));

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	lea	eax, DWORD PTR _doc$[ebp]
	cmp	esi, eax
	je	SHORT $LN119@parse

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN119@parse:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN263@parse
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN263@parse:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 129  :    return parse( begin, end, root, collectComments );

	push	DWORD PTR _collectComments$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [edi+56]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 129  :    return parse( begin, end, root, collectComments );

	mov	ecx, edi
	push	ebx
	add	eax, esi
	push	eax
	push	esi
	call	?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ; Json::Reader::parse
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR _doc$[ebp+20]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 147  :    return parse( doc, root, collectComments );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN379@parse

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR _doc$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN379@parse:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 147  :    return parse( doc, root, collectComments );

	mov	al, bl

; 148  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z$0:
	lea	ecx, DWORD PTR _doc$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?parse@Reader@Json@@QAE_NAAV?$basic_istream@DU?$char_traits@D@std@@@std@@AAVValue@2@_N@Z ENDP ; Json::Reader::parse
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
_TEXT	SEGMENT
_endDoc$GSCopy$1$ = -64					; size = 4
_beginDoc$GSCopy$1$ = -60				; size = 4
$T24 = -56						; size = 4
_token$ = -52						; size = 12
$T30 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_beginDoc$ = 8						; size = 4
_endDoc$ = 12						; size = 4
_root$ = 16						; size = 4
_collectComments$ = 20					; size = 1
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z PROC	; Json::Reader::parse, COMDAT
; _this$ = ecx

; 154  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	eax, DWORD PTR _endDoc$[ebp]
	xor	ecx, ecx
	cmp	BYTE PTR [esi+108], cl
	mov	edx, DWORD PTR _beginDoc$[ebp]
	mov	edi, DWORD PTR _root$[ebp]
	mov	DWORD PTR _endDoc$GSCopy$1$[ebp], eax

; 161  :    end_ = endDoc;

	mov	DWORD PTR [esi+68], eax
	movzx	eax, BYTE PTR _collectComments$[ebp]
	cmovne	ecx, eax
	mov	DWORD PTR _beginDoc$GSCopy$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 162  :    collectComments_ = collectComments;

	mov	BYTE PTR [esi+110], cl

; 166  :    commentsBefore_ = "";

	lea	ecx, DWORD PTR [esi+84]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 160  :    begin_ = beginDoc;

	mov	DWORD PTR [esi+64], edx

; 163  :    current_ = begin_;

	mov	DWORD PTR [esi+72], edx

; 164  :    lastValueEnd_ = 0;

	mov	DWORD PTR [esi+76], 0

; 165  :    lastValue_ = 0;

	mov	DWORD PTR [esi+80], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 167  :    errors_.clear();

	lea	ecx, DWORD PTR [esi+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1675 : 		_Tidy();

	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
	cmp	DWORD PTR [esi+16], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 168  :    while ( !nodes_.empty() )

	je	SHORT $LN3@parse
	npad	1
$LL2@parse:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN38@parse

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN38@parse:
	cmp	DWORD PTR [esi+16], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 168  :    while ( !nodes_.empty() )

	jne	SHORT $LL2@parse
$LN3@parse:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	lea	eax, DWORD PTR $T24[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 170  :    nodes_.push( &root );

	mov	DWORD PTR $T24[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	push	eax
	mov	ecx, esi
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 172  :    bool successful = readValue();

	mov	ecx, esi
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue

; 248  :    if ( features_.allowComments_ )

	cmp	BYTE PTR [esi+108], 0

; 172  :    bool successful = readValue();

	mov	bl, al

; 248  :    if ( features_.allowComments_ )

	je	SHORT $LN112@parse
$LL111@parse:

; 249  :    {
; 250  :       do
; 251  :       {
; 252  :          readToken( token );

	lea	eax, DWORD PTR _token$[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 253  :       }
; 254  :       while ( token.type_ == tokenComment );

	cmp	DWORD PTR _token$[ebp], 12		; 0000000cH
	je	SHORT $LL111@parse

; 255  :    }
; 256  :    else

	jmp	SHORT $LN113@parse
$LN112@parse:

; 257  :    {
; 258  :       readToken( token );

	lea	eax, DWORD PTR _token$[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
$LN113@parse:

; 173  :    Token token;
; 174  :    skipCommentTokens( token );
; 175  :    if ( collectComments_  &&  !commentsBefore_.empty() )

	cmp	BYTE PTR [esi+110], 0
	je	SHORT $LN5@parse
	cmp	DWORD PTR [esi+100], 0
	lea	eax, DWORD PTR [esi+84]
	je	SHORT $LN5@parse

; 176  :       root.setComment( commentsBefore_, commentAfter );

	push	2
	push	eax
	mov	ecx, edi
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
$LN5@parse:

; 177  :    if ( features_.strictRoot_ )

	cmp	BYTE PTR [esi+109], 0
	je	SHORT $LN7@parse
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1315 :    return type_ == nullValue  ||  type_ == arrayValue;

	mov	al, BYTE PTR [edi+8]
	test	al, al
	je	SHORT $LN7@parse
	cmp	al, 6
	je	SHORT $LN7@parse

; 1322 :    return type_ == nullValue  ||  type_ == objectValue;

	cmp	al, 7
	je	SHORT $LN7@parse
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 185  :          addError( "A valid JSON document must be either an array or an object value.",

	mov	eax, DWORD PTR _beginDoc$GSCopy$1$[ebp]
	lea	ecx, DWORD PTR $T30[ebp]
	mov	DWORD PTR _token$[ebp+4], eax
	mov	eax, DWORD PTR _endDoc$GSCopy$1$[ebp]
	push	OFFSET ??_C@_0EC@HCHNIDLM@A?5valid?5JSON?5document?5must?5be?5ei@
	mov	DWORD PTR _token$[ebp], 13		; 0000000dH
	mov	DWORD PTR _token$[ebp+8], eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	0
	lea	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	lea	eax, DWORD PTR $T30[ebp]
	mov	ecx, esi
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T30[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN141@parse

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T30[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN141@parse:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 187  :          return false;

	xor	al, al
	jmp	SHORT $LN1@parse
$LN7@parse:

; 188  :       }
; 189  :    }
; 190  :    return successful;

	mov	al, bl
$LN1@parse:

; 191  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z$0:
	lea	ecx, DWORD PTR $T30[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?parse@Reader@Json@@QAE_NPBD0AAVValue@2@_N@Z ENDP	; Json::Reader::parse
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readValue@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
$T74 = -96						; size = 12
$T5 = -84						; size = 12
_token$ = -72						; size = 12
$T11 = -60						; size = 16
$T10 = -60						; size = 16
$T9 = -60						; size = 16
$T75 = -56						; size = 12
_successful$1$ = -41					; size = 1
$T20 = -40						; size = 24
$T6 = -28						; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?readValue@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readValue, COMDAT
; _this$ = ecx

; 196  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readValue@Reader@Json@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 248  :    if ( features_.allowComments_ )

	cmp	BYTE PTR [edi+108], 0
	je	SHORT $LN23@readValue
$LL22@readValue:

; 249  :    {
; 250  :       do
; 251  :       {
; 252  :          readToken( token );

	lea	eax, DWORD PTR _token$[ebp]
	mov	ecx, edi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 253  :       }
; 254  :       while ( token.type_ == tokenComment );

	mov	ebx, DWORD PTR _token$[ebp]
	cmp	ebx, 12					; 0000000cH
	je	SHORT $LL22@readValue

; 255  :    }
; 256  :    else

	jmp	SHORT $LN24@readValue
$LN23@readValue:

; 257  :    {
; 258  :       readToken( token );

	lea	eax, DWORD PTR _token$[ebp]
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	ebx, DWORD PTR _token$[ebp]
$LN24@readValue:

; 197  :    Token token;
; 198  :    skipCommentTokens( token );
; 199  :    bool successful = true;
; 200  : 
; 201  :    if ( collectComments_  &&  !commentsBefore_.empty() )

	cmp	BYTE PTR [edi+110], 0
	mov	BYTE PTR _successful$1$[ebp], 1
	je	SHORT $LN4@readValue
	cmp	DWORD PTR [edi+100], 0
	je	SHORT $LN4@readValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	ecx
	lea	eax, DWORD PTR $T5[ebp]
	mov	ecx, edi
	push	eax
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN51@readValue
$LN50@readValue:
	mov	esi, DWORD PTR [esi]
$LN51@readValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	eax, edx
	mov	ecx, DWORD PTR [esi+8]

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	shr	eax, 2
	dec	ecx
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 203  :       currentValue().setComment( commentsBefore_, commentBefore );

	push	0
	lea	esi, DWORD PTR [edi+84]
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+ecx*4]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 203  :       currentValue().setComment( commentsBefore_, commentBefore );

	mov	ecx, DWORD PTR [eax+edx*4]
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@readValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 208  :    switch ( token.type_ )

	dec	ebx
	cmp	ebx, 8
	ja	$LN12@readValue
	jmp	DWORD PTR $LN348@readValue[ebx*4]
$LN5@readValue:

; 209  :    {
; 210  :    case tokenObjectBegin:
; 211  :       successful = readObject( token );

	lea	eax, DWORD PTR _token$[ebp]
	mov	ecx, edi
	push	eax
	call	?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readObject
	mov	bl, al

; 212  :       break;

	jmp	$LN2@readValue
$LN6@readValue:

; 213  :    case tokenArrayBegin:
; 214  :       successful = readArray( token );

	lea	eax, DWORD PTR _token$[ebp]
	mov	ecx, edi
	push	eax
	call	?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readArray
	mov	bl, al

; 215  :       break;

	jmp	$LN2@readValue
$LN7@readValue:

; 216  :    case tokenNumber:
; 217  :       successful = decodeNumber( token );

	lea	eax, DWORD PTR _token$[ebp]
	mov	ecx, edi
	push	eax
	call	?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeNumber
	mov	bl, al

; 218  :       break;

	jmp	$LN2@readValue
$LN8@readValue:

; 219  :    case tokenString:
; 220  :       successful = decodeString( token );

	lea	eax, DWORD PTR _token$[ebp]
	mov	ecx, edi
	push	eax
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeString
	mov	bl, al

; 221  :       break;

	jmp	SHORT $LN2@readValue
$LN9@readValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 408  :    : type_( booleanValue )

	mov	eax, DWORD PTR $T9[ebp+8]
	and	eax, -251				; ffffff05H

; 409  :    , comments_( 0 )

	mov	DWORD PTR $T9[ebp+12], 0
	or	eax, 5

; 410  : # ifdef JSON_VALUE_USE_INTERNAL_MAP
; 411  :    , itemIsUsed_( 0 )
; 412  : #endif
; 413  : {
; 414  :    value_.bool_ = value;

	mov	BYTE PTR $T9[ebp], 1
	mov	DWORD PTR $T9[ebp+8], eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 223  :       currentValue() = true;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 224  :       break;

	jmp	SHORT $LN347@readValue
$LN10@readValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 408  :    : type_( booleanValue )

	mov	eax, DWORD PTR $T10[ebp+8]
	and	eax, -251				; ffffff05H

; 409  :    , comments_( 0 )

	mov	DWORD PTR $T10[ebp+12], 0
	or	eax, 5

; 410  : # ifdef JSON_VALUE_USE_INTERNAL_MAP
; 411  :    , itemIsUsed_( 0 )
; 412  : #endif
; 413  : {
; 414  :    value_.bool_ = value;

	mov	BYTE PTR $T10[ebp], 0
	mov	DWORD PTR $T10[ebp+8], eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 226  :       currentValue() = false;

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 227  :       break;

	jmp	SHORT $LN347@readValue
$LN11@readValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 270  :    , allocated_( 0 )

	and	DWORD PTR $T11[ebp+8], -512		; fffffe00H

; 271  :    , comments_( 0 )

	mov	DWORD PTR $T11[ebp+12], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 229  :       currentValue() = Value();

	mov	DWORD PTR __$EHRec$[ebp+8], 3
$LN347@readValue:
	lea	eax, DWORD PTR $T11[ebp]
	mov	ecx, edi
	push	eax
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value
	mov	bl, BYTE PTR _successful$1$[ebp]
$LN2@readValue:

; 233  :    }
; 234  : 
; 235  :    if ( collectComments_ )

	cmp	BYTE PTR [edi+110], 0
	je	$LN232@readValue

; 236  :    {
; 237  :       lastValueEnd_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [edi+76], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	lea	eax, DWORD PTR $T74[ebp]
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T75[ebp]
	mov	ecx, edi
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN340@readValue
$LN339@readValue:
	mov	esi, DWORD PTR [esi]
$LN340@readValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	ecx, edx
	mov	eax, DWORD PTR [esi+8]
	dec	eax
	shr	ecx, 2
	and	ecx, eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 238  :       lastValue_ = &currentValue();

	mov	eax, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 238  :       lastValue_ = &currentValue();

	mov	eax, DWORD PTR [eax+ecx*4]
	mov	eax, DWORD PTR [eax+edx*4]
	mov	DWORD PTR [edi+80], eax

; 239  :    }
; 240  : 
; 241  :    return successful;

	jmp	SHORT $LN232@readValue
$LN12@readValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	46					; 0000002eH
	push	OFFSET ??_C@_0CP@GDDNKEK@Syntax?5error?3?5value?0?5object?5or?5a@
	lea	ecx, DWORD PTR $T20[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T20[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T20[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T20[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 232  :       return addError( "Syntax error: value, object or array expected.", token );

	push	0
	lea	eax, DWORD PTR _token$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	push	eax
	lea	eax, DWORD PTR $T20[ebp]
	mov	ecx, edi
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T20[ebp+20]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 232  :       return addError( "Syntax error: value, object or array expected.", token );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN232@readValue

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR $T20[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN232@readValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 232  :       return addError( "Syntax error: value, object or array expected.", token );

	mov	al, bl

; 242  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	1
$LN348@readValue:
	DD	$LN5@readValue
	DD	$LN12@readValue
	DD	$LN6@readValue
	DD	$LN12@readValue
	DD	$LN8@readValue
	DD	$LN7@readValue
	DD	$LN9@readValue
	DD	$LN10@readValue
	DD	$LN11@readValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$0:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$1:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$2:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readValue@Reader@Json@@AAE_NXZ$3:
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readValue@Reader@Json@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readValue@Reader@Json@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?readValue@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readValue
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z
_TEXT	SEGMENT
_token$ = 8						; size = 4
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z PROC	; Json::Reader::skipCommentTokens, COMDAT
; _this$ = ecx

; 247  : {

	push	ebp
	mov	ebp, esp
	push	edi
	mov	edi, ecx

; 248  :    if ( features_.allowComments_ )

	cmp	BYTE PTR [edi+108], 0
	je	SHORT $LN5@skipCommen
	push	esi
	mov	esi, DWORD PTR _token$[ebp]
$LL4@skipCommen:

; 249  :    {
; 250  :       do
; 251  :       {
; 252  :          readToken( token );

	push	esi
	mov	ecx, edi
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 253  :       }
; 254  :       while ( token.type_ == tokenComment );

	cmp	DWORD PTR [esi], 12			; 0000000cH
	je	SHORT $LL4@skipCommen
	pop	esi
	pop	edi

; 259  :    }
; 260  : }

	pop	ebp
	ret	4
$LN5@skipCommen:

; 255  :    }
; 256  :    else
; 257  :    {
; 258  :       readToken( token );

	push	DWORD PTR _token$[ebp]
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	pop	edi

; 259  :    }
; 260  : }

	pop	ebp
	ret	4
?skipCommentTokens@Reader@Json@@AAEXAAVToken@12@@Z ENDP	; Json::Reader::skipCommentTokens
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
_TEXT	SEGMENT
$T1 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_type$ = 8						; size = 4
_token$ = 12						; size = 4
_message$ = 16						; size = 4
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z PROC ; Json::Reader::expectToken, COMDAT
; _this$ = ecx

; 265  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	edi, DWORD PTR _token$[ebp]
	mov	esi, DWORD PTR _message$[ebp]

; 266  :    readToken( token );

	push	edi
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 267  :    if ( token.type_ != type )

	mov	eax, DWORD PTR [edi]
	cmp	eax, DWORD PTR _type$[ebp]
	je	SHORT $LN2@expectToke
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T1[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T1[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T1[ebp], 0

; 523  : 		return (*_First == 0 ? 0

	jne	SHORT $LN115@expectToke
	xor	ecx, ecx
	jmp	SHORT $LN116@expectToke
$LN115@expectToke:
	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
$LL218@expectToke:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL218@expectToke
	sub	ecx, edx
$LN116@expectToke:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	esi
	lea	ecx, DWORD PTR $T1[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 268  :       return addError( message, token );

	push	0
	push	edi
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	mov	ecx, ebx
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T1[ebp+20]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 268  :       return addError( message, token );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN123@expectToke

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR $T1[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN123@expectToke:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 268  :       return addError( message, token );

	mov	al, bl
	jmp	SHORT $LN1@expectToke
$LN2@expectToke:

; 269  :    return true;

	mov	al, 1
$LN1@expectToke:

; 270  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?expectToken@Reader@Json@@AAE_NW4TokenType@12@AAVToken@12@PBD@Z ENDP ; Json::Reader::expectToken
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readToken@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
_token$ = 8						; size = 4
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readToken, COMDAT
; _this$ = ecx

; 275  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx

; 351  :    while ( current_ != end_ )

	mov	edx, DWORD PTR [edi+68]
	cmp	DWORD PTR [edi+72], edx
	je	SHORT $LN35@readToken
	npad	1
$LL21@readToken:

; 352  :    {
; 353  :       Char c = *current_;

	mov	ecx, DWORD PTR [edi+72]
	mov	al, BYTE PTR [ecx]

; 354  :       if ( c == ' '  ||  c == '\t'  ||  c == '\r'  ||  c == '\n' )

	cmp	al, 32					; 00000020H
	je	SHORT $LN25@readToken
	cmp	al, 9
	je	SHORT $LN25@readToken
	cmp	al, 13					; 0000000dH
	je	SHORT $LN25@readToken
	cmp	al, 10					; 0000000aH
	jne	SHORT $LN35@readToken
$LN25@readToken:

; 355  :          ++current_;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi+72], eax
	cmp	eax, edx
	jne	SHORT $LL21@readToken
$LN35@readToken:

; 276  :    skipSpaces();
; 277  :    token.start_ = current_;

	mov	esi, DWORD PTR _token$[ebp]
	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+4], eax

; 810  :    if ( current_ == end_ )

	mov	eax, DWORD PTR [edi+72]
	cmp	eax, DWORD PTR [edi+68]
	jne	SHORT $LN28@readToken

; 811  :       return 0;

	xor	cl, cl
	jmp	SHORT $LN27@readToken
$LN28@readToken:

; 812  :    return *current_++;

	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [edi+72], eax
$LN27@readToken:

; 278  :    Char c = getNextChar();
; 279  :    bool ok = true;
; 280  :    switch ( c )

	movsx	eax, cl
	cmp	eax, 125				; 0000007dH
	ja	$LN33@readToken
	movzx	eax, BYTE PTR $LN34@readToken[eax]
	jmp	DWORD PTR $LN38@readToken[eax*4]
$LN4@readToken:

; 281  :    {
; 282  :    case '{':
; 283  :       token.type_ = tokenObjectBegin;

	mov	DWORD PTR [esi], 1

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN5@readToken:

; 284  :       break;
; 285  :    case '}':
; 286  :       token.type_ = tokenObjectEnd;

	mov	DWORD PTR [esi], 2

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN6@readToken:

; 287  :       break;
; 288  :    case '[':
; 289  :       token.type_ = tokenArrayBegin;

	mov	DWORD PTR [esi], 3

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN7@readToken:

; 290  :       break;
; 291  :    case ']':
; 292  :       token.type_ = tokenArrayEnd;

	mov	DWORD PTR [esi], 4

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN8@readToken:

; 293  :       break;
; 294  :    case '"':
; 295  :       token.type_ = tokenString;
; 296  :       ok = readString();

	mov	ecx, edi
	mov	DWORD PTR [esi], 5
	call	?readString@Reader@Json@@AAE_NXZ	; Json::Reader::readString

; 297  :       break;

	jmp	SHORT $LN2@readToken
$LN9@readToken:

; 298  :    case '/':
; 299  :       token.type_ = tokenComment;
; 300  :       ok = readComment();

	mov	ecx, edi
	mov	DWORD PTR [esi], 12			; 0000000cH
	call	?readComment@Reader@Json@@AAE_NXZ	; Json::Reader::readComment

; 301  :       break;

	jmp	SHORT $LN2@readToken
$LN10@readToken:

; 302  :    case '0':
; 303  :    case '1':
; 304  :    case '2':
; 305  :    case '3':
; 306  :    case '4':
; 307  :    case '5':
; 308  :    case '6':
; 309  :    case '7':
; 310  :    case '8':
; 311  :    case '9':
; 312  :    case '-':
; 313  :       token.type_ = tokenNumber;
; 314  :       readNumber();

	mov	ecx, edi
	mov	DWORD PTR [esi], 6
	call	?readNumber@Reader@Json@@AAEXXZ		; Json::Reader::readNumber

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN11@readToken:

; 315  :       break;
; 316  :    case 't':
; 317  :       token.type_ = tokenTrue;
; 318  :       ok = match( "rue", 3 );

	push	3
	mov	DWORD PTR [esi], 7
	push	OFFSET ??_C@_03FFDNHNKN@rue?$AA@

; 319  :       break;

	jmp	SHORT $LN36@readToken
$LN12@readToken:

; 320  :    case 'f':
; 321  :       token.type_ = tokenFalse;
; 322  :       ok = match( "alse", 4 );

	push	4
	mov	DWORD PTR [esi], 8
	push	OFFSET ??_C@_04KCECFHEP@alse?$AA@

; 323  :       break;

	jmp	SHORT $LN36@readToken
$LN13@readToken:

; 324  :    case 'n':
; 325  :       token.type_ = tokenNull;
; 326  :       ok = match( "ull", 3 );

	push	3
	mov	DWORD PTR [esi], 9
	push	OFFSET ??_C@_03KNPGGKC@ull?$AA@
$LN36@readToken:
	mov	ecx, edi
	call	?match@Reader@Json@@AAE_NPBDH@Z		; Json::Reader::match
$LN2@readToken:

; 336  :       break;
; 337  :    default:
; 338  :       ok = false;
; 339  :       break;
; 340  :    }
; 341  :    if ( !ok )

	test	al, al
	jne	SHORT $LN18@readToken
$LN33@readToken:

; 342  :       token.type_ = tokenError;

	mov	DWORD PTR [esi], 13			; 0000000dH
$LN18@readToken:

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN14@readToken:

; 327  :       break;
; 328  :    case ',':
; 329  :       token.type_ = tokenArraySeparator;

	mov	DWORD PTR [esi], 10			; 0000000aH

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN15@readToken:

; 330  :       break;
; 331  :    case ':':
; 332  :       token.type_ = tokenMemberSeparator;

	mov	DWORD PTR [esi], 11			; 0000000bH

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
$LN16@readToken:

; 333  :       break;
; 334  :    case 0:
; 335  :       token.type_ = tokenEndOfStream;

	mov	DWORD PTR [esi], 0

; 343  :    token.end_ = current_;

	mov	eax, DWORD PTR [edi+72]
	mov	DWORD PTR [esi+8], eax

; 344  :    return true;

	mov	al, 1
	pop	edi
	pop	esi

; 345  : }

	pop	ebp
	ret	4
	npad	1
$LN38@readToken:
	DD	$LN16@readToken
	DD	$LN8@readToken
	DD	$LN14@readToken
	DD	$LN10@readToken
	DD	$LN9@readToken
	DD	$LN15@readToken
	DD	$LN6@readToken
	DD	$LN7@readToken
	DD	$LN12@readToken
	DD	$LN13@readToken
	DD	$LN11@readToken
	DD	$LN4@readToken
	DD	$LN5@readToken
	DD	$LN33@readToken
$LN34@readToken:
	DB	0
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	1
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	2
	DB	3
	DB	13					; 0000000dH
	DB	4
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	3
	DB	5
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	6
	DB	13					; 0000000dH
	DB	7
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	8
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	9
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	10					; 0000000aH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	13					; 0000000dH
	DB	11					; 0000000bH
	DB	13					; 0000000dH
	DB	12					; 0000000cH
?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readToken
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?skipSpaces@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
?skipSpaces@Reader@Json@@AAEXXZ PROC			; Json::Reader::skipSpaces, COMDAT
; _this$ = ecx

; 350  : {

	push	esi

; 351  :    while ( current_ != end_ )

	mov	esi, DWORD PTR [ecx+68]
	cmp	DWORD PTR [ecx+72], esi
	je	SHORT $LN11@skipSpaces
	npad	7
$LL2@skipSpaces:

; 352  :    {
; 353  :       Char c = *current_;

	mov	edx, DWORD PTR [ecx+72]
	mov	al, BYTE PTR [edx]

; 354  :       if ( c == ' '  ||  c == '\t'  ||  c == '\r'  ||  c == '\n' )

	cmp	al, 32					; 00000020H
	je	SHORT $LN6@skipSpaces
	cmp	al, 9
	je	SHORT $LN6@skipSpaces
	cmp	al, 13					; 0000000dH
	je	SHORT $LN6@skipSpaces
	cmp	al, 10					; 0000000aH
	jne	SHORT $LN11@skipSpaces
$LN6@skipSpaces:

; 355  :          ++current_;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx+72], eax
	cmp	eax, esi
	jne	SHORT $LL2@skipSpaces
$LN11@skipSpaces:
	pop	esi

; 356  :       else
; 357  :          break;
; 358  :    }
; 359  : }

	ret	0
?skipSpaces@Reader@Json@@AAEXXZ ENDP			; Json::Reader::skipSpaces
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?match@Reader@Json@@AAE_NPBDH@Z
_TEXT	SEGMENT
_pattern$ = 8						; size = 4
_patternLength$ = 12					; size = 4
?match@Reader@Json@@AAE_NPBDH@Z PROC			; Json::Reader::match, COMDAT
; _this$ = ecx

; 365  : {

	push	ebp
	mov	ebp, esp
	push	ebx
	mov	ebx, ecx
	push	esi

; 366  :    if ( end_ - current_ < patternLength )

	mov	esi, DWORD PTR _patternLength$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+68]
	mov	edi, DWORD PTR [ebx+72]
	sub	eax, edi
	cmp	eax, esi
	jge	SHORT $LN4@match
$LN8@match:
	pop	edi
	pop	esi

; 367  :       return false;

	xor	al, al
	pop	ebx

; 374  : }

	pop	ebp
	ret	8
$LN4@match:

; 368  :    int index = patternLength;

	mov	edx, esi

; 369  :    while ( index-- )

	test	esi, esi
	je	SHORT $LN9@match

; 370  :       if ( current_[index] != pattern[index] )

	mov	eax, DWORD PTR _pattern$[ebp]
	sub	edi, eax
	lea	ecx, DWORD PTR [eax+esi]
	npad	2
$LL2@match:
	mov	al, BYTE PTR [edi+ecx-1]
	lea	ecx, DWORD PTR [ecx-1]
	dec	edx
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN8@match

; 369  :    while ( index-- )

	test	edx, edx
	jne	SHORT $LL2@match

; 370  :       if ( current_[index] != pattern[index] )

	mov	edi, DWORD PTR [ebx+72]
$LN9@match:

; 371  :          return false;
; 372  :    current_ += patternLength;

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	mov	DWORD PTR [ebx+72], eax

; 373  :    return true;

	mov	al, 1
	pop	esi
	pop	ebx

; 374  : }

	pop	ebp
	ret	8
?match@Reader@Json@@AAE_NPBDH@Z ENDP			; Json::Reader::match
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
_c$1$ = -1						; size = 1
?readComment@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readComment, COMDAT
; _this$ = ecx

; 379  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	push	edi

; 380  :    Location commentBegin = current_ - 1;

	mov	eax, DWORD PTR [esi+72]

; 810  :    if ( current_ == end_ )

	mov	ecx, DWORD PTR [esi+68]

; 380  :    Location commentBegin = current_ - 1;

	lea	edi, DWORD PTR [eax-1]

; 810  :    if ( current_ == end_ )

	cmp	eax, ecx
	je	SHORT $LN39@readCommen

; 811  :       return 0;
; 812  :    return *current_++;

	mov	dl, BYTE PTR [eax]
	inc	eax
	mov	BYTE PTR _c$1$[ebp], dl
	mov	DWORD PTR [esi+72], eax

; 381  :    Char c = getNextChar();
; 382  :    bool successful = false;
; 383  :    if ( c == '*' )

	cmp	dl, 42					; 0000002aH
	jne	SHORT $LN2@readCommen

; 384  :       successful = readCStyleComment();

	mov	ecx, esi
	call	?readCStyleComment@Reader@Json@@AAE_NXZ	; Json::Reader::readCStyleComment

; 386  :       successful = readCppStyleComment();
; 387  :    if ( !successful )

	test	al, al
	jne	SHORT $LN44@readCommen
$LN39@readCommen:
	pop	edi

; 388  :       return false;

	xor	al, al
	pop	esi

; 402  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@readCommen:

; 385  :    else if ( c == '/' )

	cmp	dl, 47					; 0000002fH
	jne	SHORT $LN39@readCommen

; 441  :    while ( current_ != end_ )

	cmp	eax, ecx
	je	SHORT $LN5@readCommen
	npad	1
$LL15@readCommen:

; 810  :    if ( current_ == end_ )

	cmp	eax, ecx
	je	SHORT $LN41@readCommen

; 811  :       return 0;
; 812  :    return *current_++;

	mov	dl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+72], eax

; 444  :       if (  c == '\r'  ||  c == '\n' )

	cmp	dl, 13					; 0000000dH
	je	SHORT $LN44@readCommen
	cmp	dl, 10					; 0000000aH
	je	SHORT $LN44@readCommen
$LN41@readCommen:

; 403  : 
; 404  : 
; 405  : void 
; 406  : Reader::addComment( Location begin, 
; 407  :                     Location end, 
; 408  :                     CommentPlacement placement )
; 409  : {
; 410  :    assert( collectComments_ );
; 411  :    if ( placement == commentAfterOnSameLine )
; 412  :    {
; 413  :       assert( lastValue_ != 0 );
; 414  :       lastValue_->setComment( std::string( begin, end ), placement );
; 415  :    }
; 416  :    else
; 417  :    {
; 418  :       if ( !commentsBefore_.empty() )
; 419  :          commentsBefore_ += "\n";
; 420  :       commentsBefore_ += std::string( begin, end );
; 421  :    }
; 422  : }
; 423  : 
; 424  : 
; 425  : bool 
; 426  : Reader::readCStyleComment()
; 427  : {
; 428  :    while ( current_ != end_ )
; 429  :    {
; 430  :       Char c = getNextChar();
; 431  :       if ( c == '*'  &&  *current_ == '/' )
; 432  :          break;
; 433  :    }
; 434  :    return getNextChar() == '/';
; 435  : }
; 436  : 
; 437  : 
; 438  : bool 
; 439  : Reader::readCppStyleComment()
; 440  : {
; 441  :    while ( current_ != end_ )

	cmp	DWORD PTR [esi+72], ecx
	jne	SHORT $LL15@readCommen
$LN44@readCommen:
	mov	dl, BYTE PTR _c$1$[ebp]
$LN5@readCommen:

; 389  : 
; 390  :    if ( collectComments_ )

	cmp	BYTE PTR [esi+110], 0
	je	SHORT $LN6@readCommen

; 391  :    {
; 392  :       CommentPlacement placement = commentBefore;
; 393  :       if ( lastValueEnd_  &&  !containsNewLine( lastValueEnd_, commentBegin ) )

	mov	eax, DWORD PTR [esi+76]
	push	ebx
	xor	ebx, ebx
	test	eax, eax
	je	SHORT $LN8@readCommen

; 63   :    for ( ;begin < end; ++begin )

	cmp	eax, edi
	jae	SHORT $LN25@readCommen
$LL26@readCommen:

; 64   :       if ( *begin == '\n'  ||  *begin == '\r' )

	mov	cl, BYTE PTR [eax]
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN8@readCommen
	cmp	cl, 13					; 0000000dH
	je	SHORT $LN8@readCommen

; 63   :    for ( ;begin < end; ++begin )

	inc	eax
	cmp	eax, edi
	jb	SHORT $LL26@readCommen
$LN25@readCommen:

; 394  :       {
; 395  :          if ( c != '*'  ||  !containsNewLine( commentBegin, current_ ) )

	cmp	dl, 42					; 0000002aH
	jne	SHORT $LN9@readCommen
	mov	edx, DWORD PTR [esi+72]
	mov	ecx, edi
	call	?containsNewLine@Json@@YA_NPBD0@Z	; Json::containsNewLine
	test	al, al
	jne	SHORT $LN8@readCommen
$LN9@readCommen:

; 396  :             placement = commentAfterOnSameLine;

	mov	ebx, 1
$LN8@readCommen:

; 397  :       }
; 398  : 
; 399  :       addComment( commentBegin, current_, placement );

	push	ebx
	push	DWORD PTR [esi+72]
	mov	ecx, esi
	push	edi
	call	?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ; Json::Reader::addComment
	pop	ebx
$LN6@readCommen:

; 400  :    }
; 401  :    return true;

	pop	edi
	mov	al, 1
	pop	esi

; 402  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?readComment@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readComment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
_TEXT	SEGMENT
$T64 = -64						; size = 24
$T3 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_begin$ = 8						; size = 4
_end$ = 12						; size = 4
_placement$ = 16					; size = 4
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z PROC ; Json::Reader::addComment, COMDAT
; _this$ = ecx

; 409  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx

; 410  :    assert( collectComments_ );
; 411  :    if ( placement == commentAfterOnSameLine )

	cmp	DWORD PTR _placement$[ebp], 1
	mov	edi, DWORD PTR _begin$[ebp]
	mov	esi, DWORD PTR _end$[ebp]
	jne	SHORT $LN2@addComment
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	cmp	edi, esi
	je	SHORT $LN128@addComment

; 906  : 			assign(_First, _Last - _First);

	sub	esi, edi
	lea	ecx, DWORD PTR $T3[ebp]
	push	esi
	push	edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN128@addComment:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 414  :       lastValue_->setComment( std::string( begin, end ), placement );

	push	1
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR [ebx+80]
	push	eax
	call	?setComment@Value@Json@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::setComment
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN383@addComment

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T3[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 416  :    else

	jmp	SHORT $LN479@addComment
$LN2@addComment:
	cmp	DWORD PTR [ebx+100], 0

; 417  :    {
; 418  :       if ( !commentsBefore_.empty() )

	je	SHORT $LN4@addComment
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 419  :          commentsBefore_ += "\n";

	lea	ecx, DWORD PTR [ebx+84]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN4@addComment:

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T64[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T64[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T64[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	cmp	edi, esi
	je	SHORT $LN371@addComment

; 906  : 			assign(_First, _Last - _First);

	sub	esi, edi
	lea	ecx, DWORD PTR $T64[ebp]
	push	esi
	push	edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN371@addComment:

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	lea	eax, DWORD PTR $T64[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 420  :       commentsBefore_ += std::string( begin, end );

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 420  :       commentsBefore_ += std::string( begin, end );

	lea	ecx, DWORD PTR [ebx+84]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T64[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN383@addComment

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T64[ebp]
$LN479@addComment:
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN383@addComment:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 422  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z$1:
	lea	ecx, DWORD PTR $T64[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addComment@Reader@Json@@AAEXPBD0W4CommentPlacement@2@@Z ENDP ; Json::Reader::addComment
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readCStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readCStyleComment@Reader@Json@@AAE_NXZ PROC		; Json::Reader::readCStyleComment, COMDAT
; _this$ = ecx

; 427  : {

	push	esi
	mov	esi, ecx

; 428  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi+68]
	cmp	eax, edx
	je	SHORT $LN17@readCStyle
$LN19@readCStyle:

; 812  :    return *current_++;

	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+72], eax

; 429  :    {
; 430  :       Char c = getNextChar();
; 431  :       if ( c == '*'  &&  *current_ == '/' )

	cmp	cl, 42					; 0000002aH
	jne	SHORT $LN4@readCStyle
	cmp	BYTE PTR [eax], 47			; 0000002fH
	je	SHORT $LN17@readCStyle
$LN4@readCStyle:

; 428  :    while ( current_ != end_ )

	cmp	eax, edx
	jne	SHORT $LN19@readCStyle
$LN17@readCStyle:

; 810  :    if ( current_ == end_ )

	mov	eax, DWORD PTR [esi+72]
	cmp	eax, edx
	jne	SHORT $LN10@readCStyle

; 811  :       return 0;

	xor	cl, cl
	cmp	cl, 47					; 0000002fH
	pop	esi
	sete	al

; 432  :          break;
; 433  :    }
; 434  :    return getNextChar() == '/';
; 435  : }

	ret	0
$LN10@readCStyle:

; 812  :    return *current_++;

	mov	cl, BYTE PTR [eax]
	inc	eax
	cmp	cl, 47					; 0000002fH
	mov	DWORD PTR [esi+72], eax
	pop	esi
	sete	al

; 432  :          break;
; 433  :    }
; 434  :    return getNextChar() == '/';
; 435  : }

	ret	0
?readCStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCStyleComment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readCppStyleComment@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readCppStyleComment@Reader@Json@@AAE_NXZ PROC		; Json::Reader::readCppStyleComment, COMDAT
; _this$ = ecx

; 440  : {

	push	esi
	mov	esi, ecx

; 441  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [esi+72]
	mov	edx, DWORD PTR [esi+68]
	cmp	eax, edx
	je	SHORT $LN20@readCppSty
$LN22@readCppSty:

; 812  :    return *current_++;

	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [esi+72], eax

; 442  :    {
; 443  :       Char c = getNextChar();
; 444  :       if (  c == '\r'  ||  c == '\n' )

	cmp	cl, 13					; 0000000dH
	je	SHORT $LN20@readCppSty
	cmp	cl, 10					; 0000000aH
	je	SHORT $LN20@readCppSty

; 441  :    while ( current_ != end_ )

	cmp	eax, edx
	jne	SHORT $LN22@readCppSty
$LN20@readCppSty:

; 445  :          break;
; 446  :    }
; 447  :    return true;

	mov	al, 1
	pop	esi

; 448  : }

	ret	0
?readCppStyleComment@Reader@Json@@AAE_NXZ ENDP		; Json::Reader::readCppStyleComment
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readNumber@Reader@Json@@AAEXXZ
_TEXT	SEGMENT
?readNumber@Reader@Json@@AAEXXZ PROC			; Json::Reader::readNumber, COMDAT
; _this$ = ecx

; 453  : {

	push	esi

; 454  :    while ( current_ != end_ )

	mov	esi, DWORD PTR [ecx+68]
	cmp	DWORD PTR [ecx+72], esi
	je	SHORT $LN17@readNumber
	npad	7
$LL2@readNumber:

; 455  :    {
; 456  :       if ( !(*current_ >= '0'  &&  *current_ <= '9')  &&

	mov	edx, DWORD PTR [ecx+72]
	mov	al, BYTE PTR [edx]
	cmp	al, 48					; 00000030H
	jl	SHORT $LN5@readNumber
	cmp	al, 57					; 00000039H
	jle	SHORT $LN9@readNumber
$LN5@readNumber:

; 55   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4  ||  c == c5;

	cmp	al, 46					; 0000002eH
	je	SHORT $LN9@readNumber
	cmp	al, 101					; 00000065H
	je	SHORT $LN9@readNumber
	cmp	al, 69					; 00000045H
	je	SHORT $LN9@readNumber
	cmp	al, 43					; 0000002bH
	je	SHORT $LN9@readNumber
	cmp	al, 45					; 0000002dH
	jne	SHORT $LN17@readNumber
$LN9@readNumber:

; 457  :            !in( *current_, '.', 'e', 'E', '+', '-' ) )
; 458  :          break;
; 459  :       ++current_;

	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx+72], eax
	cmp	eax, esi
	jne	SHORT $LL2@readNumber
$LN17@readNumber:
	pop	esi

; 460  :    }
; 461  : }

	ret	0
?readNumber@Reader@Json@@AAEXXZ ENDP			; Json::Reader::readNumber
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readString@Reader@Json@@AAE_NXZ
_TEXT	SEGMENT
?readString@Reader@Json@@AAE_NXZ PROC			; Json::Reader::readString, COMDAT
; _this$ = ecx

; 466  :    Char c = 0;
; 467  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [ecx+72]
	xor	dl, dl
	push	esi
	mov	esi, DWORD PTR [ecx+68]
	cmp	eax, esi
	je	SHORT $LN18@readString
$LN9@readString:

; 812  :    return *current_++;

	mov	dl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [ecx+72], eax

; 468  :    {
; 469  :       c = getNextChar();
; 470  :       if ( c == '\\' )

	cmp	dl, 92					; 0000005cH
	jne	SHORT $LN4@readString

; 810  :    if ( current_ == end_ )

	cmp	eax, esi
	je	SHORT $LN6@readString

; 811  :       return 0;
; 812  :    return *current_++;

	inc	eax
	mov	DWORD PTR [ecx+72], eax

; 813  : }

	jmp	SHORT $LN6@readString
$LN4@readString:

; 471  :          getNextChar();
; 472  :       else if ( c == '"' )

	cmp	dl, 34					; 00000022H
	je	SHORT $LN19@readString
$LN6@readString:

; 466  :    Char c = 0;
; 467  :    while ( current_ != end_ )

	mov	eax, DWORD PTR [ecx+72]
	cmp	eax, esi
	jne	SHORT $LN9@readString
$LN18@readString:
	cmp	dl, 34					; 00000022H
$LN19@readString:
	sete	al
	pop	esi

; 473  :          break;
; 474  :    }
; 475  :    return c == '"';
; 476  : }

	ret	0
?readString@Reader@Json@@AAE_NXZ ENDP			; Json::Reader::readString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T28 = -108						; size = 4
$T79 = -108						; size = 4
$T27 = -104						; size = 16
_tokenName$ = -100					; size = 12
$T47 = -88						; size = 24
$T37 = -76						; size = 12
_comma$210 = -76					; size = 12
_name$ = -64						; size = 24
$T130 = -40						; size = 24
$T101 = -40						; size = 24
$T36 = -28						; size = 12
_colon$211 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tokenStart$ = 8					; size = 4
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readObject, COMDAT
; _this$ = ecx

; 481  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _name$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _name$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _name$[ebp], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 483  :    std::string name;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	eax, DWORD PTR $T27[ebp+8]
	and	eax, -505				; fffffe07H
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 271  :    , comments_( 0 )

	mov	DWORD PTR $T27[ebp+12], 0
	or	eax, 7

; 293  :       value_.map_ = new ObjectValues();

	push	8
	mov	DWORD PTR $T27[ebp+8], eax
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T28[ebp], esi
	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 293  :       value_.map_ = new ObjectValues();

	mov	DWORD PTR $T27[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	ecx
	lea	eax, DWORD PTR $T36[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 484  :    currentValue() = Value( objectValue );

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	eax
	lea	eax, DWORD PTR $T37[ebp]
	mov	ecx, edi
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN198@readObject
$LN197@readObject:
	mov	esi, DWORD PTR [esi]
$LN198@readObject:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	eax, edx
	mov	ecx, DWORD PTR [esi+8]

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	shr	eax, 2
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+ecx*4]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 484  :    currentValue() = Value( objectValue );

	lea	ecx, DWORD PTR $T27[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+edx*4]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T27[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 485  :    while ( readToken( tokenName ) )

	lea	eax, DWORD PTR _tokenName$[ebp]
	mov	ecx, edi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	$LN3@readObject
	npad	6
$LL2@readObject:

; 486  :    {
; 487  :       bool initialTokenOk = true;
; 488  :       while ( tokenName.type_ == tokenComment  &&  initialTokenOk )

	mov	eax, DWORD PTR _tokenName$[ebp]
	mov	cl, 1
	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN850@readObject
	npad	6
$LL4@readObject:
	test	cl, cl
	je	$LN3@readObject

; 489  :          initialTokenOk = readToken( tokenName );

	lea	eax, DWORD PTR _tokenName$[ebp]
	mov	ecx, edi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	cl, al
	mov	eax, DWORD PTR _tokenName$[ebp]
	cmp	eax, 12					; 0000000cH
	je	SHORT $LL4@readObject

; 490  :       if  ( !initialTokenOk )

	test	cl, cl
	je	$LN3@readObject
$LN850@readObject:

; 491  :          break;
; 492  :       if ( tokenName.type_ == tokenObjectEnd  &&  name.empty() )  // empty object

	cmp	eax, 2
	je	$LN851@readObject

; 493  :          return true;
; 494  :       if ( tokenName.type_ != tokenString )

	cmp	eax, 5
	jne	$LN3@readObject
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	lea	ecx, DWORD PTR _name$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 498  :       if ( !decodeString( tokenName, name ) )

	lea	eax, DWORD PTR _name$[ebp]
	mov	ecx, edi
	push	eax
	lea	eax, DWORD PTR _tokenName$[ebp]
	push	eax
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString

; 500  : 
; 501  :       Token colon;
; 502  :       if ( !readToken( colon ) ||  colon.type_ != tokenMemberSeparator )

	mov	ecx, edi
	test	al, al
	je	$LN837@readObject
	lea	eax, DWORD PTR _colon$211[ebp]
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	$LN13@readObject
	cmp	DWORD PTR _colon$211[ebp], 11		; 0000000bH
	jne	$LN13@readObject

; 505  :                                     colon, 
; 506  :                                     tokenObjectEnd );
; 507  :       }
; 508  :       Value &value = currentValue()[ name ];

	mov	ecx, edi
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR _name$[ebp+20], 16		; 00000010H
	lea	ecx, DWORD PTR _name$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1017 :    return resolveReference( key, false );

	push	0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmovae	ecx, DWORD PTR _name$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1017 :    return resolveReference( key, false );

	push	ecx
	mov	ecx, eax
	call	?resolveReference@Value@Json@@AAEAAV12@PBD_N@Z ; Json::Value::resolveReference
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 509  :       nodes_.push( &value );

	mov	DWORD PTR $T79[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	mov	ecx, edi
	lea	eax, DWORD PTR $T79[ebp]
	push	eax
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 510  :       bool ok = readValue();

	mov	ecx, edi
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [edi+16], -1
	jne	SHORT $LN351@readObject

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [edi+12], 0
$LN351@readObject:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 517  :             ||  ( comma.type_ != tokenObjectEnd  &&  

	mov	ecx, edi
	test	al, al
	je	$LN837@readObject
	lea	eax, DWORD PTR _comma$210[ebp]
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	je	$LN16@readObject
	mov	eax, DWORD PTR _comma$210[ebp]
	cmp	eax, 2
	je	SHORT $LN15@readObject
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN15@readObject
	cmp	eax, 12					; 0000000cH
	jne	$LN16@readObject
$LN15@readObject:

; 522  :                                     comma, 
; 523  :                                     tokenObjectEnd );
; 524  :       }
; 525  :       bool finalizeTokenOk = true;

	mov	cl, 1

; 526  :       while ( comma.type_ == tokenComment &&

	cmp	eax, 12					; 0000000cH
	jne	SHORT $LN854@readObject
$LL6@readObject:
	test	cl, cl
	je	SHORT $LN854@readObject

; 527  :               finalizeTokenOk )
; 528  :          finalizeTokenOk = readToken( comma );

	lea	eax, DWORD PTR _comma$210[ebp]
	mov	ecx, edi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	cl, al
	mov	eax, DWORD PTR _comma$210[ebp]
	cmp	eax, 12					; 0000000cH
	je	SHORT $LL6@readObject
$LN854@readObject:

; 529  :       if ( comma.type_ == tokenObjectEnd )

	cmp	eax, 2
	je	$LN841@readObject

; 485  :    while ( readToken( tokenName ) )

	lea	eax, DWORD PTR _tokenName$[ebp]
	mov	ecx, edi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	$LL2@readObject
$LN3@readObject:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	33					; 00000021H
	push	OFFSET ??_C@_0CC@JNCGHFHN@Missing?5?8?$HN?8?5or?5object?5member?5nam@
	lea	ecx, DWORD PTR $T130[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T130[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T130[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T130[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 532  :    return addErrorAndRecover( "Missing '}' or object member name", 

	push	2
	lea	eax, DWORD PTR _tokenName$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	push	eax
	lea	eax, DWORD PTR $T130[ebp]
	mov	ecx, edi
	push	eax
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T130[ebp+20]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 532  :    return addErrorAndRecover( "Missing '}' or object member name", 

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN635@readObject

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR $T130[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN635@readObject:

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T130[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T130[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T130[ebp], 0
$LN630@readObject:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _name$[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN853@readObject

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR _name$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN853@readObject:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 532  :    return addErrorAndRecover( "Missing '}' or object member name", 

	mov	al, bl

; 533  :                               tokenName, 
; 534  :                               tokenObjectEnd );
; 535  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN16@readObject:

; 518  :                   comma.type_ != tokenArraySeparator &&
; 519  : 		  comma.type_ != tokenComment ) )
; 520  :       {
; 521  :          return addErrorAndRecover( "Missing ',' or '}' in object declaration", 

	push	OFFSET ??_C@_0CJ@NGKOAFKA@Missing?5?8?0?8?5or?5?8?$HN?8?5in?5object?5dec@
	lea	ecx, DWORD PTR $T101[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	2
	lea	eax, DWORD PTR _comma$210[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	eax
	lea	eax, DWORD PTR $T101[ebp]
	mov	ecx, edi
	push	eax
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T101[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN630@readObject

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T101[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate

; 1018 : 		}

	jmp	SHORT $LN630@readObject
$LN13@readObject:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 504  :          return addErrorAndRecover( "Missing ':' after object member name", 

	push	OFFSET ??_C@_0CF@GCCDMCPH@Missing?5?8?3?8?5after?5object?5member?5@
	lea	ecx, DWORD PTR $T47[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	2
	lea	eax, DWORD PTR _colon$211[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	eax
	lea	eax, DWORD PTR $T47[ebp]
	mov	ecx, edi
	push	eax
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T47[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	$LN630@readObject

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T47[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
	jmp	$LN630@readObject
$LN837@readObject:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 499  :          return recoverFromError( tokenObjectEnd );

	push	2
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
	mov	bl, al
	jmp	$LN630@readObject
$LN851@readObject:
	cmp	DWORD PTR _name$[ebp+16], 0

; 491  :          break;
; 492  :       if ( tokenName.type_ == tokenObjectEnd  &&  name.empty() )  // empty object

	jne	$LN3@readObject
$LN841@readObject:
	mov	bl, 1
	jmp	$LN630@readObject
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR _name$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$32:
	push	8
	mov	eax, DWORD PTR $T28[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T27[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T130[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T101[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T47[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readObject@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readObject@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readObject
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T11 = -84						; size = 12
_endArray$64 = -84					; size = 12
$T1 = -72						; size = 16
$T10 = -56						; size = 12
_token$65 = -56						; size = 12
$T2 = -44						; size = 4
$T14 = -44						; size = 4
$T35 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tokenStart$ = 8					; size = 4
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::readArray, COMDAT
; _this$ = ecx

; 540  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR $T1[ebp+8]
	and	eax, -506				; fffffe06H
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 271  :    , comments_( 0 )

	mov	DWORD PTR $T1[ebp+12], 0
	or	eax, 6

; 293  :       value_.map_ = new ObjectValues();

	push	8
	mov	DWORD PTR $T1[ebp+8], eax
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	mov	DWORD PTR $T2[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 293  :       value_.map_ = new ObjectValues();

	mov	DWORD PTR $T1[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	ecx
	lea	eax, DWORD PTR $T10[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 541  :    currentValue() = Value( arrayValue );

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	eax
	lea	eax, DWORD PTR $T11[ebp]
	mov	ecx, edi
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN77@readArray
$LN76@readArray:
	mov	esi, DWORD PTR [esi]
$LN77@readArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	eax, edx
	mov	ecx, DWORD PTR [esi+8]

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	shr	eax, 2
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+ecx*4]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 541  :    currentValue() = Value( arrayValue );

	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+edx*4]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 351  :    while ( current_ != end_ )

	mov	edx, DWORD PTR [edi+68]
	cmp	DWORD PTR [edi+72], edx
	je	SHORT $LN275@readArray
	npad	1
$LL81@readArray:

; 352  :    {
; 353  :       Char c = *current_;

	mov	ecx, DWORD PTR [edi+72]
	mov	al, BYTE PTR [ecx]

; 354  :       if ( c == ' '  ||  c == '\t'  ||  c == '\r'  ||  c == '\n' )

	cmp	al, 32					; 00000020H
	je	SHORT $LN85@readArray
	cmp	al, 9
	je	SHORT $LN85@readArray
	cmp	al, 13					; 0000000dH
	je	SHORT $LN85@readArray
	cmp	al, 10					; 0000000aH
	jne	SHORT $LN275@readArray
$LN85@readArray:

; 355  :          ++current_;

	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi+72], eax
	cmp	eax, edx
	jne	SHORT $LL81@readArray
$LN275@readArray:

; 542  :    skipSpaces();
; 543  :    if ( *current_ == ']' ) // empty array

	mov	eax, DWORD PTR [edi+72]
	cmp	BYTE PTR [eax], 93			; 0000005dH
	jne	SHORT $LN6@readArray

; 544  :    {
; 545  :       Token endArray;
; 546  :       readToken( endArray );

	lea	eax, DWORD PTR _endArray$64[ebp]
	mov	ecx, edi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 547  :       return true;

	mov	al, 1
	jmp	$LN1@readArray
$LN6@readArray:

; 548  :    }
; 549  :    int index = 0;

	xor	esi, esi
	npad	5
$LL2@readArray:

; 552  :       Value &value = currentValue()[ index++ ];

	push	esi
	mov	ecx, edi
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
	call	??AValue@Json@@QAEAAV01@I@Z		; Json::Value::operator[]

; 553  :       nodes_.push( &value );

	mov	DWORD PTR $T14[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	mov	ecx, edi
	lea	eax, DWORD PTR $T14[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 552  :       Value &value = currentValue()[ index++ ];

	inc	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 108  : 		c.push_back(_STD move(_Val));

	push	eax
	call	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 554  :       bool ok = readValue();

	mov	ecx, edi
	call	?readValue@Reader@Json@@AAE_NXZ		; Json::Reader::readValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [edi+16], -1
	jne	SHORT $LN95@readArray

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [edi+12], 0
$LN95@readArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 561  :       ok = readToken( token );

	mov	ecx, edi
	test	al, al
	je	SHORT $LN264@readArray
	lea	eax, DWORD PTR _token$65[ebp]
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken

; 562  :       while ( token.type_ == tokenComment  &&  ok )

	mov	ecx, DWORD PTR _token$65[ebp]
	cmp	ecx, 12					; 0000000cH
	jne	SHORT $LN5@readArray
	npad	7
$LL4@readArray:
	test	al, al
	je	SHORT $LN9@readArray

; 563  :       {
; 564  :          ok = readToken( token );

	lea	eax, DWORD PTR _token$65[ebp]
	mov	ecx, edi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	mov	ecx, DWORD PTR _token$65[ebp]
	cmp	ecx, 12					; 0000000cH
	je	SHORT $LL4@readArray
$LN5@readArray:

; 565  :       }
; 566  :       bool badTokenType = ( token.type_ == tokenArraySeparator  &&  
; 567  :                             token.type_ == tokenArrayEnd );
; 568  :       if ( !ok  ||  badTokenType )

	test	al, al
	je	SHORT $LN9@readArray

; 571  :                                     token, 
; 572  :                                     tokenArrayEnd );
; 573  :       }
; 574  :       if ( token.type_ == tokenArrayEnd )

	cmp	ecx, 4
	jne	SHORT $LL2@readArray

; 575  :          break;
; 576  :    }
; 577  :    return true;

	mov	al, 1
	jmp	SHORT $LN1@readArray
$LN9@readArray:

; 570  :          return addErrorAndRecover( "Missing ',' or ']' in array declaration", 

	push	OFFSET ??_C@_0CI@DPCANLPO@Missing?5?8?0?8?5or?5?8?$FN?8?5in?5array?5decl@
	lea	ecx, DWORD PTR $T35[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	4
	lea	eax, DWORD PTR _token$65[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	eax
	lea	eax, DWORD PTR $T35[ebp]
	mov	ecx, edi
	push	eax
	call	?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ; Json::Reader::addErrorAndRecover
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T35[ebp+20]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 570  :          return addErrorAndRecover( "Missing ',' or ']' in array declaration", 

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN166@readArray

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR $T35[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN166@readArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 570  :          return addErrorAndRecover( "Missing ',' or ']' in array declaration", 

	mov	al, bl
	jmp	SHORT $LN1@readArray
$LN264@readArray:

; 555  :       nodes_.pop();
; 556  :       if ( !ok ) // error already set
; 557  :          return recoverFromError( tokenArrayEnd );

	push	4
	call	?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ; Json::Reader::recoverFromError
$LN1@readArray:

; 578  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	push	8
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T35[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?readArray@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?readArray@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::readArray
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
_token$GSCopy$1$ = -140					; size = 4
_this$GSCopy$1$ = -136					; size = 4
tv1897 = -129						; size = 1
_info$210 = -128					; size = 40
$T33 = -88						; size = 24
$T204 = -76						; size = 12
$T32 = -64						; size = 24
$T203 = -52						; size = 12
$T3 = -40						; size = 24
$T208 = -32						; size = 16
$T207 = -32						; size = 16
$T202 = -32						; size = 16
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeNumber, COMDAT
; _this$ = ecx

; 583  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 128				; 00000080H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edx
	mov	ebx, DWORD PTR _token$[ebp]

; 584  :    bool isDouble = false;

	xor	al, al
	mov	DWORD PTR _token$GSCopy$1$[ebp], ebx

; 585  :    for ( Location inspect = token.start_; inspect != token.end_; ++inspect )

	mov	edi, DWORD PTR [ebx+4]
	mov	ecx, edi
	mov	esi, DWORD PTR [ebx+8]
	cmp	ecx, esi
	je	SHORT $LN7@decodeNumb
	npad	3
$LL4@decodeNumb:

; 586  :    {
; 587  :       isDouble = isDouble  

	test	al, al
	jne	SHORT $LN17@decodeNumb
	mov	al, BYTE PTR [ecx]

; 49   :    return c == c1  ||  c == c2  ||  c == c3  ||  c == c4;

	cmp	al, 46					; 0000002eH
	je	SHORT $LN17@decodeNumb
	cmp	al, 101					; 00000065H
	je	SHORT $LN17@decodeNumb
	cmp	al, 69					; 00000045H
	je	SHORT $LN17@decodeNumb
	cmp	al, 43					; 0000002bH
	je	SHORT $LN17@decodeNumb

; 586  :    {
; 587  :       isDouble = isDouble  

	cmp	al, 45					; 0000002dH
	jne	SHORT $LN18@decodeNumb
	cmp	ecx, edi
	jne	SHORT $LN17@decodeNumb
$LN18@decodeNumb:
	xor	al, al
	jmp	SHORT $LN19@decodeNumb
$LN17@decodeNumb:
	mov	al, 1
$LN19@decodeNumb:

; 585  :    for ( Location inspect = token.start_; inspect != token.end_; ++inspect )

	inc	ecx
	cmp	ecx, esi
	jne	SHORT $LL4@decodeNumb

; 588  :                  ||  in( *inspect, '.', 'e', 'E', '+' )  
; 589  :                  ||  ( *inspect == '-'  &&  inspect != token.start_ );
; 590  :    }
; 591  :    if ( isDouble )

	test	al, al
	je	SHORT $LN7@decodeNumb

; 592  :       return decodeDouble( token );

	push	ebx
	mov	ecx, edx
	call	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeDouble
	jmp	$LN1@decodeNumb
$LN7@decodeNumb:

; 593  :    Location current = token.start_;

	mov	edx, edi

; 594  :    bool isNegative = *current == '-';

	mov	al, BYTE PTR [edx]
	mov	BYTE PTR tv1897[ebp], al
	cmp	al, 45					; 0000002dH

; 595  :    if ( isNegative )

	jne	SHORT $LN8@decodeNumb

; 596  :       ++current;

	inc	edx
$LN8@decodeNumb:
	cmp	al, 45					; 0000002dH
	mov	ecx, 429496729				; 19999999H
	mov	ebx, 214748364				; 0cccccccH
	cmovne	ebx, ecx

; 597  :    Value::UInt threshold = (isNegative ? Value::UInt(-Value::minInt) 
; 598  :                                        : Value::maxUInt) / 10;
; 599  :    Value::UInt value = 0;

	xor	ecx, ecx

; 600  :    while ( current < token.end_ )

	cmp	edx, esi
	jae	SHORT $LN6@decodeNumb
	npad	2
$LL5@decodeNumb:

; 601  :    {
; 602  :       Char c = *current++;

	mov	al, BYTE PTR [edx]
	inc	edx

; 603  :       if ( c < '0'  ||  c > '9' )

	cmp	al, 48					; 00000030H
	jl	$LN10@decodeNumb
	cmp	al, 57					; 00000039H
	jg	$LN10@decodeNumb

; 605  :       if ( value >= threshold )

	cmp	ecx, ebx
	jae	SHORT $LN830@decodeNumb

; 607  :       value = value * 10 + Value::UInt(c - '0');

	movsx	eax, al
	lea	ecx, DWORD PTR [ecx+ecx*4]
	lea	ecx, DWORD PTR [ecx-24]
	lea	ecx, DWORD PTR [eax+ecx*2]
	cmp	edx, esi
	jb	SHORT $LL5@decodeNumb

; 605  :       if ( value >= threshold )

	mov	al, BYTE PTR tv1897[ebp]
$LN6@decodeNumb:
	cmp	al, 45					; 0000002dH
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 314  :    , comments_( 0 )

	mov	DWORD PTR $T202[ebp+12], 0
	mov	eax, DWORD PTR $T202[ebp+8]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 609  :    if ( isNegative )

	jne	$LN12@decodeNumb
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 313  :    : type_( intValue )

	and	eax, -255				; ffffff01H
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 610  :       currentValue() = -Value::Int( value );

	neg	ecx
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 313  :    : type_( intValue )

	or	eax, 1

; 319  :    value_.int_ = value;

	mov	DWORD PTR $T202[ebp], ecx
	mov	DWORD PTR $T202[ebp+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	ecx
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T203[ebp]
	push	eax
	lea	eax, DWORD PTR $T204[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 610  :       currentValue() = -Value::Int( value );

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	jne	$LN819@decodeNumb
	jmp	$LN820@decodeNumb
$LN830@decodeNumb:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 606  :          return decodeDouble( token );

	mov	ecx, DWORD PTR _token$GSCopy$1$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	call	?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::decodeDouble
	jmp	$LN1@decodeNumb
$LN10@decodeNumb:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	cmp	edi, esi
	je	SHORT $LN152@decodeNumb

; 906  : 			assign(_First, _Last - _First);

	sub	esi, edi
	lea	ecx, DWORD PTR $T3[ebp]
	push	esi
	push	edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN152@decodeNumb:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 604  :          return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	mov	edx, OFFSET ??_C@_01GEODFPGF@?8?$AA@
	lea	ecx, DWORD PTR $T32[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	mov	edx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T33[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _info$210[ebp+32], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _info$210[ebp+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _info$210[ebp+12], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 765  :    info.token_ = token;

	mov	ecx, DWORD PTR _token$GSCopy$1$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	movq	xmm0, QWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR _info$210[ebp+8], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	lea	ecx, DWORD PTR _info$210[ebp+12]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 765  :    info.token_ = token;

	movq	QWORD PTR _info$210[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	cmp	ecx, eax
	je	SHORT $LN268@decodeNumb

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN268@decodeNumb:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 768  :    errors_.push_back( info );

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _info$210[ebp]
	push	eax
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _info$210[ebp+36], 0
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _info$210[ebp+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN407@decodeNumb

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR _info$210[ebp+12]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN407@decodeNumb:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T33[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN508@decodeNumb

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T33[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN508@decodeNumb:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T32[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T33[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T33[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T33[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN609@decodeNumb

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T32[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN609@decodeNumb:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T32[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T32[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T32[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN710@decodeNumb

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T3[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN710@decodeNumb:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 604  :          return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	xor	al, al
	jmp	SHORT $LN1@decodeNumb
$LN819@decodeNumb:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	ecx, DWORD PTR [ecx]
$LN820@decodeNumb:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR [eax+8]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 610  :       currentValue() = -Value::Int( value );

	lea	eax, DWORD PTR $T202[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 610  :       currentValue() = -Value::Int( value );

	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	edx
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 610  :       currentValue() = -Value::Int( value );

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, esi
	shr	eax, 2
	and	edx, eax

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 610  :       currentValue() = -Value::Int( value );

	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [ecx+esi*4]
	jmp	SHORT $LN839@decodeNumb
$LN12@decodeNumb:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 319  :    value_.int_ = value;

	mov	DWORD PTR $T207[ebp], ecx
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 611  :    else if ( value <= Value::UInt(Value::maxInt) )

	cmp	ecx, 2147483647				; 7fffffffH
	ja	SHORT $LN14@decodeNumb
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 313  :    : type_( intValue )

	and	eax, -255				; ffffff01H
	or	eax, 1
	mov	DWORD PTR $T207[ebp+8], eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 612  :       currentValue() = Value::Int( value );

	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 613  :    else

	jmp	SHORT $LN840@decodeNumb
$LN14@decodeNumb:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 324  :    : type_( uintValue )

	and	eax, -254				; ffffff02H
	or	eax, 2
	mov	DWORD PTR $T208[ebp+8], eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 614  :       currentValue() = value;

	mov	DWORD PTR __$EHRec$[ebp+8], 6
$LN840@decodeNumb:
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T208[ebp]
	push	eax
	call	?currentValue@Reader@Json@@AAEAAVValue@2@XZ ; Json::Reader::currentValue
	mov	ecx, eax
$LN839@decodeNumb:
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T208[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 615  :    return true;

	mov	al, 1
$LN1@decodeNumb:

; 616  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T202[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T32[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T33[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$35:
	lea	ecx, DWORD PTR _info$210[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T207[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__unwindfunclet$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z$5:
	lea	ecx, DWORD PTR $T208[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeNumber@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeNumber
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T176 = -128						; size = 12
$T175 = -116						; size = 12
_value$ = -104						; size = 8
$T94 = -96						; size = 24
$T64 = -72						; size = 24
_buffer$180 = -72					; size = 24
$T174 = -64						; size = 16
_buffer$181 = -48					; size = 32
$T93 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeDouble, COMDAT
; _this$ = ecx

; 621  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 116				; 00000074H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	edi, DWORD PTR _token$[ebp]
	xorps	xmm0, xmm0

; 622  :    double value = 0;

	movsd	QWORD PTR _value$[ebp], xmm0

; 623  :    const int bufferSize = 32;
; 624  :    int count;
; 625  :    int length = int(token.end_ - token.start_);

	mov	ecx, DWORD PTR [edi+8]
	mov	esi, ecx
	mov	eax, DWORD PTR [edi+4]
	sub	esi, eax

; 626  :    if ( length <= bufferSize )

	cmp	esi, 32					; 00000020H
	jg	SHORT $LN2@decodeDoub

; 627  :    {
; 628  :       Char buffer[bufferSize];
; 629  :       memcpy( buffer, token.start_, length );

	push	esi
	push	eax
	lea	eax, DWORD PTR _buffer$181[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 630  :       buffer[length] = 0;

	cmp	esi, 32					; 00000020H
	jae	SHORT $LN6@decodeDoub

; 631  :       count = sscanf( buffer, "%lf", &value );

	lea	eax, DWORD PTR _value$[ebp]
	mov	BYTE PTR _buffer$181[ebp+esi], 0
	push	eax
	lea	eax, DWORD PTR _buffer$181[ebp]
	push	OFFSET ??_C@_03DLDNIBIK@?$CFlf?$AA@
	push	eax
	call	_sscanf
	add	esp, 12					; 0000000cH
	mov	esi, eax

; 632  :    }
; 633  :    else

	jmp	SHORT $LN158@decodeDoub
$LN6@decodeDoub:

; 630  :       buffer[length] = 0;

	call	___report_rangecheckfailure
$LN698@decodeDoub:
$LN2@decodeDoub:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _buffer$180[ebp+20], 15	; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _buffer$180[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _buffer$180[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	cmp	eax, ecx
	je	SHORT $LN148@decodeDoub

; 906  : 			assign(_First, _Last - _First);

	sub	ecx, eax
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _buffer$180[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR _buffer$180[ebp+20], 16	; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR _buffer$180[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jae	SHORT $LN149@decodeDoub
$LN148@decodeDoub:
	lea	eax, DWORD PTR _buffer$180[ebp]
$LN149@decodeDoub:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 636  :       count = sscanf( buffer.c_str(), "%lf", &value );

	lea	ecx, DWORD PTR _value$[ebp]
	push	ecx
	push	OFFSET ??_C@_03DLDNIBIK@?$CFlf?$AA@
	push	eax
	call	_sscanf
	mov	esi, eax
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _buffer$180[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN158@decodeDoub

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR _buffer$180[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN158@decodeDoub:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 639  :    if ( count != 1 )

	cmp	esi, 1
	je	$LN4@decodeDoub

; 640  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	eax, DWORD PTR [edi+8]
	mov	ecx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T64[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T64[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T64[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	cmp	ecx, eax
	je	SHORT $LN373@decodeDoub

; 906  : 			assign(_First, _Last - _First);

	sub	eax, ecx
	push	eax
	push	ecx
	lea	ecx, DWORD PTR $T64[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN373@decodeDoub:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 640  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	lea	eax, DWORD PTR $T64[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	mov	edx, OFFSET ??_C@_01GEODFPGF@?8?$AA@
	lea	ecx, DWORD PTR $T93[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_0BD@HHNBFDKF@?8?5is?5not?5a?5number?4?$AA@
	mov	edx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T94[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
	push	0
	push	edi
	push	eax
	mov	ecx, ebx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T94[ebp+20]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 640  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN381@decodeDoub

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR $T94[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN381@decodeDoub:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T93[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T94[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T94[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T94[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN482@decodeDoub

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T93[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN482@decodeDoub:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T64[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T93[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T93[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T93[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN583@decodeDoub

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T64[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN583@decodeDoub:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 640  :       return addError( "'" + std::string( token.start_, token.end_ ) + "' is not a number.", token );

	mov	al, bl
	jmp	SHORT $LN1@decodeDoub
$LN4@decodeDoub:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 334  :    : type_( realValue )

	mov	eax, DWORD PTR $T174[ebp+8]

; 335  :    , comments_( 0 )
; 336  : # ifdef JSON_VALUE_USE_INTERNAL_MAP
; 337  :    , itemIsUsed_( 0 )
; 338  : #endif
; 339  : {
; 340  :    value_.real_ = value;

	movsd	xmm0, QWORD PTR _value$[ebp]
	and	eax, -253				; ffffff03H
	or	eax, 3
	mov	DWORD PTR $T174[ebp+12], 0
	mov	DWORD PTR $T174[ebp+8], eax
	movsd	QWORD PTR $T174[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	ecx
	lea	eax, DWORD PTR $T175[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 641  :    currentValue() = value;

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	eax
	lea	eax, DWORD PTR $T176[ebp]
	mov	ecx, ebx
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN693@decodeDoub
$LN692@decodeDoub:
	mov	ecx, DWORD PTR [ecx]
$LN693@decodeDoub:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR [eax+8]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 641  :    currentValue() = value;

	lea	eax, DWORD PTR $T174[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 641  :    currentValue() = value;

	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	edx
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 641  :    currentValue() = value;

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, esi

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	shr	eax, 2
	and	edx, eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 641  :    currentValue() = value;

	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [ecx+esi*4]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T174[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 642  :    return true;

	mov	al, 1
$LN1@decodeDoub:

; 643  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN697@decodeDoub:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T64[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$2:
	lea	ecx, DWORD PTR $T93[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$3:
	lea	ecx, DWORD PTR $T94[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z$4:
	lea	ecx, DWORD PTR $T174[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-132]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeDouble@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeDouble
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
_TEXT	SEGMENT
$T31 = -80						; size = 12
$T30 = -68						; size = 12
$T29 = -56						; size = 16
_decoded$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z PROC	; Json::Reader::decodeString, COMDAT
; _this$ = ecx

; 648  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	eax, DWORD PTR _token$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _decoded$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _decoded$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _decoded$[ebp], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 650  :    if ( !decodeString( token, decoded ) )

	lea	ecx, DWORD PTR _decoded$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	ecx
	push	eax
	mov	ecx, esi
	call	?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Reader::decodeString
	test	al, al
	jne	SHORT $LN2@decodeStri
	xor	bl, bl
	jmp	SHORT $LN6@decodeStri
$LN2@decodeStri:

; 652  :    currentValue() = decoded;

	lea	eax, DWORD PTR _decoded$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T29[ebp]
	call	??0Value@Json@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::Value
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	ecx
	lea	eax, DWORD PTR $T30[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 652  :    currentValue() = decoded;

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	push	eax
	lea	eax, DWORD PTR $T31[ebp]
	mov	ecx, esi
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN127@decodeStri
$LN126@decodeStri:
	mov	ecx, DWORD PTR [ecx]
$LN127@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR [eax+8]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 652  :    currentValue() = decoded;

	lea	eax, DWORD PTR $T29[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	mov	edx, esi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 652  :    currentValue() = decoded;

	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	eax
	shr	edx, 2

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	and	edx, eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 652  :    currentValue() = decoded;

	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	ecx, DWORD PTR [ecx+esi*4]
	call	??4Value@Json@@QAEAAV01@ABV01@@Z	; Json::Value::operator=
	lea	ecx, DWORD PTR $T29[ebp]
	call	??1Value@Json@@QAE@XZ			; Json::Value::~Value

; 653  :    return true;

	mov	bl, 1
$LN6@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR _decoded$[ebp+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN231@decodeStri

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR _decoded$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN231@decodeStri:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 653  :    return true;

	mov	al, bl

; 654  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$0:
	lea	ecx, DWORD PTR _decoded$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z$1:
	lea	ecx, DWORD PTR $T29[ebp]
	jmp	??1Value@Json@@QAE@XZ			; Json::Value::~Value
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@@Z ENDP	; Json::Reader::decodeString
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_c$124 = -84						; size = 1
_unicode$125 = -80					; size = 4
_token$GSCopy$1$ = -76					; size = 4
_current$ = -72						; size = 4
_this$GSCopy$1$ = -68					; size = 4
$T41 = -64						; size = 24
$T13 = -64						; size = 24
$T69 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_decoded$ = 12						; size = 4
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::Reader::decodeString, COMDAT
; _this$ = ecx

; 659  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	ebx, DWORD PTR _token$[ebp]
	mov	edi, DWORD PTR _decoded$[ebp]
	mov	DWORD PTR _token$GSCopy$1$[ebp], ebx

; 660  :    decoded.reserve( token.end_ - token.start_ - 2 );

	mov	eax, DWORD PTR [ebx+8]
	sub	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	mov	esi, DWORD PTR [edi+16]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 660  :    decoded.reserve( token.end_ - token.start_ - 2 );

	sub	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	cmp	esi, eax
	ja	SHORT $LN72@decodeStri
	cmp	DWORD PTR [edi+20], eax
	je	SHORT $LN72@decodeStri

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	mov	ecx, edi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN502@decodeStri

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], esi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN67@decodeStri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN68@decodeStri
$LN67@decodeStri:
	mov	eax, edi
$LN68@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+esi], 0
$LN502@decodeStri:
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
$LN72@decodeStri:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 661  :    Location current = token.start_ + 1; // skip '"'

	mov	esi, DWORD PTR [ebx+4]

; 662  :    Location end = token.end_ - 1;      // do not include '"'

	mov	ebx, DWORD PTR [ebx+8]
	inc	esi
	dec	ebx

; 663  :    while ( current != end )

	cmp	esi, ebx
	je	$LN499@decodeStri
$LL2@decodeStri:

; 664  :    {
; 665  :       Char c = *current++;

	mov	al, BYTE PTR [esi]
	inc	esi
	mov	BYTE PTR _c$124[ebp], al

; 666  :       if ( c == '"' )

	cmp	al, 34					; 00000022H
	je	$LN499@decodeStri

; 667  :          break;
; 668  :       else if ( c == '\\' )

	cmp	al, 92					; 0000005cH
	jne	$LN8@decodeStri

; 669  :       {
; 670  :          if ( current == end )

	cmp	esi, ebx
	je	$LN495@decodeStri

; 672  :          Char escape = *current++;

	mov	al, BYTE PTR [esi]
	inc	esi

; 673  :          switch ( escape )

	movsx	eax, al
	add	eax, -34				; ffffffdeH
	mov	DWORD PTR _current$[ebp], esi
	cmp	eax, 83					; 00000053H
	ja	$LN21@decodeStri
	movzx	eax, BYTE PTR $LN500@decodeStri[eax]
	jmp	DWORD PTR $LN505@decodeStri[eax*4]
$LN11@decodeStri:

; 674  :          {
; 675  :          case '"': decoded += '"'; break;

	push	34					; 00000022H
	jmp	SHORT $LN504@decodeStri
$LN12@decodeStri:

; 676  :          case '/': decoded += '/'; break;

	push	47					; 0000002fH
	jmp	SHORT $LN504@decodeStri
$LN13@decodeStri:

; 677  :          case '\\': decoded += '\\'; break;

	push	92					; 0000005cH
	jmp	SHORT $LN504@decodeStri
$LN14@decodeStri:

; 678  :          case 'b': decoded += '\b'; break;

	push	8
	jmp	SHORT $LN504@decodeStri
$LN15@decodeStri:

; 679  :          case 'f': decoded += '\f'; break;

	push	12					; 0000000cH
	jmp	SHORT $LN504@decodeStri
$LN16@decodeStri:

; 680  :          case 'n': decoded += '\n'; break;

	push	10					; 0000000aH
	jmp	SHORT $LN504@decodeStri
$LN17@decodeStri:

; 681  :          case 'r': decoded += '\r'; break;

	push	13					; 0000000dH
	jmp	SHORT $LN504@decodeStri
$LN18@decodeStri:

; 682  :          case 't': decoded += '\t'; break;

	push	9
	jmp	SHORT $LN504@decodeStri
$LN19@decodeStri:

; 683  :          case 'u':
; 684  :             {
; 685  :                unsigned int unicode;
; 686  :                if ( !decodeUnicodeCodePoint( token, current, end, unicode ) )

	lea	eax, DWORD PTR _unicode$125[ebp]
	push	eax
	push	ebx
	lea	eax, DWORD PTR _current$[ebp]
	push	eax
	push	DWORD PTR _token$GSCopy$1$[ebp]
	call	?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeCodePoint
	test	al, al
	je	SHORT $LN496@decodeStri

; 688  :                decoded += codePointToUTF8(unicode);

	mov	edx, DWORD PTR _unicode$125[ebp]
	lea	ecx, DWORD PTR $T41[ebp]
	call	?codePointToUTF8@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::codePointToUTF8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, edi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 688  :                decoded += codePointToUTF8(unicode);

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 688  :                decoded += codePointToUTF8(unicode);

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T41[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN501@decodeStri

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T41[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN501@decodeStri:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 695  :       else

	mov	esi, DWORD PTR _current$[ebp]
	jmp	SHORT $LN9@decodeStri
$LN8@decodeStri:

; 696  :       {
; 697  :          decoded += c;

	push	DWORD PTR _c$124[ebp]
$LN504@decodeStri:
	mov	ecx, edi
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN9@decodeStri:

; 663  :    while ( current != end )

	cmp	esi, ebx
	je	$LN499@decodeStri
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	jmp	$LL2@decodeStri
$LN496@decodeStri:

; 687  :                   return false;

	xor	al, al
	jmp	$LN1@decodeStri
$LN21@decodeStri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	29					; 0000001dH
	push	OFFSET ??_C@_0BO@NDEEJNNB@Bad?5escape?5sequence?5in?5string?$AA@
	lea	ecx, DWORD PTR $T69[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T69[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T69[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T69[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 692  :             return addError( "Bad escape sequence in string", token, current );

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T69[ebp]
	push	esi
	push	DWORD PTR _token$GSCopy$1$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T69[ebp+20]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 692  :             return addError( "Bad escape sequence in string", token, current );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN80@decodeStri

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR $T69[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 692  :             return addError( "Bad escape sequence in string", token, current );

	mov	al, bl
	jmp	SHORT $LN1@decodeStri
$LN495@decodeStri:

; 671  :             return addError( "Empty escape sequence in string", token, current );

	push	OFFSET ??_C@_0CA@DPGKPPOE@Empty?5escape?5sequence?5in?5string?$AA@
	lea	ecx, DWORD PTR $T13[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T13[ebp]
	push	esi
	push	DWORD PTR _token$GSCopy$1$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T13[ebp+20]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 671  :             return addError( "Empty escape sequence in string", token, current );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN80@decodeStri

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR $T13[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN80@decodeStri:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 671  :             return addError( "Empty escape sequence in string", token, current );

	mov	al, bl
	jmp	SHORT $LN1@decodeStri
$LN499@decodeStri:

; 698  :       }
; 699  :    }
; 700  :    return true;

	mov	al, 1
$LN1@decodeStri:

; 701  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	1
$LN505@decodeStri:
	DD	$LN11@decodeStri
	DD	$LN12@decodeStri
	DD	$LN13@decodeStri
	DD	$LN14@decodeStri
	DD	$LN15@decodeStri
	DD	$LN16@decodeStri
	DD	$LN17@decodeStri
	DD	$LN18@decodeStri
	DD	$LN19@decodeStri
	DD	$LN21@decodeStri
$LN500@decodeStri:
	DB	0
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	1
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	2
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	3
	DB	9
	DB	9
	DB	9
	DB	4
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	9
	DB	5
	DB	9
	DB	9
	DB	9
	DB	6
	DB	9
	DB	7
	DB	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
	lea	ecx, DWORD PTR $T41[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
	lea	ecx, DWORD PTR $T69[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR $T13[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeString@Reader@Json@@AAE_NAAVToken@12@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::Reader::decodeString
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT
_surrogatePair$6 = -76					; size = 4
_this$GSCopy$1$ = -72					; size = 4
_token$GSCopy$1$ = -68					; size = 4
$T3 = -64						; size = 24
$T1 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_current$ = 12						; size = 4
_end$ = 16						; size = 4
_unicode$ = 20						; size = 4
?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z PROC ; Json::Reader::decodeUnicodeCodePoint, COMDAT
; _this$ = ecx

; 708  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 64					; 00000040H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], eax
	mov	edi, DWORD PTR _unicode$[ebp]

; 709  : 
; 710  :    if ( !decodeUnicodeEscapeSequence( token, current, end, unicode ) )

	mov	ebx, DWORD PTR _end$[ebp]
	mov	ecx, DWORD PTR _token$[ebp]
	mov	esi, DWORD PTR _current$[ebp]
	push	edi
	push	ebx
	push	esi
	mov	DWORD PTR _token$GSCopy$1$[ebp], ecx
	push	ecx
	mov	ecx, eax
	call	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
	test	al, al
	jne	SHORT $LN2@decodeUnic
$LN7@decodeUnic:

; 711  :       return false;

	xor	al, al
	jmp	$LN1@decodeUnic
$LN2@decodeUnic:

; 712  :    if (unicode >= 0xD800 && unicode <= 0xDBFF)

	mov	eax, DWORD PTR [edi]
	cmp	eax, 55296				; 0000d800H
	jb	$LN6@decodeUnic
	cmp	eax, 56319				; 0000dbffH
	ja	$LN6@decodeUnic

; 713  :    {
; 714  :       // surrogate pairs
; 715  :       if (end - current < 6)

	mov	ecx, DWORD PTR [esi]
	mov	eax, ebx
	sub	eax, ecx
	cmp	eax, 6
	jge	SHORT $LN4@decodeUnic

; 716  :          return addError( "additional six characters expected to parse unicode surrogate pair.", token, current );

	push	OFFSET ??_C@_0EE@LMPEHADE@additional?5six?5characters?5expect@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	DWORD PTR [esi]
	push	DWORD PTR _token$GSCopy$1$[ebp]
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	lea	ecx, DWORD PTR $T1[ebp]
	mov	bl, al
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, bl
	jmp	SHORT $LN1@decodeUnic
$LN4@decodeUnic:

; 717  :       unsigned int surrogatePair;
; 718  :       if (*(current++) == '\\' && *(current++)== 'u')

	mov	al, BYTE PTR [ecx]
	lea	edx, DWORD PTR [ecx+1]
	mov	DWORD PTR [esi], edx
	cmp	al, 92					; 0000005cH
	jne	SHORT $LN5@decodeUnic
	mov	cl, BYTE PTR [edx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [esi], eax
	cmp	cl, 117					; 00000075H
	jne	SHORT $LN5@decodeUnic

; 719  :       {
; 720  :          if (decodeUnicodeEscapeSequence( token, current, end, surrogatePair ))

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _surrogatePair$6[ebp]
	push	eax
	push	ebx
	push	esi
	push	DWORD PTR _token$GSCopy$1$[ebp]
	call	?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ; Json::Reader::decodeUnicodeEscapeSequence
	test	al, al
	je	$LN7@decodeUnic

; 721  :          {
; 722  :             unicode = 0x10000 + ((unicode & 0x3FF) << 10) + (surrogatePair & 0x3FF);

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR _surrogatePair$6[ebp]
	and	ecx, 1023				; 000003ffH
	add	ecx, 64					; 00000040H
	and	eax, 1023				; 000003ffH
	shl	ecx, 10					; 0000000aH
	add	ecx, eax
	mov	DWORD PTR [edi], ecx
$LN6@decodeUnic:

; 729  :    }
; 730  :    return true;

	mov	al, 1
$LN1@decodeUnic:

; 731  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN5@decodeUnic:

; 723  :          } 
; 724  :          else
; 725  :             return false;
; 726  :       } 
; 727  :       else
; 728  :          return addError( "expecting another \\u token to begin the second half of a unicode surrogate pair", token, current );

	push	OFFSET ??_C@_0FA@BGMMPLKB@expecting?5another?5?2u?5token?5to?5be@
	lea	ecx, DWORD PTR $T3[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	DWORD PTR [esi]
	push	DWORD PTR _token$GSCopy$1$[ebp]
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
	lea	ecx, DWORD PTR $T3[ebp]
	mov	bl, al
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, bl
	jmp	SHORT $LN1@decodeUnic
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-80]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeUnicodeCodePoint@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ENDP ; Json::Reader::decodeUnicodeCodePoint
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
_TEXT	SEGMENT
_token$GSCopy$1$ = -112					; size = 4
_this$GSCopy$1$ = -108					; size = 4
_info$198 = -104					; size = 40
$T55 = -64						; size = 24
$T1 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_token$ = 8						; size = 4
_current$ = 12						; size = 4
_end$ = 16						; size = 4
_unicode$ = 20						; size = 4
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z PROC ; Json::Reader::decodeUnicodeEscapeSequence, COMDAT
; _this$ = ecx

; 738  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 100				; 00000064H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	ebx, DWORD PTR _current$[ebp]

; 739  :    if ( end - current < 4 )

	mov	eax, DWORD PTR _end$[ebp]
	mov	edi, DWORD PTR _token$[ebp]
	mov	esi, DWORD PTR _unicode$[ebp]
	sub	eax, DWORD PTR [ebx]
	mov	DWORD PTR _token$GSCopy$1$[ebp], edi
	cmp	eax, 4
	jge	SHORT $LN5@decodeUnic
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	60					; 0000003cH
	push	OFFSET ??_C@_0DN@BPAHJPFJ@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	ecx, DWORD PTR $T1[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T1[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T1[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 740  :       return addError( "Bad unicode escape sequence in string: four digits expected.", token, current );

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	DWORD PTR [ebx]
	push	edi
	push	eax
	call	?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ; Json::Reader::addError
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T1[ebp+20]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 740  :       return addError( "Bad unicode escape sequence in string: four digits expected.", token, current );

	mov	bl, al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN133@decodeUnic

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR $T1[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN133@decodeUnic:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 740  :       return addError( "Bad unicode escape sequence in string: four digits expected.", token, current );

	mov	al, bl
	jmp	$LN1@decodeUnic
$LN5@decodeUnic:

; 741  :    unicode = 0;

	mov	DWORD PTR [esi], 0

; 742  :    for ( int index =0; index < 4; ++index )

	xor	edi, edi
	npad	2
$LL4@decodeUnic:

; 743  :    {
; 744  :       Char c = *current++;

	mov	eax, DWORD PTR [ebx]
	mov	cl, BYTE PTR [eax]
	inc	eax
	mov	DWORD PTR [ebx], eax

; 745  :       unicode *= 16;
; 746  :       if ( c >= '0'  &&  c <= '9' )

	mov	al, cl
	mov	edx, DWORD PTR [esi]
	sub	al, 48					; 00000030H
	shl	edx, 4
	mov	DWORD PTR [esi], edx
	cmp	al, 9
	ja	SHORT $LN6@decodeUnic

; 747  :          unicode += c - '0';

	movsx	eax, cl
	add	eax, -48				; ffffffd0H
	jmp	SHORT $LN794@decodeUnic
$LN6@decodeUnic:

; 748  :       else if ( c >= 'a'  &&  c <= 'f' )

	mov	al, cl
	sub	al, 97					; 00000061H
	cmp	al, 5
	ja	SHORT $LN8@decodeUnic

; 749  :          unicode += c - 'a' + 10;

	movsx	eax, cl
	add	eax, -87				; ffffffa9H
	jmp	SHORT $LN794@decodeUnic
$LN8@decodeUnic:

; 750  :       else if ( c >= 'A'  &&  c <= 'F' )

	mov	al, cl
	sub	al, 65					; 00000041H
	cmp	al, 5
	ja	SHORT $LN10@decodeUnic

; 751  :          unicode += c - 'A' + 10;

	movsx	eax, cl
	add	eax, -55				; ffffffc9H
$LN794@decodeUnic:
	add	eax, edx
	inc	edi
	mov	DWORD PTR [esi], eax
	cmp	edi, 4
	jl	SHORT $LL4@decodeUnic

; 754  :    }
; 755  :    return true;

	mov	al, 1
	jmp	$LN1@decodeUnic
$LN10@decodeUnic:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	66					; 00000042H
	push	OFFSET ??_C@_0ED@FIDDECIG@Bad?5unicode?5escape?5sequence?5in?5s@
	lea	ecx, DWORD PTR $T55[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T55[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T55[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T55[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 753  :          return addError( "Bad unicode escape sequence in string: hexadecimal digit expected.", token, current );

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	esi, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _info$198[ebp+32], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _info$198[ebp+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _info$198[ebp+12], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 765  :    info.token_ = token;

	mov	eax, DWORD PTR _token$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1144 : 		return (assign(_Right, 0, npos));

	lea	ecx, DWORD PTR _info$198[ebp+12]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 764  :    ErrorInfo info;

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 765  :    info.token_ = token;

	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _info$198[ebp+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1144 : 		return (assign(_Right, 0, npos));

	lea	eax, DWORD PTR $T55[ebp]
	push	eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 765  :    info.token_ = token;

	movq	QWORD PTR _info$198[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1144 : 		return (assign(_Right, 0, npos));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 768  :    errors_.push_back( info );

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _info$198[ebp]
	push	eax
	add	ecx, 20					; 00000014H
	mov	DWORD PTR _info$198[ebp+36], esi
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _info$198[ebp+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN593@decodeUnic

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR _info$198[ebp+12]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN593@decodeUnic:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T55[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN694@decodeUnic

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T55[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN694@decodeUnic:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 753  :          return addError( "Bad unicode escape sequence in string: hexadecimal digit expected.", token, current );

	xor	al, al
$LN1@decodeUnic:

; 756  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$1:
	lea	ecx, DWORD PTR $T55[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z$81:
	lea	ecx, DWORD PTR _info$198[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-116]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?decodeUnicodeEscapeSequence@Reader@Json@@AAE_NAAVToken@12@AAPBDPBDAAI@Z ENDP ; Json::Reader::decodeUnicodeEscapeSequence
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
_TEXT	SEGMENT
_info$ = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_message$ = 8						; size = 4
_token$ = 12						; size = 4
_extra$ = 16						; size = 4
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z PROC ; Json::Reader::addError, COMDAT
; _this$ = ecx

; 763  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	edx, DWORD PTR _message$[ebp]
	mov	eax, DWORD PTR _token$[ebp]
	mov	edi, DWORD PTR _extra$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _info$[ebp+32], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _info$[ebp+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _info$[ebp+12], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 764  :    ErrorInfo info;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 765  :    info.token_ = token;

	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _info$[ebp+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	lea	eax, DWORD PTR _info$[ebp+12]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 765  :    info.token_ = token;

	movq	QWORD PTR _info$[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	cmp	eax, edx
	je	SHORT $LN115@addError

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	edx
	mov	ecx, eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN115@addError:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 768  :    errors_.push_back( info );

	lea	eax, DWORD PTR _info$[ebp]
	mov	DWORD PTR _info$[ebp+36], edi
	push	eax
	lea	ecx, DWORD PTR [esi+20]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _info$[ebp+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN349@addError

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR _info$[ebp+12]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN349@addError:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 769  :    return false;

	xor	al, al

; 770  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z$0:
	lea	ecx, DWORD PTR _info$[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-56]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addError@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@PBD@Z ENDP ; Json::Reader::addError
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??0ErrorInfo@Reader@Json@@QAE@XZ PROC			; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+32], 15			; 0000000fH
	mov	eax, ecx

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+12], 0
	ret	0
??0ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??1ErrorInfo@Reader@Json@@QAE@XZ
_TEXT	SEGMENT
??1ErrorInfo@Reader@Json@@QAE@XZ PROC			; Json::Reader::ErrorInfo::~ErrorInfo, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN9@ErrorInfo

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi+12]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN9@ErrorInfo:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+32], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+32], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+28], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN97@ErrorInfo
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+12]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
	ret	0
$LN97@ErrorInfo:
	mov	BYTE PTR [esi+12], 0
	pop	esi
	ret	0
??1ErrorInfo@Reader@Json@@QAE@XZ ENDP			; Json::Reader::ErrorInfo::~ErrorInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z
_TEXT	SEGMENT
_skip$ = -12						; size = 12
_skipUntilToken$ = 8					; size = 4
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z PROC ; Json::Reader::recoverFromError, COMDAT
; _this$ = ecx

; 775  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 776  :    int errorCount = int(errors_.size());

	mov	ebx, DWORD PTR _skipUntilToken$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+36]
$LL2@recoverFro:

; 777  :    Token skip;
; 778  :    while ( true )
; 779  :    {
; 780  :       if ( !readToken(skip) )

	lea	eax, DWORD PTR _skip$[ebp]
	mov	ecx, esi
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN4@recoverFro

; 781  :          errors_.resize( errorCount ); // discard errors caused by recovery

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN4@recoverFro:

; 782  :       if ( skip.type_ == skipUntilToken  ||  skip.type_ == tokenEndOfStream )

	mov	eax, DWORD PTR _skip$[ebp]
	cmp	eax, ebx
	je	SHORT $LN21@recoverFro
	test	eax, eax
	jne	SHORT $LL2@recoverFro
$LN21@recoverFro:

; 783  :          break;
; 784  :    }
; 785  :    errors_.resize( errorCount );

	push	edi
	lea	ecx, DWORD PTR [esi+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
	pop	edi
	pop	esi

; 786  :    return false;

	xor	al, al
	pop	ebx

; 787  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?recoverFromError@Reader@Json@@AAE_NW4TokenType@12@@Z ENDP ; Json::Reader::recoverFromError
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z
_TEXT	SEGMENT
_skip$94 = -68						; size = 12
_info$95 = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_message$ = 8						; size = 4
_token$ = 12						; size = 4
_skipUntilToken$ = 16					; size = 4
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z PROC ; Json::Reader::addErrorAndRecover, COMDAT
; _this$ = ecx

; 794  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	ecx, DWORD PTR _message$[ebp]
	mov	eax, DWORD PTR _token$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _info$95[ebp+32], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _info$95[ebp+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _info$95[ebp+12], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 764  :    ErrorInfo info;

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 765  :    info.token_ = token;

	movq	xmm0, QWORD PTR [eax]
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR _info$95[ebp+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	lea	eax, DWORD PTR _info$95[ebp+12]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 765  :    info.token_ = token;

	movq	QWORD PTR _info$95[ebp], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	cmp	eax, ecx
	je	SHORT $LN117@addErrorAn

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	ecx
	mov	ecx, eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN117@addErrorAn:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 768  :    errors_.push_back( info );

	lea	eax, DWORD PTR _info$95[ebp]
	mov	DWORD PTR _info$95[ebp+36], 0
	push	eax
	lea	ecx, DWORD PTR [ebx+20]
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back

; 769  :    return false;

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _info$95[ebp+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN256@addErrorAn

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR _info$95[ebp+12]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN256@addErrorAn:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 776  :    int errorCount = int(errors_.size());

	mov	edi, DWORD PTR [ebx+36]
	npad	3
$LL352@addErrorAn:

; 777  :    Token skip;
; 778  :    while ( true )
; 779  :    {
; 780  :       if ( !readToken(skip) )

	lea	eax, DWORD PTR _skip$94[ebp]
	mov	ecx, ebx
	push	eax
	call	?readToken@Reader@Json@@AAE_NAAVToken@12@@Z ; Json::Reader::readToken
	test	al, al
	jne	SHORT $LN354@addErrorAn

; 781  :          errors_.resize( errorCount ); // discard errors caused by recovery

	push	edi
	lea	ecx, DWORD PTR [ebx+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
$LN354@addErrorAn:

; 782  :       if ( skip.type_ == skipUntilToken  ||  skip.type_ == tokenEndOfStream )

	mov	eax, DWORD PTR _skip$94[ebp]
	cmp	eax, DWORD PTR _skipUntilToken$[ebp]
	je	SHORT $LN371@addErrorAn
	test	eax, eax
	jne	SHORT $LL352@addErrorAn
$LN371@addErrorAn:

; 783  :          break;
; 784  :    }
; 785  :    errors_.resize( errorCount );

	push	edi
	lea	ecx, DWORD PTR [ebx+20]
	call	?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize

; 795  :    addError( message, token );
; 796  :    return recoverFromError( skipUntilToken );

	xor	al, al

; 797  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z$0:
	lea	ecx, DWORD PTR _info$95[ebp]
	jmp	??1ErrorInfo@Reader@Json@@QAE@XZ
__ehhandler$?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?addErrorAndRecover@Reader@Json@@AAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAVToken@12@W4TokenType@12@@Z ENDP ; Json::Reader::addErrorAndRecover
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?currentValue@Reader@Json@@AAEAAVValue@2@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 12
$T1 = -12						; size = 12
?currentValue@Reader@Json@@AAEAAVValue@2@XZ PROC	; Json::Reader::currentValue, COMDAT
; _this$ = ecx

; 802  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	lea	eax, DWORD PTR $T1[ebp]
	push	esi
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN14@currentVal
$LN13@currentVal:
	mov	eax, DWORD PTR [eax]
$LN14@currentVal:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR [esi+8]
	mov	edx, esi
	mov	ecx, DWORD PTR [eax+8]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 803  :    return *(nodes_.top());

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	shr	edx, 2
	and	edx, ecx

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 803  :    return *(nodes_.top());

	mov	eax, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 804  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?currentValue@Reader@Json@@AAEAAVValue@2@XZ ENDP	; Json::Reader::currentValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?getNextChar@Reader@Json@@AAEDXZ
_TEXT	SEGMENT
?getNextChar@Reader@Json@@AAEDXZ PROC			; Json::Reader::getNextChar, COMDAT
; _this$ = ecx

; 809  : {

	mov	edx, ecx

; 810  :    if ( current_ == end_ )

	mov	ecx, DWORD PTR [edx+72]
	cmp	ecx, DWORD PTR [edx+68]
	jne	SHORT $LN2@getNextCha

; 811  :       return 0;

	xor	al, al

; 813  : }

	ret	0
$LN2@getNextCha:

; 812  :    return *current_++;

	mov	al, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edx+72], ecx

; 813  : }

	ret	0
?getNextChar@Reader@Json@@AAEDXZ ENDP			; Json::Reader::getNextChar
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_location$ = 8						; size = 4
_line$ = 12						; size = 4
_column$ = 16						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z PROC ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = ecx

; 820  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 821  :    Location current = begin_;
; 822  :    Location lastLineStart = current;
; 823  :    line = 0;

	mov	edx, DWORD PTR _line$[ebp]
	mov	eax, DWORD PTR [ecx+64]
	push	esi

; 824  :    while ( current < location  &&  current != end_ )

	mov	esi, DWORD PTR _location$[ebp]
	mov	DWORD PTR _this$1$[ebp], ecx
	mov	DWORD PTR [edx], 0
	push	edi
	mov	edi, eax
	cmp	eax, esi
	jae	SHORT $LN12@getLocatio
	push	ebx
	npad	1
$LL2@getLocatio:
	mov	ebx, eax
	cmp	eax, DWORD PTR [ecx+68]
	je	SHORT $LN13@getLocatio

; 825  :    {
; 826  :       Char c = *current++;

	mov	cl, BYTE PTR [eax]
	inc	eax

; 827  :       if ( c == '\r' )

	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN4@getLocatio

; 828  :       {
; 829  :          if ( *current == '\n' )
; 830  :             ++current;
; 831  :          lastLineStart = current;
; 832  :          ++line;

	cmp	BYTE PTR [eax], 10			; 0000000aH
	cmovne	eax, ebx
	inc	eax
	jmp	SHORT $LN14@getLocatio
$LN4@getLocatio:

; 833  :       }
; 834  :       else if ( c == '\n' )

	cmp	cl, 10					; 0000000aH
	jne	SHORT $LN7@getLocatio
$LN14@getLocatio:

; 835  :       {
; 836  :          lastLineStart = current;
; 837  :          ++line;

	inc	DWORD PTR [edx]
	mov	edi, eax
$LN7@getLocatio:

; 824  :    while ( current < location  &&  current != end_ )

	mov	ecx, DWORD PTR _this$1$[ebp]
	cmp	eax, esi
	jb	SHORT $LL2@getLocatio
$LN13@getLocatio:
	pop	ebx
$LN12@getLocatio:

; 838  :       }
; 839  :    }
; 840  :    // column & line start at 1
; 841  :    column = int(location - lastLineStart) + 1;

	mov	eax, DWORD PTR _column$[ebp]
	sub	esi, edi
	inc	esi
	pop	edi
	mov	DWORD PTR [eax], esi

; 842  :    ++line;

	inc	DWORD PTR [edx]
	pop	esi

; 843  : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?getLocationLineAndColumn@Reader@Json@@ABEXPBDAAH1@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
_TEXT	SEGMENT
$T1 = -68						; size = 4
___$ReturnUdt$GSCopy$1$ = -64				; size = 4
tv453 = -60						; size = 4
_buffer$ = -56						; size = 51
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_location$ = 12						; size = 4
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC ; Json::Reader::getLocationLineAndColumn, COMDAT
; _this$ = ecx

; 848  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 821  :    Location current = begin_;

	mov	eax, DWORD PTR [ecx+64]

; 822  :    Location lastLineStart = current;

	mov	edx, eax
	push	ebx
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _location$[ebp]

; 823  :    line = 0;

	xor	esi, esi
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], ebx
	mov	DWORD PTR $T1[ebp], 0

; 824  :    while ( current < location  &&  current != end_ )

	cmp	eax, edi
	jae	SHORT $LN7@getLocatio
	mov	ecx, DWORD PTR [ecx+68]
	mov	DWORD PTR tv453[ebp], ecx
$LL6@getLocatio:
	mov	ebx, eax
	cmp	eax, ecx
	je	SHORT $LN129@getLocatio

; 825  :    {
; 826  :       Char c = *current++;

	mov	cl, BYTE PTR [eax]
	inc	eax

; 827  :       if ( c == '\r' )

	cmp	cl, 13					; 0000000dH
	jne	SHORT $LN8@getLocatio
	cmp	BYTE PTR [eax], 10			; 0000000aH
	mov	edx, eax
	cmovne	edx, ebx
	inc	edx

; 828  :       {
; 829  :          if ( *current == '\n' )
; 830  :             ++current;
; 831  :          lastLineStart = current;
; 832  :          ++line;

	mov	eax, edx
	jmp	SHORT $LN130@getLocatio
$LN8@getLocatio:

; 833  :       }
; 834  :       else if ( c == '\n' )

	cmp	cl, 10					; 0000000aH
	jne	SHORT $LN11@getLocatio

; 835  :       {
; 836  :          lastLineStart = current;

	mov	edx, eax
$LN130@getLocatio:

; 837  :          ++line;

	inc	esi
$LN11@getLocatio:

; 824  :    while ( current < location  &&  current != end_ )

	mov	ecx, DWORD PTR tv453[ebp]
	cmp	eax, edi
	jb	SHORT $LL6@getLocatio
$LN129@getLocatio:
	mov	ebx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
$LN7@getLocatio:

; 852  :    sprintf( buffer, "Line %d, Column %d", line, column );

	sub	edi, edx

; 842  :    ++line;

	lea	eax, DWORD PTR [esi+1]
	inc	edi

; 852  :    sprintf( buffer, "Line %d, Column %d", line, column );

	push	edi
	push	eax
	lea	eax, DWORD PTR _buffer$[ebp]
	push	OFFSET ??_C@_0BD@LAMGIMLG@Line?5?$CFd?0?5Column?5?$CFd?$AA@
	push	eax
	call	_sprintf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ebx+20], 15			; 0000000fH
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 852  :    sprintf( buffer, "Line %d, Column %d", line, column );

	add	esp, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ebx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ebx], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR _buffer$[ebp], 0
	jne	SHORT $LN123@getLocatio
	xor	ecx, ecx
	jmp	SHORT $LN124@getLocatio
$LN123@getLocatio:
	lea	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	5
$LL128@getLocatio:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL128@getLocatio
	sub	ecx, edx
$LN124@getLocatio:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	lea	eax, DWORD PTR _buffer$[ebp]
	mov	ecx, ebx
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 854  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, ebx
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; Json::Reader::getLocationLineAndColumn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp
;	COMDAT ?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T28 = -124						; size = 12
_itError$250 = -112					; size = 12
___$ReturnUdt$GSCopy$ = -100				; size = 4
$T1 = -96						; size = 4
_this$GSCopy$1$ = -92					; size = 4
$T167 = -88						; size = 24
$T112 = -88						; size = 24
$T30 = -88						; size = 24
$T168 = -64						; size = 24
$T32 = -64						; size = 24
$T169 = -40						; size = 24
$T113 = -40						; size = 24
$T31 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Json::Reader::getFormatedErrorMessages, COMDAT
; _this$ = ecx

; 859  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 112				; 00000070H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$GSCopy$1$[ebp], ecx
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR ___$ReturnUdt$GSCopy$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [esi+16], 0

; 497  : 		_Myres(0)

	mov	DWORD PTR [esi+20], 0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN117@getFormate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN118@getFormate
$LN117@getFormate:
	mov	eax, esi
$LN118@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 871  :    return formattedMessage;

	lea	ebx, DWORD PTR [ecx+20]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	eax, DWORD PTR _itError$250[ebp]
	mov	DWORD PTR $T1[ebp], 1
	push	eax
	mov	ecx, ebx
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	lea	eax, DWORD PTR $T28[ebp]
	mov	ecx, ebx
	push	eax
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 468  : 		return (this->_Myoff == _Right._Myoff);

	mov	edi, DWORD PTR _itError$250[ebp+8]
	cmp	edi, DWORD PTR [eax+8]

; 473  : 		return (!(*this == _Right));

	setne	al
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 862  :          itError != errors_.end();

	test	al, al
	je	$LN964@getFormate
	npad	2
$LL4@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR _itError$250[ebp]
	test	eax, eax
	je	SHORT $LN137@getFormate
$LN136@getFormate:
	mov	eax, DWORD PTR [eax]
$LN137@getFormate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [eax+8]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 865  :       const ErrorInfo &error = *itError;

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, edi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 865  :       const ErrorInfo &error = *itError;

	mov	ebx, DWORD PTR [eax+ecx*4]

; 866  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

	lea	eax, DWORD PTR $T30[ebp]
	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	DWORD PTR [ebx+4]
	push	eax
	call	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
	push	eax
	mov	edx, OFFSET ??_C@_02KAOAMBHJ@?$CK?5?$AA@
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T31[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	edx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T32[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 866  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T32[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN150@getFormate

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T32[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN150@getFormate:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T31[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T32[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T32[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T32[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN251@getFormate

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T31[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN251@getFormate:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 866  :       formattedMessage += "* " + getLocationLineAndColumn( error.token_.start_ ) + "\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T30[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T31[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T31[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T31[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN352@getFormate

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T30[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN352@getFormate:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 867  :       formattedMessage += "  " + error.message_ + "\n";

	lea	eax, DWORD PTR [ebx+12]
	push	eax
	lea	ecx, DWORD PTR $T112[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	edx, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T113[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 867  :       formattedMessage += "  " + error.message_ + "\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T113[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN457@getFormate

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T113[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN457@getFormate:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 867  :       formattedMessage += "  " + error.message_ + "\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T112[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T113[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T113[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T113[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN558@getFormate

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T112[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN558@getFormate:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 868  :       if ( error.extra_ )

	mov	eax, DWORD PTR [ebx+36]
	test	eax, eax
	je	$LN2@getFormate

; 869  :          formattedMessage += "See " + getLocationLineAndColumn( error.extra_ ) + " for detail.\n";

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	push	eax
	lea	eax, DWORD PTR $T167[ebp]
	push	eax
	call	?getLocationLineAndColumn@Reader@Json@@ABE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::Reader::getLocationLineAndColumn
	push	eax
	mov	edx, OFFSET ??_C@_04JBAOJHKB@See?5?$AA@
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T168[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_0O@JBAGGIKP@?5for?5detail?4?6?$AA@
	mov	edx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	lea	ecx, DWORD PTR $T169[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 869  :          formattedMessage += "See " + getLocationLineAndColumn( error.extra_ ) + " for detail.\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T169[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN663@getFormate

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T169[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN663@getFormate:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T168[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T169[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T169[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T169[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN764@getFormate

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T168[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN764@getFormate:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 869  :          formattedMessage += "See " + getLocationLineAndColumn( error.extra_ ) + " for detail.\n";

	mov	BYTE PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T167[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T168[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T168[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T168[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN2@getFormate

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T167[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN2@getFormate:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 862  :          itError != errors_.end();

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	lea	eax, DWORD PTR $T28[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 368  : 		++_Myoff;

	inc	edi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 862  :          itError != errors_.end();

	lea	ecx, DWORD PTR [ecx+20]
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 468  : 		return (this->_Myoff == _Right._Myoff);

	cmp	edi, DWORD PTR [eax+8]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_reader.cpp

; 862  :          itError != errors_.end();

	jne	$LL4@getFormate
$LN964@getFormate:

; 871  :    return formattedMessage;

	mov	eax, esi

; 872  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN8@getFormate
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$GSCopy$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@getFormate:
	ret	0
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$1:
	lea	ecx, DWORD PTR $T30[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$2:
	lea	ecx, DWORD PTR $T31[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$3:
	lea	ecx, DWORD PTR $T32[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$4:
	lea	ecx, DWORD PTR $T112[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$5:
	lea	ecx, DWORD PTR $T113[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$6:
	lea	ecx, DWORD PTR $T167[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$7:
	lea	ecx, DWORD PTR $T168[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ$8:
	lea	ecx, DWORD PTR $T169[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?getFormatedErrorMessages@Reader@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Json::Reader::getFormatedErrorMessages
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=, COMDAT
; _this$ = ecx

; 472  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, DWORD PTR [eax+8]
	setne	al

; 473  : 		return (!(*this == _Right));
; 474  : 		}

	pop	ebp
	ret	4
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++, COMDAT
; _this$ = ecx

; 353  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 354  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 355  : 		if (_Mycont == 0
; 356  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 357  : 		{	// report error
; 358  : 		_DEBUG_ERROR("deque iterator not incrementable");
; 359  : 		_SCL_SECURE_OUT_OF_RANGE;
; 360  : 		}
; 361  : 
; 362  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 363  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 364  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 365  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 366  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 367  : 
; 368  : 		++_Myoff;

	inc	DWORD PTR [ecx+8]

; 369  : 		return (*this);

	mov	eax, ecx

; 370  : 		}

	ret	0
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*, COMDAT
; _this$ = ecx

; 322  : 		{	// return designated object

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	jne	SHORT $LN5@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [eax+8]

; 323  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 324  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 325  : 		if (_Mycont == 0
; 326  : 			|| this->_Myoff < _Mycont->_Myoff
; 327  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 328  : 		{	// report error
; 329  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 330  : 		_SCL_SECURE_OUT_OF_RANGE;
; 331  : 		}
; 332  : 
; 333  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 334  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 335  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 336  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 337  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 338  : 
; 339  : 		_Analysis_assume_(_Mycont != 0);
; 340  : 
; 341  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, DWORD PTR [edx+8]

; 323  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 324  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 325  : 		if (_Mycont == 0
; 326  : 			|| this->_Myoff < _Mycont->_Myoff
; 327  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 328  : 		{	// report error
; 329  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 330  : 		_SCL_SECURE_OUT_OF_RANGE;
; 331  : 		}
; 332  : 
; 333  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 334  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 335  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 336  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 337  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 338  : 
; 339  : 		_Analysis_assume_(_Mycont != 0);
; 340  : 
; 341  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+ecx*4]

; 344  : 		}

	ret	0
$LN5@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [eax+8]

; 323  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 324  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 325  : 		if (_Mycont == 0
; 326  : 			|| this->_Myoff < _Mycont->_Myoff
; 327  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 328  : 		{	// report error
; 329  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 330  : 		_SCL_SECURE_OUT_OF_RANGE;
; 331  : 		}
; 332  : 
; 333  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 334  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 335  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 336  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 337  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 338  : 
; 339  : 		_Analysis_assume_(_Mycont != 0);
; 340  : 
; 341  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, DWORD PTR [edx+8]

; 323  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 324  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 325  : 		if (_Mycont == 0
; 326  : 			|| this->_Myoff < _Mycont->_Myoff
; 327  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 328  : 		{	// report error
; 329  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 330  : 		_SCL_SECURE_OUT_OF_RANGE;
; 331  : 		}
; 332  : 
; 333  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 334  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 335  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 336  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 337  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 338  : 
; 339  : 		_Analysis_assume_(_Mycont != 0);
; 340  : 
; 341  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;
; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+ecx*4]

; 344  : 		}

	ret	0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [ecx+16], -1
	jne	SHORT $LN4@pop

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [ecx+12], 0
$LN4@pop:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 146  : 		}

	ret	0
?pop@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::pop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 12
$T1 = -12						; size = 12
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top, COMDAT
; _this$ = ecx

; 129  : 		{	// return last element of mutable stack

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1448 : 		return (*(end() - 1));

	lea	eax, DWORD PTR $T1[ebp]
	push	esi
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN12@top
$LN11@top:
	mov	esi, DWORD PTR [esi]
$LN12@top:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	ecx, edx
	mov	eax, DWORD PTR [esi+8]
	dec	eax
	shr	ecx, 2
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
	and	edx, 3
	pop	esi
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 131  : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?top@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::top
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1393 : 		return (this->_Mysize() == 0);

	cmp	DWORD PTR [ecx+16], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 121  : 		}

	ret	0
?empty@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBE_NXZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push, COMDAT
; _this$ = ecx

; 107  : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp

; 109  : 		}

	pop	ebp

; 108  : 		c.push_back(_STD move(_Val));

	jmp	?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
?push@?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::push
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=, COMDAT
; _this$ = ecx

; 101  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1106 : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[ebp]
	cmp	esi, edi
	je	SHORT $LN322@operator

; 1107 : 			{	// different, assign it
; 1108 : 			_Tidy();

	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [esi], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [edi], edx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN210@operator

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], esi
$LN210@operator:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN211@operator

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], edi
$LN211@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1120 : 		this->_Map() = _Right._Map();

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 1121 : 		this->_Mapsize() = _Right._Mapsize();

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax

; 1122 : 		this->_Myoff() = _Right._Myoff();

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax

; 1123 : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], eax

; 1124 : 
; 1125 : 		_Right._Map() = _Mapptr();

	mov	DWORD PTR [edi+4], 0

; 1126 : 		_Right._Mapsize() = 0;

	mov	DWORD PTR [edi+8], 0

; 1127 : 		_Right._Myoff() = 0;

	mov	DWORD PTR [edi+12], 0

; 1128 : 		_Right._Mysize() = 0;

	mov	DWORD PTR [edi+16], 0
$LN322@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 103  : 		return (*this);

	mov	eax, esi

; 104  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z$1:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 75   : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 74   : 		: c(_STD move(_Right.c))

	push	DWORD PTR __Right$[ebp]

; 75   : 		{	// construct by moving _Right

	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	call	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >

; 76   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=, COMDAT
; _this$ = ecx

; 42   : 		{	// assign by copying _Right

	push	ebp
	mov	ebp, esp
	push	esi

; 43   : 		c = _Right.c;

	push	DWORD PTR __Right$[ebp]
	mov	esi, ecx
	call	??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=

; 44   : 		return (*this);

	mov	eax, esi
	pop	esi

; 45   : 		}

	pop	ebp
	ret	4
??4?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 33   : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 32   : 		: c(_Right.c)

	push	DWORD PTR __Right$[ebp]

; 33   : 		{	// construct by copying _Right

	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	call	??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >

; 34   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack
;	COMDAT ??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 28   : 		{	// construct with empty container

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 28   : 		{	// construct with empty container

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN73@stack
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN73@stack:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\stack

; 29   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$stack@PAVValue@Json@@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >::stack<Json::Value *,std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 1243 : 		{	// destroy the deque

	push	esi
	mov	esi, ecx

; 1244 : 		_Tidy();

	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 1245 : 		}

	ret	0
??1?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::~deque<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear, COMDAT
; _this$ = ecx

; 1675 : 		_Tidy();

	jmp	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
?clear@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back, COMDAT
; _this$ = ecx

; 1494 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [edi+16]
	inc	eax
	cmp	DWORD PTR [edi+8], eax
	ja	SHORT $LN2@push_back
	push	ecx
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@push_back:
	mov	eax, DWORD PTR [edi+8]
	dec	eax
	and	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+16]
	add	eax, DWORD PTR [edi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [edi+8]
	dec	ecx
	and	ecx, eax

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ecx*4]
	cmp	DWORD PTR [ebx+eax], 0
	jne	SHORT $LN3@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	DWORD PTR [ebx+ecx], eax
$LN3@push_back:

; 1497 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [ebx+eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ebx, ebx
	je	SHORT $LN301@push_back
	mov	esi, DWORD PTR __Val$[ebp]
	lea	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [ebx], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+8], eax
	lea	eax, DWORD PTR [esi+12]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [ebx+36], eax
$LN301@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1499 : 		_PUSH_BACK_END;

	inc	DWORD PTR [edi+16]

; 1500 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z$41:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size, COMDAT
; _this$ = ecx

; 1383 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 1384 : 		}

	ret	0
?size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize, COMDAT
; _this$ = ecx

; 1365 : 		{	// determine new length, padding as needed

	push	ebp
	mov	ebp, esp
	push	ebx

; 1366 : 		while (this->_Mysize() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	cmp	DWORD PTR [esi+16], ebx
	jae	SHORT $LN479@resize
$LL2@resize:

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	cmp	DWORD PTR [esi+8], eax
	ja	SHORT $LN17@resize
	push	ecx
	mov	ecx, esi
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN17@resize:
	mov	eax, DWORD PTR [esi+8]
	dec	eax
	and	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [esi+16]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [esi+8]

; 1187 : 		_PUSH_BACK_BEGIN;

	add	ecx, DWORD PTR [esi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	eax
	and	ecx, eax

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	lea	edi, DWORD PTR [ecx*4]
	cmp	DWORD PTR [edi+eax], 0
	jne	SHORT $LN18@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	DWORD PTR [edi+ecx], eax
$LN18@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+eax]
	test	eax, eax
	je	SHORT $LN165@resize
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+32], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+12], 0
$LN165@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1191 : 		_PUSH_BACK_END;

	inc	DWORD PTR [esi+16]

; 1366 : 		while (this->_Mysize() < _Newsize)

	cmp	DWORD PTR [esi+16], ebx
	jb	SHORT $LL2@resize
$LN479@resize:

; 1367 : 			emplace_back();
; 1368 : 
; 1369 : 		while (_Newsize < this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	ebx, ecx
	jae	SHORT $LN5@resize
	npad	2
$LL4@resize:

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+12]
	dec	eax
	add	ecx, eax

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [esi+8]
	dec	eax
	and	ecx, eax

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+32]
	add	edi, 12					; 0000000cH
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN365@resize

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [edi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN365@resize:

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN453@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN453@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN299@resize

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN299@resize:

; 1367 : 			emplace_back();
; 1368 : 
; 1369 : 		while (_Newsize < this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	ebx, ecx
	jb	SHORT $LL4@resize
$LN5@resize:
	pop	edi
	pop	esi
	pop	ebx

; 1370 : 			pop_back();
; 1371 : 		}

	pop	ebp
	ret	4
?resize@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end, COMDAT
; _this$ = ecx

; 1295 : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1296 : 		return (const_iterator(this->_Myoff() + this->_Mysize(),

	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1298 : 		}

	pop	ebp
	ret	4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin, COMDAT
; _this$ = ecx

; 1284 : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1286 : 		}

	pop	ebp
	ret	4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T71 = -36						; size = 12
$T68 = -36						; size = 12
$T64 = -36						; size = 12
$T60 = -36						; size = 12
$T73 = -24						; size = 12
$T57 = -24						; size = 12
__Mid$74 = -12						; size = 12
__Mid$75 = -12						; size = 12
__Right$ = 8						; size = 4
??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=, COMDAT
; _this$ = ecx

; 1248 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi

; 1249 : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[ebp]
	mov	esi, ecx
	cmp	esi, edi
	je	$LN308@operator

; 1250 : 			{	// different, assign it
; 1251 : 			if (this->_Getal() != _Right._Getal()
; 1252 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1253 : 				{	// change allocator before copying
; 1254 : 				_Tidy();
; 1255 : 				this->_Copy_alloc(_Right._Getal());
; 1256 : 				}
; 1257 : 
; 1258 : 			this->_Orphan_all();
; 1259 : 
; 1260 : 			if (_Right._Mysize() == 0)

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	jne	SHORT $LN4@operator

; 1675 : 		_Tidy();

	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 1273 : 				}
; 1274 : 			}
; 1275 : 		return (*this);

	mov	eax, esi

; 1276 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@operator:

; 1261 : 				clear();
; 1262 : 			else if (_Right._Mysize() <= this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	eax, ecx
	ja	$LN6@operator

; 1263 : 				{	// enough elements, copy new and destroy old
; 1264 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),

	sub	esp, 12					; 0000000cH
	mov	ecx, esi
	push	esp
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	sub	esp, 12					; 0000000cH
	mov	ecx, edi
	push	esp
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	sub	esp, 12					; 0000000cH
	mov	ecx, edi
	push	esp
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	lea	ecx, DWORD PTR __Mid$75[ebp]
	call	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H

; 1266 : 				erase(_Mid, end());

	lea	eax, DWORD PTR $T57[ebp]
	mov	ecx, esi
	push	eax
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	sub	esp, 12					; 0000000cH
	mov	edx, eax
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN236@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN236@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN236@operator:
	mov	eax, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1266 : 				erase(_Mid, end());

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Mid$75[ebp]
	test	eax, eax
	je	SHORT $LN250@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN250@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN250@operator:
	mov	eax, DWORD PTR __Mid$75[ebp+8]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1266 : 				erase(_Mid, end());

	lea	eax, DWORD PTR $T60[ebp]
	push	eax
	mov	ecx, esi
	call	?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase

; 1273 : 				}
; 1274 : 			}
; 1275 : 		return (*this);

	mov	eax, esi

; 1276 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@operator:

; 1267 : 				}
; 1268 : 			else
; 1269 : 				{	// new sequence longer, copy and construct new
; 1270 : 				const_iterator _Mid = _Right.begin() + this->_Mysize();

	push	ecx
	lea	eax, DWORD PTR __Mid$74[ebp]
	mov	ecx, edi
	push	eax
	lea	eax, DWORD PTR $T64[ebp]
	push	eax
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+

; 1271 : 				_STD copy(_Right.begin(), _Mid, begin());

	sub	esp, 12					; 0000000cH
	mov	ecx, esi
	push	esp
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	ebx, DWORD PTR __Mid$74[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1271 : 				_STD copy(_Right.begin(), _Mid, begin());

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	ebx, ebx
	je	SHORT $LN273@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [ebx]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN273@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN273@operator:
	mov	eax, DWORD PTR __Mid$74[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1271 : 				_STD copy(_Right.begin(), _Mid, begin());

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edi
	push	esp
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	lea	ecx, DWORD PTR $T68[ebp]
	call	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >

; 1272 : 				insert(end(), _Mid, _Right.end());

	add	esp, 24					; 00000018H
	mov	ecx, edi
	push	esp
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	ebx, ebx
	je	SHORT $LN287@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [ebx]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN287@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN287@operator:
	mov	eax, DWORD PTR __Mid$74[ebp+8]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1272 : 				insert(end(), _Mid, _Right.end());

	lea	eax, DWORD PTR $T71[ebp]
	push	eax
	mov	ecx, esi
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	sub	esp, 12					; 0000000cH
	mov	edx, eax
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN301@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN301@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN301@operator:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1272 : 				insert(end(), _Mid, _Right.end());

	lea	eax, DWORD PTR $T73[ebp]
	push	eax
	mov	ecx, esi
	call	??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
$LN308@operator:

; 1276 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 1243 : 		{	// destroy the deque

	push	esi
	mov	esi, ecx

; 1244 : 		_Tidy();

	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 1245 : 		}

	ret	0
??1?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::~deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=, COMDAT
; _this$ = ecx

; 1105 : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1106 : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[ebp]
	cmp	esi, edi
	je	SHORT $LN315@operator

; 1107 : 			{	// different, assign it
; 1108 : 			_Tidy();

	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [esi], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [edi], edx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN204@operator

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], esi
$LN204@operator:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN205@operator

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], edi
$LN205@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1120 : 		this->_Map() = _Right._Map();

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 1121 : 		this->_Mapsize() = _Right._Mapsize();

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax

; 1122 : 		this->_Myoff() = _Right._Myoff();

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax

; 1123 : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], eax

; 1124 : 
; 1125 : 		_Right._Map() = _Mapptr();

	mov	DWORD PTR [edi+4], 0

; 1126 : 		_Right._Mapsize() = 0;

	mov	DWORD PTR [edi+8], 0

; 1127 : 		_Right._Myoff() = 0;

	mov	DWORD PTR [edi+12], 0

; 1128 : 		_Right._Mysize() = 0;

	mov	DWORD PTR [edi+16], 0
$LN315@operator:

; 1109 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1110 : 				&& this->_Getal() != _Right._Getal())
; 1111 : 				this->_Move_alloc(_Right._Getal());
; 1112 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1113 : 			}
; 1114 : 		return (*this);

	mov	eax, esi

; 1115 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 1093 : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1093 : 		{	// construct by moving _Right

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN85@deque
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN85@deque:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	edx, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	DWORD PTR [eax], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [edx], ecx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN129@deque

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], esi
$LN129@deque:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN130@deque

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], edx
$LN130@deque:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1120 : 		this->_Map() = _Right._Map();

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 1121 : 		this->_Mapsize() = _Right._Mapsize();

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax

; 1122 : 		this->_Myoff() = _Right._Myoff();

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax

; 1123 : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax

; 1094 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1095 : 		}

	mov	eax, esi

; 1125 : 		_Right._Map() = _Mapptr();

	mov	DWORD PTR [edx+4], 0

; 1126 : 		_Right._Mapsize() = 0;

	mov	DWORD PTR [edx+8], 0

; 1127 : 		_Right._Myoff() = 0;

	mov	DWORD PTR [edx+12], 0

; 1128 : 		_Right._Mysize() = 0;

	mov	DWORD PTR [edx+16], 0
	pop	esi

; 1094 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1095 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 1010 : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [edi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [edi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [edi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN91@deque
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN91@deque:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], edi

; 1011 : 		_Construct(_Right.begin(), _Right.end());

	mov	ecx, DWORD PTR __Right$[ebp]
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	esp
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	mov	ecx, DWORD PTR __Right$[ebp]
	sub	esp, 12					; 0000000cH
	push	esp
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, edi
	call	??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >

; 1012 : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::~_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
__ehhandler$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 979  : 		{	// construct empty deque

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 979  : 		{	// construct empty deque

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN70@deque
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN70@deque:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 980  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT
; _this$ = ecx

; 1803 : 		{	// test if sequence is empty

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 1804 : 		return (this->_Mysize() == 0);
; 1805 : 		}

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newcap$ = 8						; size = 4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT
; _this$ = ecx

; 1793 : 		{	// determine new minimum length of allocated storage

	push	ebp
	mov	ebp, esp

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	mov	eax, DWORD PTR __Newcap$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	edi, eax
	ja	SHORT $LN47@reserve
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN47@reserve

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN47@reserve

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN42@reserve
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN42@reserve:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
$LN47@reserve:
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1800 : 		}

	pop	ebp
	ret	4
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1775 : 		{	// determine new length, padding with null elements as needed

	push	ebp
	mov	ebp, esp

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, edx
	ja	SHORT $LN4@resize

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN27@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN27@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1777 : 		}

	pop	ebp
	ret	4
$LN4@resize:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	push	0
	sub	eax, edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1777 : 		}

	pop	ebp
	ret	4
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length, COMDAT
; _this$ = ecx

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 1761 : 		}

	ret	0
?length@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN13@c_str

; 1743 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 1744 : 		}

	ret	0
$LN13@c_str:

; 1743 : 		return (this->_Myptr());

	mov	eax, ecx

; 1744 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1688 : 		return (this->_Myptr()[_Off]);

	mov	eax, DWORD PTR __Off$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN13@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN13@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1688 : 		return (this->_Myptr()[_Off]);

	add	eax, ecx

; 1689 : 		}

	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1105 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@append
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1108 : 		}

	pop	ebp
	ret	4
$LN5@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@append:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@append
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1108 : 		}

	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1064 : 		{	// append _Right

	push	ebp
	mov	ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1066 : 		}

	pop	ebp
	ret	4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1059 : 		{	// append 1 * _Ch

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	not	eax
	cmp	eax, 1
	ja	SHORT $LN4@operator

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN280@operator:
$LN4@operator:

; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+1]

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN29@operator

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN281@operator:
$LN29@operator:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN30@operator

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1116 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN273@operator
$LN278@operator:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	mov	edx, DWORD PTR [esi+16]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN235@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN236@operator
$LN30@operator:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN278@operator

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN205@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	mov	eax, esi
	pop	esi

; 1061 : 		}

	pop	ebp
	ret	4
$LN205@operator:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1061 : 		}

	pop	ebp
	ret	4
$LN235@operator:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, esi
$LN236@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [ecx+edx], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN268@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	mov	eax, esi
	pop	edi
	pop	esi

; 1061 : 		}

	pop	ebp
	ret	4
$LN268@operator:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN273@operator:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	mov	eax, esi
	pop	esi

; 1061 : 		}

	pop	ebp
	ret	4
$LN279@operator:
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1054 : 		{	// append [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN7@operator
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1055 : 		return (append(_Ptr));
; 1056 : 		}

	pop	ebp
	ret	4
$LN7@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL9@operator:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL9@operator
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi

; 1055 : 		return (append(_Ptr));
; 1056 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1049 : 		{	// append _Right

	push	ebp
	mov	ebp, esp

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1050 : 		return (append(_Right));
; 1051 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1040 : 		return (assign(_Ptr));
; 1041 : 		}

	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1023 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp

; 1024 : 		if (this != &_Right)

	mov	eax, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, ecx
	cmp	esi, eax
	je	SHORT $LN132@operator

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN132@operator:

; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);
; 1030 : 				this->_Copy_alloc(_Right._Getal());
; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);
; 1034 : 			}
; 1035 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1036 : 		}

	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN6@basic_stri

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN6@basic_stri:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN94@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	ret	0
$LN94@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 928  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 929  : 		if (this != &_Right)

	cmp	esi, DWORD PTR __Right$[ebp]
	je	SHORT $LN224@operator

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN10@operator

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN10@operator:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN98@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN99@operator
$LN98@operator:
	mov	eax, esi
$LN99@operator:

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	push	DWORD PTR __Right$[ebp]
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN224@operator:

; 941  : 			}
; 942  : 		return (*this);

	mov	eax, esi

; 943  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi

; 911  : 		{	// construct by moving _Right

	mov	edi, ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jae	SHORT $LN126@basic_stri

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

	mov	eax, DWORD PTR [esi+16]
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN127@basic_stri
	push	eax
	push	esi
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	jmp	SHORT $LN127@basic_stri
$LN126@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 968  : 			_Right._Bx()._Ptr = pointer();

	mov	DWORD PTR [esi], 0
$LN127@basic_stri:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN351@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 914  : 		}

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
$LN351@basic_stri:
	mov	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 914  : 		}

	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	ecx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN111@basic_stri
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);
; 839  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
$LN111@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, ecx
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL113@basic_stri:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL113@basic_stri
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);
; 839  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 796  : 		}

	mov	eax, ecx

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 796  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	edx, DWORD PTR ___that$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN13@Deque_cons

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN13@Deque_cons

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@Deque_cons:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	edx, DWORD PTR ___that$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN13@Deque_cons

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN13@Deque_cons

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@Deque_cons:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==, COMDAT
; _this$ = ecx

; 466  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, DWORD PTR [eax+8]
	sete	al

; 467  : 		_Compat(_Right);
; 468  : 		return (this->_Myoff == _Right._Myoff);
; 469  : 		}

	pop	ebp
	ret	4
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+, COMDAT
; _this$ = ecx

; 436  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [ecx]
	push	esi

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	xor	esi, esi

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN15@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN15@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	esi, DWORD PTR [eax]
$LN15@operator:

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 431  : 		_Myoff += _Off;

	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], edx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	esi, esi
	je	SHORT $LN31@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	ecx, DWORD PTR [esi]

; 150  : 		if (_Parent == 0)

	test	ecx, ecx
	je	SHORT $LN31@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
$LN31@operator:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 439  : 		}

	pop	ebp
	ret	8
??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp

; 303  : 		: _Myoff(_Off)

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Pdeque$[ebp]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN11@Deque_cons

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN11@Deque_cons:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 306  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock, COMDAT
; _this$ = ecx

; 767  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp

; 768  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	dec	eax
	and	eax, DWORD PTR __Off$[ebp]

; 770  : 		}

	pop	ebp
	ret	4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction, COMDAT
; _this$dead$ = ecx

; 912  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mysize, COMDAT
; _this$ = ecx

; 941  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 942  : 		}

	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mysize, COMDAT
; _this$ = ecx

; 936  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 937  : 		}

	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myoff, COMDAT
; _this$ = ecx

; 931  : 		return (_Get_data()._Myoff);

	lea	eax, DWORD PTR [ecx+12]

; 932  : 		}

	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myoff, COMDAT
; _this$ = ecx

; 926  : 		return (_Get_data()._Myoff);

	lea	eax, DWORD PTR [ecx+12]

; 927  : 		}

	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mapsize, COMDAT
; _this$ = ecx

; 916  : 		return (_Get_data()._Mapsize);

	lea	eax, DWORD PTR [ecx+8]

; 917  : 		}

	ret	0
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Mapsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Map@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAPAVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
?_Map@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAPAVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Map, COMDAT
; _this$ = ecx

; 906  : 		return (_Get_data()._Map);

	lea	eax, DWORD PTR [ecx+4]

; 907  : 		}

	ret	0
?_Map@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAPAVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Map
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 901  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 902  : 		}

	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 891  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 892  : 		}

	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal, COMDAT
; _this$ = ecx

; 886  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 887  : 		}

	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 876  : 		_Get_data()._Orphan_all();
; 877  : 		}

	ret	0
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Move_alloc@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Move_alloc@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 834  : 		{	// replace old allocator

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN147@Move_alloc
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
$LN147@Move_alloc:
	mov	DWORD PTR [eax], esi
	pop	esi

; 835  : 		_Free_proxy();
; 836  : 		_Pocma(_Getal(), _Al);
; 837  : 		_Alloc_proxy();
; 838  : 		}

	ret	4
?_Move_alloc@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Copy_alloc@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Copy_alloc@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 827  : 		{	// replace old allocator

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN147@Copy_alloc
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
$LN147@Copy_alloc:
	mov	DWORD PTR [eax], esi
	pop	esi

; 828  : 		_Free_proxy();
; 829  : 		_Pocca(_Getal(), _Al);
; 830  : 		_Alloc_proxy();
; 831  : 		}

	ret	4
?_Copy_alloc@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::~_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 822  : 		{	// destroy proxy

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 823  : 		_Free_proxy();
; 824  : 		}

	ret	0
??1?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::~_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 808  : 		{	// default construct allocator

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN67@Deque_allo
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN67@Deque_allo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 809  : 		_Alloc_proxy();
; 810  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEII@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getblock, COMDAT
; _this$ = ecx

; 802  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	dec	eax
	and	eax, DWORD PTR __Off$[ebp]

; 803  : 		return (_Get_data()._Getblock(_Off));
; 804  : 		}

	pop	ebp
	ret	4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??1?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::~_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 822  : 		{	// destroy proxy

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 823  : 		_Free_proxy();
; 824  : 		}

	ret	0
??1?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::~_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy, COMDAT
; _this$ = ecx

; 1841 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1393 : 		return (this->_Mysize() == 0);

	cmp	DWORD PTR [esi+16], 0

; 1842 : 		_Alpty _Almap(this->_Getal());
; 1843 : 		while (!empty())

	je	SHORT $LN3@Tidy
	npad	7
$LL2@Tidy:

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN29@Tidy

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN29@Tidy:

; 1393 : 		return (this->_Mysize() == 0);

	cmp	DWORD PTR [esi+16], 0

; 1842 : 		_Alpty _Almap(this->_Getal());
; 1843 : 		while (!empty())

	jne	SHORT $LL2@Tidy
$LN3@Tidy:
	push	edi

; 1845 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $LN5@Tidy
	npad	5
$LL4@Tidy:

; 1846 : 			{	// free storage for a block and destroy pointer
; 1847 : 			if (this->_Map()[--_Block] != pointer())

	mov	eax, DWORD PTR [esi+4]
	dec	edi
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN7@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1845 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	test	edi, edi
	jne	SHORT $LL4@Tidy
$LN5@Tidy:

; 1848 : 				{	// free block and destroy its pointer
; 1849 : 				this->_Getal().deallocate(this->_Map()[_Block], _DEQUESIZ);
; 1850 : 				this->_Getal().destroy(_STD addressof(this->_Map()[_Block]));
; 1851 : 				}
; 1852 : 			}
; 1853 : 
; 1854 : 		if (this->_Map() != _Mapptr())

	mov	ecx, DWORD PTR [esi+4]
	pop	edi
	test	ecx, ecx
	je	SHORT $LN198@Tidy

; 1855 : 			_Almap.deallocate(this->_Map(),

	mov	eax, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN192@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN232@Tidy:
$LN192@Tidy:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN193@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN194@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN233@Tidy:
$LN194@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN195@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN234@Tidy:
$LN195@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN196@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN235@Tidy:
$LN196@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN197@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN236@Tidy:
$LN197@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN193@Tidy:

; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN198@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1857 : 		this->_Mapsize() = 0;

	mov	DWORD PTR [esi+8], 0

; 1858 : 		this->_Map() = _Mapptr();

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1859 : 		}

	ret	0
$LN231@Tidy:
?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back, COMDAT
; _this$ = ecx

; 1504 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1505 : 		if (empty())
; 1506 : 			_DEBUG_ERROR("deque empty before pop");
; 1507 : 		else
; 1508 : 			{	// something to erase, do it
; 1509 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1510 : 			_Orphan_off(_Newoff);
; 1511 : 			size_type _Block = this->_Getblock(_Newoff);
; 1512 : 			this->_Getal().destroy(
; 1513 : 				_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1514 : 			if (--this->_Mysize() == 0)
; 1515 : 				this->_Myoff() = 0;
; 1516 : 			}
; 1517 : 
; 1518 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1519 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1520 : 		size_type _Block = this->_Getblock(_Newoff);
; 1521 : 		this->_Getal().destroy(
; 1522 : 			_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [ecx+16], -1
	jne	SHORT $LN2@pop_back

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [ecx+12], 0
$LN2@pop_back:

; 1525 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1526 : 		}

	ret	0
?pop_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
$T2 = -24						; size = 12
$T1 = -12						; size = 12
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back, COMDAT
; _this$ = ecx

; 1447 : 		{	// return last element of mutable sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H

; 1448 : 		return (*(end() - 1));

	lea	eax, DWORD PTR $T1[ebp]
	push	esi
	push	ecx
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, eax
	call	??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN10@back
$LN9@back:
	mov	esi, DWORD PTR [esi]
$LN10@back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [eax+8]
	mov	ecx, edx
	mov	eax, DWORD PTR [esi+8]
	dec	eax
	shr	ecx, 2
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
	and	edx, 3
	pop	esi
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+edx*4]

; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAPAVValue@Json@@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty, COMDAT
; _this$ = ecx

; 1392 : 		{	// test if sequence is empty

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 1393 : 		return (this->_Mysize() == 0);
; 1394 : 		}

	ret	0
?empty@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
$T71 = -36						; size = 12
$T68 = -36						; size = 12
$T64 = -36						; size = 12
$T60 = -36						; size = 12
$T73 = -24						; size = 12
$T57 = -24						; size = 12
__Mid$74 = -12						; size = 12
__Mid$75 = -12						; size = 12
__Right$ = 8						; size = 4
??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=, COMDAT
; _this$ = ecx

; 1248 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi

; 1249 : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[ebp]
	mov	esi, ecx
	cmp	esi, edi
	je	$LN308@operator

; 1250 : 			{	// different, assign it
; 1251 : 			if (this->_Getal() != _Right._Getal()
; 1252 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1253 : 				{	// change allocator before copying
; 1254 : 				_Tidy();
; 1255 : 				this->_Copy_alloc(_Right._Getal());
; 1256 : 				}
; 1257 : 
; 1258 : 			this->_Orphan_all();
; 1259 : 
; 1260 : 			if (_Right._Mysize() == 0)

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	jne	SHORT $LN4@operator

; 1675 : 		_Tidy();

	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy

; 1273 : 				}
; 1274 : 			}
; 1275 : 		return (*this);

	mov	eax, esi

; 1276 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@operator:

; 1261 : 				clear();
; 1262 : 			else if (_Right._Mysize() <= this->_Mysize())

	mov	ecx, DWORD PTR [esi+16]
	cmp	eax, ecx
	ja	$LN6@operator

; 1263 : 				{	// enough elements, copy new and destroy old
; 1264 : 				iterator _Mid = _STD copy(_Right.begin(), _Right.end(),

	sub	esp, 12					; 0000000cH
	mov	ecx, esi
	push	esp
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	sub	esp, 12					; 0000000cH
	mov	ecx, edi
	push	esp
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	sub	esp, 12					; 0000000cH
	mov	ecx, edi
	push	esp
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	lea	ecx, DWORD PTR __Mid$75[ebp]
	call	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H

; 1266 : 				erase(_Mid, end());

	lea	eax, DWORD PTR $T57[ebp]
	mov	ecx, esi
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	sub	esp, 12					; 0000000cH
	mov	edx, eax
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN236@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN236@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN236@operator:
	mov	eax, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1266 : 				erase(_Mid, end());

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Mid$75[ebp]
	test	eax, eax
	je	SHORT $LN250@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN250@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN250@operator:
	mov	eax, DWORD PTR __Mid$75[ebp+8]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1266 : 				erase(_Mid, end());

	lea	eax, DWORD PTR $T60[ebp]
	push	eax
	mov	ecx, esi
	call	?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase

; 1273 : 				}
; 1274 : 			}
; 1275 : 		return (*this);

	mov	eax, esi

; 1276 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@operator:

; 1267 : 				}
; 1268 : 			else
; 1269 : 				{	// new sequence longer, copy and construct new
; 1270 : 				const_iterator _Mid = _Right.begin() + this->_Mysize();

	push	ecx
	lea	eax, DWORD PTR __Mid$74[ebp]
	mov	ecx, edi
	push	eax
	lea	eax, DWORD PTR $T64[ebp]
	push	eax
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, eax
	call	??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+

; 1271 : 				_STD copy(_Right.begin(), _Mid, begin());

	sub	esp, 12					; 0000000cH
	mov	ecx, esi
	push	esp
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	ebx, DWORD PTR __Mid$74[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1271 : 				_STD copy(_Right.begin(), _Mid, begin());

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	ebx, ebx
	je	SHORT $LN273@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [ebx]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN273@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN273@operator:
	mov	eax, DWORD PTR __Mid$74[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1271 : 				_STD copy(_Right.begin(), _Mid, begin());

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, edi
	push	esp
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	lea	ecx, DWORD PTR $T68[ebp]
	call	??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >

; 1272 : 				insert(end(), _Mid, _Right.end());

	add	esp, 24					; 00000018H
	mov	ecx, edi
	push	esp
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	ebx, ebx
	je	SHORT $LN287@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [ebx]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN287@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN287@operator:
	mov	eax, DWORD PTR __Mid$74[ebp+8]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1272 : 				insert(end(), _Mid, _Right.end());

	lea	eax, DWORD PTR $T71[ebp]
	push	eax
	mov	ecx, esi
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	sub	esp, 12					; 0000000cH
	mov	edx, eax
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN301@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN301@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN301@operator:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1272 : 				insert(end(), _Mid, _Right.end());

	lea	eax, DWORD PTR $T73[ebp]
	push	eax
	mov	ecx, esi
	call	??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
$LN308@operator:

; 1276 : 		}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@ABV01@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back, COMDAT
; _this$ = ecx

; 1158 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1160 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+16]
	add	eax, ecx
	test	al, 3
	jne	SHORT $LN2@push_back
	lea	eax, DWORD PTR [ecx+4]
	shr	eax, 2
	cmp	DWORD PTR [esi+8], eax
	ja	SHORT $LN2@push_back
	push	ecx
	mov	ecx, esi
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN2@push_back:
	mov	eax, DWORD PTR [esi+8]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [eax*4-1]
	and	DWORD PTR [esi+12], eax
	mov	edi, DWORD PTR [esi+16]
	add	edi, DWORD PTR [esi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, edi
	shr	eax, 2
	dec	ecx
	and	ecx, eax

; 1160 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	lea	ebx, DWORD PTR [ecx*4]
	cmp	DWORD PTR [ebx+eax], 0
	jne	SHORT $LN3@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1160 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1160 : 		_PUSH_BACK_BEGIN;

	mov	DWORD PTR [ebx+ecx], eax
$LN3@push_back:

; 1161 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [esi+4]
	and	edi, 3
	mov	eax, DWORD PTR [ebx+eax]
	lea	ecx, DWORD PTR [eax+edi*4]
	pop	edi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN175@push_back
	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN175@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1164 : 		_PUSH_BACK_END;

	inc	DWORD PTR [esi+16]
	pop	esi

; 1165 : 		}

	pop	ebp
	ret	4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAPAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=, COMDAT
; _this$ = ecx

; 1105 : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1106 : 		if (this != &_Right)

	mov	edi, DWORD PTR __Right$[ebp]
	cmp	esi, edi
	je	SHORT $LN315@operator

; 1107 : 			{	// different, assign it
; 1108 : 			_Tidy();

	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [esi], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [edi], edx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN204@operator

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], esi
$LN204@operator:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN205@operator

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], edi
$LN205@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1120 : 		this->_Map() = _Right._Map();

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [esi+4], eax

; 1121 : 		this->_Mapsize() = _Right._Mapsize();

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax

; 1122 : 		this->_Myoff() = _Right._Myoff();

	mov	eax, DWORD PTR [edi+12]
	mov	DWORD PTR [esi+12], eax

; 1123 : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [esi+16], eax

; 1124 : 
; 1125 : 		_Right._Map() = _Mapptr();

	mov	DWORD PTR [edi+4], 0

; 1126 : 		_Right._Mapsize() = 0;

	mov	DWORD PTR [edi+8], 0

; 1127 : 		_Right._Myoff() = 0;

	mov	DWORD PTR [edi+12], 0

; 1128 : 		_Right._Mysize() = 0;

	mov	DWORD PTR [edi+16], 0
$LN315@operator:

; 1109 : 			if (_Alty::propagate_on_container_move_assignment::value
; 1110 : 				&& this->_Getal() != _Right._Getal())
; 1111 : 				this->_Move_alloc(_Right._Getal());
; 1112 : 			_Assign_rv(_STD forward<_Myt>(_Right));
; 1113 : 			}
; 1114 : 		return (*this);

	mov	eax, esi

; 1115 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Right$ = 8						; size = 4
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 1093 : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1093 : 		{	// construct by moving _Right

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN85@deque
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN85@deque:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	edx, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	DWORD PTR [eax], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [edx], ecx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN129@deque

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], esi
$LN129@deque:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN130@deque

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], edx
$LN130@deque:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1120 : 		this->_Map() = _Right._Map();

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 1121 : 		this->_Mapsize() = _Right._Mapsize();

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [esi+8], eax

; 1122 : 		this->_Myoff() = _Right._Myoff();

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [esi+12], eax

; 1123 : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [esi+16], eax

; 1094 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1095 : 		}

	mov	eax, esi

; 1125 : 		_Right._Map() = _Mapptr();

	mov	DWORD PTR [edx+4], 0

; 1126 : 		_Right._Mapsize() = 0;

	mov	DWORD PTR [edx+8], 0

; 1127 : 		_Right._Myoff() = 0;

	mov	DWORD PTR [edx+12], 0

; 1128 : 		_Right._Mysize() = 0;

	mov	DWORD PTR [edx+16], 0
	pop	esi

; 1094 : 		_Assign_rv(_STD forward<_Myt>(_Right), true_type());
; 1095 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 1010 : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [edi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [edi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [edi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [edi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN91@deque
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN91@deque:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], edi

; 1011 : 		_Construct(_Right.begin(), _Right.end());

	mov	ecx, DWORD PTR __Right$[ebp]
	sub	esp, 12					; 0000000cH
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	esp
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	mov	ecx, DWORD PTR __Right$[ebp]
	sub	esp, 12					; 0000000cH
	push	esp
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, edi
	call	??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >

; 1012 : 		}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::~_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
__ehhandler$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 979  : 		{	// construct empty deque

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 979  : 		{	// construct empty deque

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN70@deque
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN70@deque:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 980  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::deque<Json::Value *,std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy, COMDAT
; _this$ = ecx

; 1841 : 		{	// free all storage

	push	esi
	mov	esi, ecx
	push	edi

; 1393 : 		return (this->_Mysize() == 0);

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx

; 1842 : 		_Alpty _Almap(this->_Getal());
; 1843 : 		while (!empty())

	je	SHORT $LN3@Tidy
	npad	5
$LL2@Tidy:

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+12]
	dec	eax
	add	ecx, eax

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [esi+8]
	dec	eax
	and	ecx, eax

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+32]
	add	edi, 12					; 0000000cH
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN95@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [edi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN95@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN183@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN183@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN29@Tidy

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN29@Tidy:

; 1393 : 		return (this->_Mysize() == 0);

	mov	ecx, DWORD PTR [esi+16]
	test	ecx, ecx

; 1842 : 		_Alpty _Almap(this->_Getal());
; 1843 : 		while (!empty())

	jne	SHORT $LL2@Tidy
$LN3@Tidy:

; 1845 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $LN5@Tidy
	npad	6
$LL4@Tidy:

; 1846 : 			{	// free storage for a block and destroy pointer
; 1847 : 			if (this->_Map()[--_Block] != pointer())

	mov	eax, DWORD PTR [esi+4]
	dec	edi
	mov	eax, DWORD PTR [eax+edi*4]
	test	eax, eax
	je	SHORT $LN7@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN7@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1845 : 		for (size_type _Block = this->_Mapsize(); 0 < _Block; )

	test	edi, edi
	jne	SHORT $LL4@Tidy
$LN5@Tidy:

; 1848 : 				{	// free block and destroy its pointer
; 1849 : 				this->_Getal().deallocate(this->_Map()[_Block], _DEQUESIZ);
; 1850 : 				this->_Getal().destroy(_STD addressof(this->_Map()[_Block]));
; 1851 : 				}
; 1852 : 			}
; 1853 : 
; 1854 : 		if (this->_Map() != _Mapptr())

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN312@Tidy

; 1855 : 			_Almap.deallocate(this->_Map(),

	mov	eax, DWORD PTR [esi+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN306@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN346@Tidy:
$LN306@Tidy:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN307@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN308@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN347@Tidy:
$LN308@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN309@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN348@Tidy:
$LN309@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN310@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN349@Tidy:
$LN310@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN311@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN350@Tidy:
$LN311@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN307@Tidy:

; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN312@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1857 : 		this->_Mapsize() = 0;

	mov	DWORD PTR [esi+8], 0
	pop	edi

; 1858 : 		this->_Map() = _Mapptr();

	mov	DWORD PTR [esi+4], 0
	pop	esi

; 1859 : 		}

	ret	0
$LN345@Tidy:
?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Myptr$1$ = -16					; size = 4
__Newmap$1$ = -12					; size = 4
_this$1$ = -8						; size = 4
__Myboff$1$ = -4					; size = 4
__Count$dead$ = 8					; size = 4
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap, COMDAT
; _this$ = ecx

; 1785 : 		{	// grow map by at least _Count pointers, _Mapsize() a power of 2

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1786 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1787 : 			"The _Xlen() test should always be performed.");
; 1788 : 
; 1789 : 		typedef typename _Alpty::pointer _Blockptr;
; 1790 : 		_Alpty _Almap(this->_Getal());
; 1791 : 		size_type _Newsize = 0 < this->_Mapsize() ? this->_Mapsize() : 1;

	mov	esi, 1
	mov	DWORD PTR _this$1$[ebp], edi
	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	cmovne	esi, ecx
	npad	5
$LL2@Growmap:

; 1792 : 		while (_Newsize - this->_Mapsize() < _Count
; 1793 : 			|| _Newsize < _DEQUEMAPSIZ)

	mov	eax, esi
	sub	eax, ecx
	cmp	eax, 1
	jb	SHORT $LN4@Growmap
	cmp	esi, 8
	jae	SHORT $LN3@Growmap
$LN4@Growmap:

; 1794 : 			{	// scale _Newsize to 2^N >= _Mapsize() + _Count
; 1795 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

	mov	eax, 107374182				; 06666666H
	sub	eax, esi
	cmp	eax, esi
	jb	$LN332@Growmap

; 1796 : 				_Xlen();	// result too long
; 1797 : 			_Newsize *= 2;

	add	esi, esi

; 1798 : 			}

	jmp	SHORT $LL2@Growmap
$LN3@Growmap:

; 1799 : 		_Count = _Newsize - this->_Mapsize();
; 1800 : 
; 1801 : 		size_type _Myboff = this->_Myoff() / _DEQUESIZ;

	mov	ebx, DWORD PTR [edi+12]
	sub	esi, ecx
	mov	DWORD PTR __Myboff$1$[ebp], ebx

; 1802 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize() + _Count);

	lea	eax, DWORD PTR [ecx+esi]
	push	eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::allocate

; 1803 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1804 : 
; 1805 : 		_Myptr = _Uninitialized_copy(this->_Map() + _Myboff,

	mov	ecx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi+8]
	shl	ebx, 2
	shl	edi, 2
	mov	DWORD PTR __Newmap$1$[ebp], eax
	lea	edx, DWORD PTR [ecx+ebx]
	add	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, edx
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	edx
	push	ebx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	edx, DWORD PTR [edi+ebx]
	mov	DWORD PTR __Myptr$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1808 : 		if (_Myboff <= _Count)

	cmp	DWORD PTR __Myboff$1$[ebp], esi
	ja	SHORT $LN6@Growmap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ebx+4]

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, eax
	mov	ebx, DWORD PTR __Myboff$1$[ebp]
	sub	edi, eax
	lea	ecx, DWORD PTR [ebx*4]
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	mov	eax, DWORD PTR __imp__memmove
	push	edx
	call	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	mov	eax, esi
	sub	eax, ebx
	shl	eax, 2
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Myptr$1$[ebp]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	0
	push	eax
	call	_memset
	mov	edi, DWORD PTR __Newmap$1$[ebp]
	mov	ecx, ebx
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	push	0
	push	edi
	call	_memset
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1818 : 		else

	jmp	SHORT $LN337@Growmap
$LN6@Growmap:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	edi, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1820 : 			_Uninitialized_copy(this->_Map(),

	lea	ebx, DWORD PTR [esi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	eax, DWORD PTR __imp__memmove
	push	ebx
	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	push	edx
	call	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1823 : 			_Myptr = _Uninitialized_copy(this->_Map() + _Count,

	mov	edi, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edx, DWORD PTR __Myboff$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1823 : 			_Myptr = _Uninitialized_copy(this->_Map() + _Count,

	lea	eax, DWORD PTR [ebx+edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, eax
	lea	ecx, DWORD PTR [edx*4]
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	DWORD PTR __Newmap$1$[ebp]
	call	DWORD PTR __imp__memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Newmap$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	0
	push	eax
	call	_memset
	mov	edi, DWORD PTR __Newmap$1$[ebp]
$LN337@Growmap:
	mov	ebx, DWORD PTR _this$1$[ebp]
	add	esp, 36					; 00000024H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1832 : 		if (this->_Map() != _Mapptr())

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN8@Growmap

; 1833 : 			_Almap.deallocate(this->_Map(),

	push	DWORD PTR [ebx+8]
	push	eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::deallocate
$LN8@Growmap:

; 1834 : 				this->_Mapsize());	// free storage for old
; 1835 : 
; 1836 : 		this->_Map() = _Newmap;	// point at new

	mov	DWORD PTR [ebx+4], edi

; 1837 : 		this->_Mapsize() += _Count;

	add	DWORD PTR [ebx+8], esi
	pop	edi
	pop	esi
	pop	ebx

; 1838 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN332@Growmap:

; 1776 : 		_Xlength_error("deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN339@Growmap:
$LN338@Growmap:
	int	3
?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T107 = -44						; size = 12
$T61 = -44						; size = 12
$T9 = -44						; size = 12
$T4 = -44						; size = 12
$T3 = -44						; size = 12
__Last$ = -32						; size = 12
__First$ = -20						; size = 12
__Off$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 12
__Last_arg$ = 24					; size = 12
?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase, COMDAT
; _this$ = ecx

; 1633 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi

; 1634 : 		iterator _First = _Make_iter(_First_arg);

	sub	esp, 12					; 0000000cH
	mov	esi, ecx
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First_arg$[ebp]
	test	eax, eax
	je	SHORT $LN23@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN23@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN23@erase:
	mov	eax, DWORD PTR __First_arg$[ebp+8]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1634 : 		iterator _First = _Make_iter(_First_arg);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, esi
	call	?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter

; 1635 : 		iterator _Last = _Make_iter(_Last_arg);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last_arg$[ebp]
	test	eax, eax
	je	SHORT $LN37@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN37@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN37@erase:
	mov	eax, DWORD PTR __Last_arg$[ebp+8]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1635 : 		iterator _Last = _Make_iter(_Last_arg);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, esi
	call	?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter

; 1636 : 
; 1637 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1638 : 		if (_Last < _First
; 1639 : 			|| _First < begin() || end() < _Last)
; 1640 : 			_DEBUG_ERROR("deque erase iterator outside range");
; 1641 : 		_DEBUG_RANGE(_First, _Last);
; 1642 : 
; 1643 : 		size_type _Off = _First - begin();
; 1644 : 		size_type _Count = _Last - _First;
; 1645 : 		bool _Moved = 0 < _Off && _Off + _Count < this->_Mysize();
; 1646 : 
; 1647 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1648 : 		size_type _Off = _First - begin();

	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, esi
	push	eax
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	edx, DWORD PTR __First$[ebp+8]
	mov	ebx, edx
	mov	edi, DWORD PTR __Last$[ebp+8]
	mov	ecx, DWORD PTR [eax+8]
	sub	ebx, ecx
	mov	eax, edx
	sub	eax, ecx
	cmp	ecx, edx

; 1652 : 		if (_Off < (size_type)(end() - _Last))

	mov	ecx, esi
	cmovbe	ebx, eax

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	eax, edi
	mov	DWORD PTR __Off$1$[ebp], ebx
	sub	eax, edx
	mov	ebx, edi
	sub	ebx, edx
	cmp	edx, edi
	cmovbe	ebx, eax

; 1652 : 		if (_Off < (size_type)(end() - _Last))

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end

; 1654 : 			_STD move_backward(begin(), _First, _Last);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	ecx, esp

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	eax, DWORD PTR [eax+8]
	sub	eax, edi
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0
	cmp	DWORD PTR __Off$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1652 : 		if (_Off < (size_type)(end() - _Last))

	jae	$LN8@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]
	test	eax, eax
	je	SHORT $LN77@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN77@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN77@erase:

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1654 : 			_STD move_backward(begin(), _First, _Last);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], edi
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN93@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN93@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN93@erase:
	mov	eax, DWORD PTR __First$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1654 : 			_STD move_backward(begin(), _First, _Last);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esi
	push	esp
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	lea	ecx, DWORD PTR $T9[ebp]
	call	??$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H

; 1655 : 			for (; 0 < _Count; --_Count)

	test	ebx, ebx
	je	$LN6@erase
	npad	6
$LL4@erase:

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [esi+8]

; 1484 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, DWORD PTR [esi+12]

; 1484 : 		this->_Getal().destroy(

	mov	edi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+32]
	add	edi, 12					; 0000000cH
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN163@erase

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [edi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN163@erase:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN252@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN252@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1486 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN96@erase

; 1487 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0

; 1488 : 		else

	jmp	SHORT $LN2@erase
$LN96@erase:

; 1489 : 			++this->_Myoff();

	inc	DWORD PTR [esi+12]
$LN2@erase:

; 1655 : 			for (; 0 < _Count; --_Count)

	sub	ebx, 1
	jne	SHORT $LL4@erase

; 1656 : 				pop_front();	// pop copied elements
; 1657 : 			}
; 1658 : 		else

	jmp	$LN6@erase
$LN8@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN299@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN299@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN299@erase:
	mov	eax, DWORD PTR __First$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1660 : 			_STD move(_Last, end(), _First);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esi
	push	esp
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1660 : 			_STD move(_Last, end(), _First);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN315@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN315@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN315@erase:
	mov	DWORD PTR [ecx+8], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1660 : 			_STD move(_Last, end(), _First);	// copy over hole

	lea	ecx, DWORD PTR $T61[ebp]
	call	??$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H

; 1661 : 			for (; 0 < _Count; --_Count)

	test	ebx, ebx
	je	SHORT $LN6@erase
	npad	3
$LL7@erase:

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+16]
	dec	eax
	add	ecx, eax

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [esi+8]
	dec	eax
	and	ecx, eax

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+4]
	mov	edi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+32]
	add	edi, 12					; 0000000cH
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN384@erase

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [edi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN384@erase:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN473@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN473@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN5@erase

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN5@erase:

; 1661 : 			for (; 0 < _Count; --_Count)

	sub	ebx, 1
	jne	SHORT $LL7@erase
$LN6@erase:

; 1662 : 				pop_back();	// pop copied elements
; 1663 : 			}
; 1664 : 
; 1665 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1666 : 		if (_Moved)
; 1667 : 			this->_Orphan_all();
; 1668 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1669 : 
; 1670 : 		return (begin() + _Off);

	push	DWORD PTR __Off$1$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	lea	eax, DWORD PTR $T107[ebp]
	push	edi
	push	eax
	mov	ecx, esi
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	eax, edi

; 1671 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?erase@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back, COMDAT
; _this$ = ecx

; 1503 : 		{	// erase element at end

	push	esi
	push	edi
	mov	edi, ecx

; 1504 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1505 : 		if (empty())
; 1506 : 			_DEBUG_ERROR("deque empty before pop");
; 1507 : 		else
; 1508 : 			{	// something to erase, do it
; 1509 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1510 : 			_Orphan_off(_Newoff);
; 1511 : 			size_type _Block = this->_Getblock(_Newoff);
; 1512 : 			this->_Getal().destroy(
; 1513 : 				_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1514 : 			if (--this->_Mysize() == 0)
; 1515 : 				this->_Myoff() = 0;
; 1516 : 			}
; 1517 : 
; 1518 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1519 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1520 : 		size_type _Block = this->_Getblock(_Newoff);
; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [edi+16]
	mov	edx, DWORD PTR [edi+12]
	dec	eax
	add	edx, eax

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [edi+8]
	dec	eax
	and	edx, eax

; 1504 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1505 : 		if (empty())
; 1506 : 			_DEBUG_ERROR("deque empty before pop");
; 1507 : 		else
; 1508 : 			{	// something to erase, do it
; 1509 : 			size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1510 : 			_Orphan_off(_Newoff);
; 1511 : 			size_type _Block = this->_Getblock(_Newoff);
; 1512 : 			this->_Getal().destroy(
; 1513 : 				_Unfancy(this->_Map()[_Block] + _Newoff % _DEQUESIZ));
; 1514 : 			if (--this->_Mysize() == 0)
; 1515 : 				this->_Myoff() = 0;
; 1516 : 			}
; 1517 : 
; 1518 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1519 : 		size_type _Newoff = this->_Myoff() + this->_Mysize() - 1;
; 1520 : 		size_type _Block = this->_Getblock(_Newoff);
; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	add	esi, 12					; 0000000cH
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN68@pop_back

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN68@pop_back:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN156@pop_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN156@pop_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [edi+16], -1
	jne	SHORT $LN2@pop_back

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [edi+12], 0
$LN2@pop_back:
	pop	edi
	pop	esi

; 1525 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1526 : 		}

	ret	0
?pop_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end, COMDAT
; _this$ = ecx

; 1289 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1290 : 		return (iterator(this->_Myoff() + this->_Mysize(),

	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1292 : 		}

	pop	ebp
	ret	4
?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin, COMDAT
; _this$ = ecx

; 1279 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1281 : 		}

	pop	ebp
	ret	4
?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Assign_rv@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEX$$QAV12@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Assign_rv, COMDAT
; _this$ = ecx

; 1141 : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 235  : 	_Container_proxy *_Temp = _Myproxy;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	esi, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [esi], edx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN23@Assign_rv

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], ecx
$LN23@Assign_rv:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN24@Assign_rv

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], esi
$LN24@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1120 : 		this->_Map() = _Right._Map();

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax

; 1121 : 		this->_Mapsize() = _Right._Mapsize();

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax

; 1122 : 		this->_Myoff() = _Right._Myoff();

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], eax

; 1123 : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], eax

; 1124 : 
; 1125 : 		_Right._Map() = _Mapptr();

	mov	DWORD PTR [esi+4], 0

; 1126 : 		_Right._Mapsize() = 0;

	mov	DWORD PTR [esi+8], 0

; 1127 : 		_Right._Myoff() = 0;

	mov	DWORD PTR [esi+12], 0

; 1128 : 		_Right._Mysize() = 0;

	mov	DWORD PTR [esi+16], 0
	pop	esi

; 1142 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1143 : 			typename _Alty::propagate_on_container_move_assignment());
; 1144 : 		}

	pop	ebp
	ret	4
?_Assign_rv@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEX$$QAV12@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Assign_rv@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Assign_rv, COMDAT
; _this$ = ecx

; 1118 : 		{	// move from _Right, stealing its contents

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 235  : 	_Container_proxy *_Temp = _Myproxy;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	esi, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [esi], edx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN18@Assign_rv

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], ecx
$LN18@Assign_rv:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN19@Assign_rv

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], esi
$LN19@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1120 : 		this->_Map() = _Right._Map();

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax

; 1121 : 		this->_Mapsize() = _Right._Mapsize();

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax

; 1122 : 		this->_Myoff() = _Right._Myoff();

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], eax

; 1123 : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], eax

; 1124 : 
; 1125 : 		_Right._Map() = _Mapptr();

	mov	DWORD PTR [esi+4], 0

; 1126 : 		_Right._Mapsize() = 0;

	mov	DWORD PTR [esi+8], 0

; 1127 : 		_Right._Myoff() = 0;

	mov	DWORD PTR [esi+12], 0

; 1128 : 		_Right._Mysize() = 0;

	mov	DWORD PTR [esi+16], 0
	pop	esi

; 1129 : 		}

	pop	ebp
	ret	8
?_Assign_rv@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$dead$ = ecx

; 534  : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$dead$ = ecx

; 912  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 735  : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 730  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 725  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 698  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 693  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$dead$ = ecx

; 607  : 		_Pocma(_Getal(), _Al);
; 608  : 		}

	ret	4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT
; _this$dead$ = ecx

; 602  : 		_Pocca(_Getal(), _Al);
; 603  : 		}

	ret	4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 590  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 590  : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN11@Myptr

; 583  : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 584  : 		}

	ret	0
$LN11@Myptr:

; 583  : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 584  : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN11@Myptr

; 578  : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 579  : 		}

	ret	0
$LN11@Myptr:

; 578  : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 579  : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 2249 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	je	SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN57@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN57@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	mov	eax, DWORD PTR [esi+20]
	inc	eax
	push	eax
	push	ebx
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
	pop	ebx
$LN4@Tidy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN92@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2262 : 		}

	pop	ebp
	ret	8
$LN92@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2262 : 		}

	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ptr$1$ = 12						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 2225 : 		if (max_size() < _Newsize)

	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN2@Grow

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN188@Grow:
$LN2@Grow:

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, edi
	jae	SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	edi, edi
	pop	edi
	setne	al
	pop	esi

; 2235 : 		}

	pop	ebp
	ret	8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	cmp	BYTE PTR __Trim$[ebp], 0
	je	SHORT $LN5@Grow
	cmp	edi, 16					; 00000010H
	jae	SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

	push	ebx
	mov	ebx, DWORD PTR [esi+16]
	cmp	edi, ebx
	cmovb	ebx, edi

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN73@Grow

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR __Ptr$1$[ebp], eax

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

	test	ebx, ebx
	je	SHORT $LN126@Grow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ebx
	push	eax
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN126@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	mov	eax, DWORD PTR [esi+20]
	inc	eax
	push	eax
	push	DWORD PTR __Ptr$1$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN73@Grow:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN161@Grow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN161@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+ebx], 0
	test	edi, edi
	pop	ebx
	pop	edi
	setne	al
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2235 : 		}

	pop	ebp
	ret	8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN186@Grow

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN178@Grow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN178@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	test	edi, edi
$LN186@Grow:
	pop	edi
	setne	al
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2235 : 		}

	pop	ebp
	ret	8
$LN187@Grow:
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2220 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2220 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Ch$dead$ = 12						; size = 1
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT
; _this$ = ecx

; 1780 : 		{	// determine new length, padding with _Ch elements as needed

	push	ebp
	mov	ebp, esp

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	mov	eax, DWORD PTR __Newsize$[ebp]
	cmp	eax, edx
	ja	SHORT $LN2@resize

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN25@resize
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN25@resize:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1785 : 		}

	pop	ebp
	ret	8
$LN2@resize:

; 1782 : 			_Eos(_Newsize);
; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	sub	eax, edx
	mov	DWORD PTR __Ch$dead$[ebp], 0
	mov	DWORD PTR __Newsize$[ebp], eax

; 1785 : 		}

	pop	ebp

; 1782 : 			_Eos(_Newsize);
; 1783 : 		else
; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 1766 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 1606 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN11@end
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

	mov	ecx, DWORD PTR [ecx+16]
	add	ecx, eax

; 48   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1609 : 		}

	pop	ebp
	ret	4
$LN11@end:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, ecx

; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

	mov	ecx, DWORD PTR [ecx+16]
	add	ecx, eax

; 48   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1609 : 		}

	pop	ebp
	ret	4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1594 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 48   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN11@begin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN11@begin:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 48   : 		: _Ptr(_Parg)

	mov	DWORD PTR [eax], ecx

; 1595 : 		auto _Mydata = &this->_Get_data();
; 1596 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));
; 1597 : 		}

	pop	ebp
	ret	4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@assign
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1183 : 		}

	pop	ebp
	ret	4
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@assign:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@assign
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1183 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

	mov	esi, ecx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN20@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN21@assign
$LN20@assign:
	mov	eax, esi
$LN21@assign:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN34@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN35@assign
$LN34@assign:
	mov	edx, esi
$LN35@assign:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN57@assign

; 1168 : 			return (assign(*this,

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1168 : 			return (assign(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN57@assign:

; 1168 : 			return (assign(*this,

	push	DWORD PTR __Count$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi

; 1168 : 			return (assign(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	edi

; 2225 : 		if (max_size() < _Newsize)

	mov	edi, DWORD PTR __Count$[ebp]
	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN62@assign

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN286@assign:
$LN62@assign:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN63@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

	je	SHORT $LN279@assign
$LN284@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN256@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN257@assign
$LN63@assign:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN284@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN238@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN238@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1177 : 		}

	pop	ebp
	ret	8
$LN256@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
$LN257@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN263@assign
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN263@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN274@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN274@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN279@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN285@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, ecx
	jae	SHORT $LN7@assign

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN307@assign:
$LN7@assign:

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	edi, DWORD PTR __Count$[ebp]
	sub	eax, ecx
	cmp	edi, eax
	cmova	edi, eax

; 1150 : 		_Right._Check_offset(_Roff);
; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1152 : 
; 1153 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	lea	eax, DWORD PTR [ecx+edi]

; 2271 : 		if (this->_Mysize() < _Off)

	cmp	DWORD PTR [esi+16], eax
	jae	SHORT $LN38@assign

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN308@assign:
$LN38@assign:

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN63@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN63@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@assign:

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN71@assign

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN309@assign:
$LN71@assign:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN72@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Roff$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1155 : 		else if (_Grow(_Count))

	je	SHORT $LN301@assign
$LN305@assign:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN264@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN264@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN278@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN279@assign
$LN72@assign:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN305@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN247@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN247@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN278@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi
$LN279@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN285@assign
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1157 : 			_Traits::copy(this->_Myptr(),

	lea	eax, DWORD PTR [ebx+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN285@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN296@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN296@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN301@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN306@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1143 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1111 : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	ebx

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	not	eax
	cmp	eax, ebx
	ja	SHORT $LN2@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN277@append:
$LN2@append:

; 1113 : 			_Xlen();	// result too long
; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+ebx]

; 1116 : 		if (0 < _Count && _Grow(_Num))

	test	ebx, ebx
	je	$LN271@append

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN27@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN278@append:
$LN27@append:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN28@append

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1116 : 		if (0 < _Count && _Grow(_Num))

	je	$LN271@append
$LN275@append:

; 1117 : 			{	// make room and append new stuff using assign
; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	mov	edx, DWORD PTR [esi+16]

; 2175 : 		if (_Count == 1)

	cmp	ebx, 1
	jne	SHORT $LN220@append

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN233@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [ecx+edx], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2177 : 		else

	jmp	SHORT $LN221@append
$LN28@append:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN275@append

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN203@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN203@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1122 : 		}

	pop	ebp
	ret	8
$LN233@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	al, BYTE PTR __Ch$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2177 : 		else

	jmp	SHORT $LN221@append
$LN220@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN250@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN251@append
$LN250@append:
	mov	ecx, esi
$LN251@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	movsx	eax, BYTE PTR __Ch$[ebp]
	push	ebx
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

	lea	eax, DWORD PTR [ecx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN221@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN266@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN266@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN271@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN276@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1087 : 		{	// append [_Ptr, _Ptr + _Count)

	mov	esi, ecx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@append

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN21@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN22@append
$LN21@append:
	mov	eax, esi
$LN22@append:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@append

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN35@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN36@append
$LN35@append:
	mov	edx, esi
$LN36@append:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@append

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN58@append

; 1090 : 			return (append(*this,

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1090 : 			return (append(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN58@append:

; 1090 : 			return (append(*this,

	push	DWORD PTR __Count$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi

; 1090 : 			return (append(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN2@append:

; 1091 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1092 : 		if (npos - this->_Mysize() <= _Count)

	mov	edx, DWORD PTR [esi+16]
	mov	eax, edx
	mov	ecx, DWORD PTR __Count$[ebp]
	not	eax
	cmp	eax, ecx
	ja	SHORT $LN3@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN316@append:
$LN3@append:
	push	edi

; 1093 : 			_Xlen();	// result too long
; 1094 : 
; 1095 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [edx+ecx]

; 1096 : 		if (0 < _Count && _Grow(_Num))

	test	ecx, ecx
	je	$LN309@append

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN84@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN317@append:
$LN84@append:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN85@append

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1096 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN309@append
$LN314@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN277@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN278@append
$LN85@append:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN314@append

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN260@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN260@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1102 : 		}

	pop	ebp
	ret	8
$LN277@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi
$LN278@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	ecx, ecx
	je	SHORT $LN293@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

	mov	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1098 : 			_Traits::copy(this->_Myptr() + this->_Mysize(), _Ptr, _Count);

	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN293@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN304@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN304@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN309@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1101 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1102 : 		}

	pop	ebp
	ret	8
$LN315@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 1070 : 		{	// append _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, ecx
	jae	SHORT $LN6@append

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN300@append:
$LN6@append:

; 1071 : 		_Right._Check_offset(_Roff);
; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

	mov	edx, DWORD PTR [esi+16]

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	sub	eax, ecx

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	ecx, DWORD PTR __Count$[ebp]
	cmp	ecx, eax
	cmova	ecx, eax

; 1071 : 		_Right._Check_offset(_Roff);
; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, edx
	not	eax

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	DWORD PTR __Count$[ebp], ecx

; 1071 : 		_Right._Check_offset(_Roff);
; 1072 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1073 : 		if (npos - this->_Mysize() <= _Count)

	cmp	eax, ecx
	ja	SHORT $LN2@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN301@append:
$LN2@append:

; 1074 : 			_Xlen();	// result too long
; 1075 : 
; 1076 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [edx+ecx]

; 1077 : 		if (0 < _Count && _Grow(_Num))

	test	ecx, ecx
	je	$LN294@append

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN55@append

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN302@append:
$LN55@append:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN56@append

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1077 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN294@append
$LN298@append:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN248@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN248@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN262@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN263@append
$LN56@append:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN298@append

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN231@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1083 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN231@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN262@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi
$LN263@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	ecx, ecx
	je	SHORT $LN278@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ecx
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1079 : 			_Traits::copy(this->_Myptr() + this->_Mysize(),

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN278@append:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN289@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1083 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN289@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN294@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1083 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1084 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN299@append:
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi

; 961  : 		{	// assign by moving _Right

	mov	edi, ecx

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jae	SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

	mov	eax, DWORD PTR [esi+16]
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN3@Assign_rv
	push	eax
	push	esi
	push	edi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	jmp	SHORT $LN3@Assign_rv
$LN2@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edi, edi
	je	SHORT $LN84@Assign_rv
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
$LN84@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 968  : 			_Right._Bx()._Ptr = pointer();

	mov	DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN227@Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 973  : 		}

	pop	ebp
	ret	4
$LN227@Assign_rv:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 973  : 		}

	pop	ebp
	ret	4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::~_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	edx, DWORD PTR ___that$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN13@Deque_cons

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN13@Deque_cons

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@Deque_cons:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	edx, DWORD PTR ___that$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN13@Deque_cons

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN13@Deque_cons

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@Deque_cons:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	edx, DWORD PTR ___that$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN15@Deque_iter

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN15@Deque_iter

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN15@Deque_iter:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::~_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::~_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::~_Deque_val<std::_Deque_simple_types<Json::Value *> >, COMDAT
; _this$dead$ = ecx
	ret	0
??1?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::~_Deque_val<std::_Deque_simple_types<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z
_TEXT	SEGMENT
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Setcont, COMDAT
; _this$ = ecx

; 518  : 		{	// set container pointer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Pdeque$[ebp]
	test	eax, eax
	je	SHORT $LN5@Setcont

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN5@Setcont:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 520  : 		}

	pop	ebp
	ret	4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 514  : 		}

	ret	4
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=, COMDAT
; _this$ = ecx

; 408  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp

; 409  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 410  : 		if (_Off != 0)
; 411  : 			{
; 412  : 			const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 413  : 			if (_Mycont == 0
; 414  : 				|| this->_Myoff + _Off < _Mycont->_Myoff
; 415  : 				|| _Mycont->_Myoff + _Mycont->_Mysize < this->_Myoff + _Off)
; 416  : 				{	// report error
; 417  : 				_DEBUG_ERROR("deque iterator + offset out of range");
; 418  : 				_SCL_SECURE_OUT_OF_RANGE;
; 419  : 				}
; 420  : 			}
; 421  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 422  : 		if (_Off != 0)
; 423  : 			{
; 424  : 			const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 425  : 			_SCL_SECURE_VALIDATE(_Mycont != 0);
; 426  : 			_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff + _Off
; 427  : 				&& this->_Myoff + _Off <= _Mycont->_Myoff + _Mycont->_Mysize);
; 428  : 			}
; 429  :  #endif /* _ITERATOR_DEBUG_LEVEL == 1 */
; 430  : 
; 431  : 		_Myoff += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	add	DWORD PTR [ecx+8], eax

; 432  : 		return (*this);

	mov	eax, ecx

; 433  : 		}

	pop	ebp
	ret	4
??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-, COMDAT
; _this$ = ecx

; 648  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, edx

; 649  : 		return (*(_Mybase *)this - _Right);
; 650  : 		}

	pop	ebp
	ret	4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+, COMDAT
; _this$ = ecx

; 631  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [ecx]
	push	esi

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	xor	esi, esi

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN17@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN17@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	esi, DWORD PTR [eax]
$LN17@operator:

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 626  : 		this->_Myoff += _Off;

	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], edx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	esi, esi
	je	SHORT $LN35@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	ecx, DWORD PTR [esi]

; 150  : 		if (_Parent == 0)

	test	ecx, ecx
	je	SHORT $LN35@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
$LN35@operator:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 634  : 		}

	pop	ebp
	ret	8
??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 572  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp

; 303  : 		: _Myoff(_Off)

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Pdeque$[ebp]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN13@Deque_iter

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@Deque_iter:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 573  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	eax, DWORD PTR __Count$[ebp]

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[ebp]

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN6@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@deallocate:
$LN6@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN7@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN8@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN8@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN9@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN9@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN10@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN10@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN11@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN11@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN7@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::allocate, COMDAT
; _this$dead$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 976  : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 977  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN7@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN18@allocate:
$LN7@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN10@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN19@allocate:
$LN10@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 976  : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 977  : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 977  : 		}

	pop	ebp
	ret	4
$LN17@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA?AV?$allocator@VErrorInfo@Reader@Json@@@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA?AV?$allocator@VErrorInfo@Reader@Json@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 875  : 		return (_Al);

	mov	eax, ecx

; 876  : 		}

	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SA?AV?$allocator@VErrorInfo@Reader@Json@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::deallocate, COMDAT
; _this$dead$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Get_data, COMDAT
; _this$ = ecx

; 896  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 897  : 		}

	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Swap_all@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Swap_all, COMDAT
; _this$ = ecx

; 880  : 		{	// swap all iterators

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 235  : 	_Container_proxy *_Temp = _Myproxy;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	esi, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [esi], edx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN16@Swap_all

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], ecx
$LN16@Swap_all:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN17@Swap_all

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], esi
$LN17@Swap_all:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 882  : 		}

	pop	ebp
	ret	4
?_Swap_all@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 850  : 		{	// destroy proxy

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 857  : 		}

	ret	0
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 841  : 		{	// construct proxy

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 841  : 		{	// construct proxy

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN81@Alloc_prox
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
$LN81@Alloc_prox:
	mov	DWORD PTR [eax], esi
	pop	esi

; 847  : 		}

	ret	0
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+, COMDAT
; _this$ = ecx

; 436  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [ecx]
	push	esi

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	xor	esi, esi

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN15@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN15@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	esi, DWORD PTR [eax]
$LN15@operator:

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 431  : 		_Myoff += _Off;

	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], edx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	esi, esi
	je	SHORT $LN31@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	ecx, DWORD PTR [esi]

; 150  : 		if (_Parent == 0)

	test	ecx, ecx
	je	SHORT $LN31@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
$LN31@operator:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 439  : 		}

	pop	ebp
	ret	8
??H?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$dead$ = 12					; size = 4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-, COMDAT
; _this$ = ecx

; 642  : 		{	// return this - integer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [ecx]
	push	esi

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	xor	esi, esi

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN17@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN17@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	esi, DWORD PTR [eax]
$LN17@operator:

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 626  : 		this->_Myoff += _Off;

	mov	edx, DWORD PTR [ecx+8]
	dec	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], edx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	esi, esi
	je	SHORT $LN37@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	ecx, DWORD PTR [esi]

; 150  : 		if (_Parent == 0)

	test	ecx, ecx
	je	SHORT $LN37@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
$LN37@operator:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 645  : 		}

	pop	ebp
	ret	8
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [ecx]
	push	esi
	test	eax, eax
	jne	SHORT $LN7@operator
	xor	esi, esi
	jmp	SHORT $LN8@operator
$LN7@operator:
	mov	esi, DWORD PTR [eax]
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, edx
	mov	eax, DWORD PTR [esi+8]

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	eax
	shr	ecx, 2
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+edx*4]

; 590  : 		return ((reference)**(_Mybase *)this);
; 591  : 		}

	ret	0
??D?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	eax, DWORD PTR __Count$[ebp]

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[ebp]

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN6@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@deallocate:
$LN6@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN7@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN8@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN8@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN9@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN9@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN10@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN10@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN11@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN21@deallocate:
$LN11@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN7@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::deallocate, COMDAT
; _this$dead$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::select_on_container_copy_construction, COMDAT
; _this$dead$ = ecx

; 912  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mysize, COMDAT
; _this$ = ecx

; 941  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 942  : 		}

	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mysize, COMDAT
; _this$ = ecx

; 936  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 937  : 		}

	ret	0
?_Mysize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myoff, COMDAT
; _this$ = ecx

; 926  : 		return (_Get_data()._Myoff);

	lea	eax, DWORD PTR [ecx+12]

; 927  : 		}

	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mapsize, COMDAT
; _this$ = ecx

; 916  : 		return (_Get_data()._Mapsize);

	lea	eax, DWORD PTR [ecx+8]

; 917  : 		}

	ret	0
?_Mapsize@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Mapsize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Map@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAPAPAVValue@Json@@XZ
_TEXT	SEGMENT
?_Map@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAPAPAVValue@Json@@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Map, COMDAT
; _this$ = ecx

; 906  : 		return (_Get_data()._Map);

	lea	eax, DWORD PTR [ecx+4]

; 907  : 		}

	ret	0
?_Map@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAPAPAVValue@Json@@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Map
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal, COMDAT
; _this$ = ecx

; 891  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 892  : 		}

	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal, COMDAT
; _this$ = ecx

; 886  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 887  : 		}

	ret	0
?_Getal@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Orphan_all, COMDAT
; _this$dead$ = ecx

; 876  : 		_Get_data()._Orphan_all();
; 877  : 		}

	ret	0
?_Orphan_all@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 850  : 		{	// destroy proxy

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
	pop	esi

; 857  : 		}

	ret	0
?_Free_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Move_alloc@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Move_alloc@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 834  : 		{	// replace old allocator

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN147@Move_alloc
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
$LN147@Move_alloc:
	mov	DWORD PTR [eax], esi
	pop	esi

; 835  : 		_Free_proxy();
; 836  : 		_Pocma(_Getal(), _Al);
; 837  : 		_Alloc_proxy();
; 838  : 		}

	ret	4
?_Move_alloc@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Copy_alloc@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
?_Copy_alloc@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 827  : 		{	// replace old allocator

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR [esi]
	call	??3@YAXPAX@Z				; operator delete

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 856  : 		_Myproxy() = 0;

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN147@Copy_alloc
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
$LN147@Copy_alloc:
	mov	DWORD PTR [eax], esi
	pop	esi

; 828  : 		_Free_proxy();
; 829  : 		_Pocca(_Getal(), _Al);
; 830  : 		_Alloc_proxy();
; 831  : 		}

	ret	4
?_Copy_alloc@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 808  : 		{	// default construct allocator

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN67@Deque_allo
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN67@Deque_allo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 809  : 		_Alloc_proxy();
; 810  : 		}

	mov	eax, esi
	pop	esi
	ret	0
??0?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEII@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getblock, COMDAT
; _this$ = ecx

; 802  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR __Off$[ebp]
	dec	eax
	shr	ecx, 2
	and	eax, ecx

; 803  : 		return (_Get_data()._Getblock(_Off));
; 804  : 		}

	pop	ebp
	ret	4
?_Getblock@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Myptr$1$ = -16					; size = 4
__Newmap$1$ = -12					; size = 4
_this$1$ = -8						; size = 4
__Myboff$1$ = -4					; size = 4
__Count$dead$ = 8					; size = 4
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap, COMDAT
; _this$ = ecx

; 1785 : 		{	// grow map by at least _Count pointers, _Mapsize() a power of 2

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1786 : 		static_assert(1 < _DEQUEMAPSIZ,
; 1787 : 			"The _Xlen() test should always be performed.");
; 1788 : 
; 1789 : 		typedef typename _Alpty::pointer _Blockptr;
; 1790 : 		_Alpty _Almap(this->_Getal());
; 1791 : 		size_type _Newsize = 0 < this->_Mapsize() ? this->_Mapsize() : 1;

	mov	esi, 1
	mov	DWORD PTR _this$1$[ebp], edi
	mov	ecx, DWORD PTR [edi+8]
	test	ecx, ecx
	cmovne	esi, ecx
	npad	5
$LL2@Growmap:

; 1792 : 		while (_Newsize - this->_Mapsize() < _Count
; 1793 : 			|| _Newsize < _DEQUEMAPSIZ)

	mov	eax, esi
	sub	eax, ecx
	cmp	eax, 1
	jb	SHORT $LN4@Growmap
	cmp	esi, 8
	jae	SHORT $LN3@Growmap
$LN4@Growmap:

; 1794 : 			{	// scale _Newsize to 2^N >= _Mapsize() + _Count
; 1795 : 			if (max_size() / _DEQUESIZ - _Newsize < _Newsize)

	mov	eax, 268435455				; 0fffffffH
	sub	eax, esi
	cmp	eax, esi
	jb	$LN332@Growmap

; 1796 : 				_Xlen();	// result too long
; 1797 : 			_Newsize *= 2;

	add	esi, esi

; 1798 : 			}

	jmp	SHORT $LL2@Growmap
$LN3@Growmap:

; 1799 : 		_Count = _Newsize - this->_Mapsize();
; 1800 : 
; 1801 : 		size_type _Myboff = this->_Myoff() / _DEQUESIZ;

	mov	ebx, DWORD PTR [edi+12]
	sub	esi, ecx
	shr	ebx, 2
	mov	DWORD PTR __Myboff$1$[ebp], ebx

; 1802 : 		_Mapptr _Newmap = _Almap.allocate(this->_Mapsize() + _Count);

	lea	eax, DWORD PTR [ecx+esi]
	push	eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::allocate

; 1803 : 		_Mapptr _Myptr = _Newmap + _Myboff;
; 1804 : 
; 1805 : 		_Myptr = _Uninitialized_copy(this->_Map() + _Myboff,

	mov	ecx, DWORD PTR [edi+4]
	mov	edi, DWORD PTR [edi+8]
	shl	ebx, 2
	shl	edi, 2
	mov	DWORD PTR __Newmap$1$[ebp], eax
	lea	edx, DWORD PTR [ecx+ebx]
	add	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, edx
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	edx
	push	ebx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	edx, DWORD PTR [edi+ebx]
	mov	DWORD PTR __Myptr$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1808 : 		if (_Myboff <= _Count)

	cmp	DWORD PTR __Myboff$1$[ebp], esi
	ja	SHORT $LN6@Growmap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ebx+4]

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, eax
	mov	ebx, DWORD PTR __Myboff$1$[ebp]
	sub	edi, eax
	lea	ecx, DWORD PTR [ebx*4]
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	mov	eax, DWORD PTR __imp__memmove
	push	edx
	call	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	mov	eax, esi
	sub	eax, ebx
	shl	eax, 2
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Myptr$1$[ebp]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	0
	push	eax
	call	_memset
	mov	edi, DWORD PTR __Newmap$1$[ebp]
	mov	ecx, ebx
	lea	eax, DWORD PTR [ecx*4]
	push	eax
	push	0
	push	edi
	call	_memset
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1818 : 		else

	jmp	SHORT $LN337@Growmap
$LN6@Growmap:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	edi, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1820 : 			_Uninitialized_copy(this->_Map(),

	lea	ebx, DWORD PTR [esi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	eax, DWORD PTR __imp__memmove
	push	ebx
	mov	ecx, DWORD PTR [edi+4]
	push	ecx
	push	edx
	call	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1823 : 			_Myptr = _Uninitialized_copy(this->_Map() + _Count,

	mov	edi, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edx, DWORD PTR __Myboff$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1823 : 			_Myptr = _Uninitialized_copy(this->_Map() + _Count,

	lea	eax, DWORD PTR [ebx+edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, eax
	lea	ecx, DWORD PTR [edx*4]
	add	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	DWORD PTR __Newmap$1$[ebp]
	call	DWORD PTR __imp__memmove

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Newmap$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	push	0
	push	eax
	call	_memset
	mov	edi, DWORD PTR __Newmap$1$[ebp]
$LN337@Growmap:
	mov	ebx, DWORD PTR _this$1$[ebp]
	add	esp, 36					; 00000024H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1832 : 		if (this->_Map() != _Mapptr())

	mov	eax, DWORD PTR [ebx+4]
	test	eax, eax
	je	SHORT $LN8@Growmap

; 1833 : 			_Almap.deallocate(this->_Map(),

	push	DWORD PTR [ebx+8]
	push	eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@I@Z ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::deallocate
$LN8@Growmap:

; 1834 : 				this->_Mapsize());	// free storage for old
; 1835 : 
; 1836 : 		this->_Map() = _Newmap;	// point at new

	mov	DWORD PTR [ebx+4], edi

; 1837 : 		this->_Mapsize() += _Count;

	add	DWORD PTR [ebx+8], esi
	pop	edi
	pop	esi
	pop	ebx

; 1838 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN332@Growmap:

; 1776 : 		_Xlength_error("deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN339@Growmap:
$LN338@Growmap:
	int	3
?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::clear, COMDAT
; _this$ = ecx

; 1675 : 		_Tidy();

	jmp	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy
?clear@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T55 = -44						; size = 12
$T35 = -44						; size = 12
$T9 = -44						; size = 12
$T4 = -44						; size = 12
$T3 = -44						; size = 12
__Last$ = -32						; size = 12
__First$ = -20						; size = 12
__Off$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 12
__Last_arg$ = 24					; size = 12
?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase, COMDAT
; _this$ = ecx

; 1633 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi

; 1634 : 		iterator _First = _Make_iter(_First_arg);

	sub	esp, 12					; 0000000cH
	mov	esi, ecx
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First_arg$[ebp]
	test	eax, eax
	je	SHORT $LN23@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN23@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN23@erase:
	mov	eax, DWORD PTR __First_arg$[ebp+8]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1634 : 		iterator _First = _Make_iter(_First_arg);

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	mov	ecx, esi
	call	?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter

; 1635 : 		iterator _Last = _Make_iter(_Last_arg);

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last_arg$[ebp]
	test	eax, eax
	je	SHORT $LN37@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN37@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN37@erase:
	mov	eax, DWORD PTR __Last_arg$[ebp+8]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1635 : 		iterator _Last = _Make_iter(_Last_arg);

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, esi
	call	?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter

; 1636 : 
; 1637 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1638 : 		if (_Last < _First
; 1639 : 			|| _First < begin() || end() < _Last)
; 1640 : 			_DEBUG_ERROR("deque erase iterator outside range");
; 1641 : 		_DEBUG_RANGE(_First, _Last);
; 1642 : 
; 1643 : 		size_type _Off = _First - begin();
; 1644 : 		size_type _Count = _Last - _First;
; 1645 : 		bool _Moved = 0 < _Off && _Off + _Count < this->_Mysize();
; 1646 : 
; 1647 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1648 : 		size_type _Off = _First - begin();

	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, esi
	push	eax
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	edx, DWORD PTR __First$[ebp+8]
	mov	ebx, edx
	mov	ecx, DWORD PTR [eax+8]
	sub	ebx, ecx
	mov	eax, edx
	sub	eax, ecx
	cmp	ecx, edx

; 1652 : 		if (_Off < (size_type)(end() - _Last))

	mov	ecx, esi
	cmovbe	ebx, eax
	mov	DWORD PTR __Off$1$[ebp], ebx

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	ebx, DWORD PTR __Last$[ebp+8]
	mov	eax, ebx
	sub	eax, edx
	mov	edi, ebx
	sub	edi, edx
	cmp	edx, ebx
	cmovbe	edi, eax

; 1652 : 		if (_Off < (size_type)(end() - _Last))

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end

; 1654 : 			_STD move_backward(begin(), _First, _Last);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	ecx, esp

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	eax, DWORD PTR [eax+8]
	sub	eax, ebx
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0
	cmp	DWORD PTR __Off$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1652 : 		if (_Off < (size_type)(end() - _Last))

	jae	SHORT $LN8@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]
	test	eax, eax
	je	SHORT $LN77@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN77@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN77@erase:

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1654 : 			_STD move_backward(begin(), _First, _Last);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], ebx
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN93@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN93@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN93@erase:
	mov	eax, DWORD PTR __First$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1654 : 			_STD move_backward(begin(), _First, _Last);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esi
	push	esp
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	lea	ecx, DWORD PTR $T9[ebp]
	call	??$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H

; 1655 : 			for (; 0 < _Count; --_Count)

	test	edi, edi
	je	$LN6@erase
$LL4@erase:

; 1486 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN96@erase

; 1487 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0

; 1488 : 		else

	jmp	SHORT $LN2@erase
$LN96@erase:

; 1489 : 			++this->_Myoff();

	inc	DWORD PTR [esi+12]
$LN2@erase:

; 1655 : 			for (; 0 < _Count; --_Count)

	sub	edi, 1
	jne	SHORT $LL4@erase

; 1656 : 				pop_front();	// pop copied elements
; 1657 : 			}
; 1658 : 		else

	jmp	SHORT $LN6@erase
$LN8@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN185@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN185@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN185@erase:
	mov	eax, DWORD PTR __First$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1660 : 			_STD move(_Last, end(), _First);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esi
	push	esp
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1660 : 			_STD move(_Last, end(), _First);	// copy over hole

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN201@erase

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN201@erase

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN201@erase:
	mov	DWORD PTR [ecx+8], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1660 : 			_STD move(_Last, end(), _First);	// copy over hole

	lea	ecx, DWORD PTR $T35[ebp]
	call	??$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H

; 1661 : 			for (; 0 < _Count; --_Count)

	test	edi, edi
	je	SHORT $LN6@erase
$LL7@erase:

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN5@erase

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0
$LN5@erase:

; 1661 : 			for (; 0 < _Count; --_Count)

	sub	edi, 1
	jne	SHORT $LL7@erase
$LN6@erase:

; 1662 : 				pop_back();	// pop copied elements
; 1663 : 			}
; 1664 : 
; 1665 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1666 : 		if (_Moved)
; 1667 : 			this->_Orphan_all();
; 1668 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1669 : 
; 1670 : 		return (begin() + _Off);

	push	DWORD PTR __Off$1$[ebp]
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	lea	eax, DWORD PTR $T55[ebp]
	push	edi
	push	eax
	mov	ecx, esi
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	eax, edi

; 1671 : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
?erase@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end, COMDAT
; _this$ = ecx

; 1295 : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1296 : 		return (const_iterator(this->_Myoff() + this->_Mysize(),

	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1298 : 		}

	pop	ebp
	ret	4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end, COMDAT
; _this$ = ecx

; 1289 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1290 : 		return (iterator(this->_Myoff() + this->_Mysize(),

	mov	edx, DWORD PTR [ecx+16]
	add	edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1292 : 		}

	pop	ebp
	ret	4
?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin, COMDAT
; _this$ = ecx

; 1284 : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1286 : 		}

	pop	ebp
	ret	4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin, COMDAT
; _this$ = ecx

; 1279 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	edx, DWORD PTR [ecx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 172  : 			_Myproxy = _Parent_proxy;

	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1281 : 		}

	pop	ebp
	ret	4
?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Assign_rv@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAV12@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Assign_rv, COMDAT
; _this$ = ecx

; 1141 : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 235  : 	_Container_proxy *_Temp = _Myproxy;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	esi, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [esi], edx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN23@Assign_rv

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], ecx
$LN23@Assign_rv:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN24@Assign_rv

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], esi
$LN24@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1120 : 		this->_Map() = _Right._Map();

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax

; 1121 : 		this->_Mapsize() = _Right._Mapsize();

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax

; 1122 : 		this->_Myoff() = _Right._Myoff();

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], eax

; 1123 : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], eax

; 1124 : 
; 1125 : 		_Right._Map() = _Mapptr();

	mov	DWORD PTR [esi+4], 0

; 1126 : 		_Right._Mapsize() = 0;

	mov	DWORD PTR [esi+8], 0

; 1127 : 		_Right._Myoff() = 0;

	mov	DWORD PTR [esi+12], 0

; 1128 : 		_Right._Mysize() = 0;

	mov	DWORD PTR [esi+16], 0
	pop	esi

; 1142 : 		_Assign_rv(_STD forward<_Myt>(_Right),
; 1143 : 			typename _Alty::propagate_on_container_move_assignment());
; 1144 : 		}

	pop	ebp
	ret	4
?_Assign_rv@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAV12@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Assign_rv@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
___formal$ = 12						; size = 1
?_Assign_rv@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Assign_rv, COMDAT
; _this$ = ecx

; 1118 : 		{	// move from _Right, stealing its contents

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 235  : 	_Container_proxy *_Temp = _Myproxy;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	esi, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [esi], edx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN18@Assign_rv

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], ecx
$LN18@Assign_rv:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN19@Assign_rv

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], esi
$LN19@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1120 : 		this->_Map() = _Right._Map();

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx+4], eax

; 1121 : 		this->_Mapsize() = _Right._Mapsize();

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax

; 1122 : 		this->_Myoff() = _Right._Myoff();

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [ecx+12], eax

; 1123 : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [ecx+16], eax

; 1124 : 
; 1125 : 		_Right._Map() = _Mapptr();

	mov	DWORD PTR [esi+4], 0

; 1126 : 		_Right._Mapsize() = 0;

	mov	DWORD PTR [esi+8], 0

; 1127 : 		_Right._Myoff() = 0;

	mov	DWORD PTR [esi+12], 0

; 1128 : 		_Right._Mysize() = 0;

	mov	DWORD PTR [esi+16], 0
	pop	esi

; 1129 : 		}

	pop	ebp
	ret	8
?_Assign_rv@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEX$$QAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1776 : 		_Xlength_error("deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IBEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front, COMDAT
; _this$ = ecx

; 1466 : 		{	// erase element at beginning

	push	esi
	push	edi
	mov	edi, ecx

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [edi+8]

; 1467 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1468 : 		if (empty())
; 1469 : 			_DEBUG_ERROR("deque empty before pop");
; 1470 : 		else
; 1471 : 			{	// something to erase, do it
; 1472 : 			_Orphan_off(this->_Myoff());
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff());
; 1474 : 			this->_Getal().destroy(
; 1475 : 				_Unfancy(this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ));
; 1476 : 			if (--this->_Mysize() == 0)
; 1477 : 				this->_Myoff() = 0;
; 1478 : 			else
; 1479 : 				++this->_Myoff();
; 1480 : 			}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 		size_type _Block = this->_Getblock(this->_Myoff());
; 1484 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [edi+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	edx
	and	edx, DWORD PTR [edi+12]

; 1467 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1468 : 		if (empty())
; 1469 : 			_DEBUG_ERROR("deque empty before pop");
; 1470 : 		else
; 1471 : 			{	// something to erase, do it
; 1472 : 			_Orphan_off(this->_Myoff());
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff());
; 1474 : 			this->_Getal().destroy(
; 1475 : 				_Unfancy(this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ));
; 1476 : 			if (--this->_Mysize() == 0)
; 1477 : 				this->_Myoff() = 0;
; 1478 : 			else
; 1479 : 				++this->_Myoff();
; 1480 : 			}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 		size_type _Block = this->_Getblock(this->_Myoff());
; 1484 : 		this->_Getal().destroy(

	mov	esi, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	add	esi, 12					; 0000000cH
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN69@pop_front

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN69@pop_front:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN157@pop_front
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN157@pop_front:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1486 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [edi+16], -1
	jne	SHORT $LN2@pop_front

; 1487 : 			this->_Myoff() = 0;

	mov	DWORD PTR [edi+12], 0
	pop	edi
	pop	esi

; 1490 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1491 : 		}

	ret	0
$LN2@pop_front:

; 1488 : 		else
; 1489 : 			++this->_Myoff();

	inc	DWORD PTR [edi+12]
	pop	edi
	pop	esi

; 1490 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1491 : 		}

	ret	0
?pop_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::pop_front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty, COMDAT
; _this$ = ecx

; 1392 : 		{	// test if sequence is empty

	cmp	DWORD PTR [ecx+16], 0
	sete	al

; 1393 : 		return (this->_Mysize() == 0);
; 1394 : 		}

	ret	0
?empty@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE_NXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT
; _this$dead$ = ecx

; 1388 : 		return (this->_Getal().max_size());

	mov	eax, 107374182				; 06666666H

; 1389 : 		}

	ret	0
?max_size@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter, COMDAT
; _this$ = ecx

; 1301 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	edx, DWORD PTR __Where$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	test	ecx, ecx
	je	SHORT $LN19@Make_iter

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
$LN19@Make_iter:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1303 : 		}

	pop	ebp
	ret	16					; 00000010H
?_Make_iter@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	ret	4
?allocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$dead$ = 12					; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 322  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp

; 48   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 323  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

	ret	0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 875  : 		return (_Al);

	mov	eax, ecx

; 876  : 		}

	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$dead$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	DWORD PTR __Count$[ebp], 4096		; 00001000H

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	eax, DWORD PTR __Ptr$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	jb	SHORT $LN7@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	je	SHORT $LN8@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@deallocate:
$LN8@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN9@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN9@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN10@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN19@deallocate:
$LN10@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN11@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN20@deallocate:
$LN11@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN7@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
$LN16@deallocate:
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::address, COMDAT
; _this$dead$ = ecx

; 925  : 		{	// return address of mutable _Val

	push	ebp
	mov	ebp, esp

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 927  : 		}

	pop	ebp
	ret	4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

	mov	eax, ecx

; 715  : 		}

	ret	0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 708  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 703  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	push	ebp
	mov	ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jae	SHORT $LN2@Check_offs

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN18@Check_offs:
$LN2@Check_offs:

; 2272 : 			_Xran();
; 2273 : 		}

	pop	ebp
	ret	4
$LN17@Check_offs:
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	esi
	test	edx, edx
	je	SHORT $LN4@Inside

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN16@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN17@Inside
$LN16@Inside:
	mov	esi, ecx
$LN17@Inside:

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	edx, esi
	jb	SHORT $LN4@Inside

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN30@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN31@Inside
$LN30@Inside:
	mov	esi, ecx
$LN31@Inside:

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [ecx+16]
	add	eax, esi
	cmp	eax, edx
	jbe	SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

	mov	al, 1
	pop	esi

; 2244 : 		}

	pop	ebp
	ret	4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2244 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	edi, eax
	or	edi, 15					; 0000000fH

; 2184 : 		if (max_size() < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

	jmp	SHORT $LN108@Copy
$LN2@Copy:
	mov	ebx, DWORD PTR [esi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

	mov	eax, -2					; fffffffeH

; 2189 : 			_Newres = this->_Myres()

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN108@Copy

; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	edi, -2					; fffffffeH
$LN108@Copy:

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 51   : 	if (_Count == 0)

	test	eax, eax
	jne	SHORT $LN136@Copy

; 52   : 		return (_Ptr);

	xor	ebx, ebx
	jmp	SHORT $LN19@Copy
$LN136@Copy:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)
; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;
; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN138@Copy

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN140@Copy

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN435@Copy:
$LN140@Copy:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ebx, DWORD PTR [eax+35]
	and	ebx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ebx-4], eax

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else

	jmp	SHORT $LN19@Copy
$LN138@Copy:

; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
	jmp	SHORT $LN19@Copy
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	inc	eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

	mov	eax, $LN432@Copy
	ret	0
$LN432@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	mov	eax, DWORD PTR __Oldlen$[ebp]
	test	eax, eax
	je	SHORT $LN270@Copy

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN261@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN262@Copy
$LN261@Copy:
	mov	ecx, esi
$LN262@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	eax, eax
	je	SHORT $LN270@Copy
	push	eax
	push	ecx
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN270@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN274@Copy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN274@Copy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN362@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN363@Copy
$LN362@Copy:
	mov	eax, esi
$LN363@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	eax, DWORD PTR __Oldlen$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2212 : 		this->_Myres() = _Newres;

	mov	DWORD PTR [esi+20], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN426@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, ebx
$LN426@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR _this$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN156@Copy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN156@Copy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN245@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN245@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2203 : 			_RERAISE;

	push	0
	push	0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2203 : 			_RERAISE;

	call	__CxxThrowException@8
$LN436@Copy:
$LN434@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off

	push	ebp
	mov	ebp, esp

; 2175 : 		if (_Count == 1)

	mov	eax, DWORD PTR __Count$[ebp]
	mov	edx, ecx
	cmp	eax, 1
	jne	SHORT $LN2@Chassign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN16@Chassign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN16@Chassign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	eax, DWORD PTR __Off$[ebp]
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [edx+eax], cl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2179 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Chassign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN33@Chassign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN33@Chassign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	movsx	eax, BYTE PTR __Ch$[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

	mov	eax, DWORD PTR __Off$[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2179 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

	push	ebp
	mov	ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

	cmp	DWORD PTR __Size$[ebp], eax
	cmovbe	eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1772 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	edi, ecx
	jae	SHORT $LN7@erase

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN94@erase:
$LN7@erase:

; 1348 : 		_Check_offset(_Off);
; 1349 : 		if (this->_Mysize() - _Off <= _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, ecx
	cmp	eax, edx
	ja	SHORT $LN2@erase

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN41@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN41@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1359 : 		}

	pop	ebp
	ret	8
$LN2@erase:

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1351 : 		else if (0 < _Count)

	test	edx, edx
	je	SHORT $LN90@erase

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN58@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN59@erase
$LN58@erase:
	mov	eax, esi
$LN59@erase:

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	edi, edx
	push	ebx
	lea	ebx, DWORD PTR [eax+ecx]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, edi
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN74@erase
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ebx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	push	ebx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN74@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi
	pop	ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN85@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN85@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN90@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN93@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jae	SHORT $LN4@erase

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN38@erase:
$LN4@erase:

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN29@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1343 : 		return (*this);

	mov	eax, ecx

; 1344 : 		}

	pop	ebp
	ret	4
$LN29@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1343 : 		return (*this);

	mov	eax, ecx

; 1344 : 		}

	pop	ebp
	ret	4
$LN37@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	edx, DWORD PTR ___that$[ebp]

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN15@Deque_iter

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN15@Deque_iter

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN15@Deque_iter:
	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z PROC	; std::pointer_traits<char *>::pointer_to, COMDAT
; __Val$ = ecx

; 280  : 		return (_STD addressof(_Val));

	mov	eax, ecx

; 281  : 		}

	ret	0
?pointer_to@?$pointer_traits@PAD@std@@SAPADAAD@Z ENDP	; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate, COMDAT
; _this$dead$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address, COMDAT
; _this$dead$ = ecx

; 925  : 		{	// return address of mutable _Val

	push	ebp
	mov	ebp, esp

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 927  : 		}

	pop	ebp
	ret	4
?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-, COMDAT
; _this$ = ecx

; 453  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 454  : 		_Compat(_Right);
; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, edx

; 456  : 			? this->_Myoff - _Right._Myoff
; 457  : 			: -(difference_type)(_Right._Myoff - this->_Myoff));
; 458  : 		}

	pop	ebp
	ret	4
??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=, COMDAT
; _this$ = ecx

; 625  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp

; 626  : 		this->_Myoff += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	add	DWORD PTR [ecx+8], eax

; 627  : 		return (*this);

	mov	eax, ecx

; 628  : 		}

	pop	ebp
	ret	4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::allocate, COMDAT
; _this$dead$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	pop	ebp
	ret	4
$LN14@allocate:
?allocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::deallocate, COMDAT
; _this$dead$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	eax, DWORD PTR __Count$[ebp]

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[ebp]

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN4@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN14@deallocate:
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN6@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN15@deallocate:
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN7@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@deallocate:
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN8@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@deallocate:
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN9@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 721  : 		}

	pop	ebp
	ret	8
$LN13@deallocate:
?deallocate@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 107374182				; 06666666H

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myproxy, COMDAT
; _this$ = ecx

; 866  : 		return (_Get_data()._Myproxy);

	mov	eax, ecx

; 867  : 		}

	ret	0
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=, COMDAT
; _this$ = ecx

; 408  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp

; 409  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 410  : 		if (_Off != 0)
; 411  : 			{
; 412  : 			const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 413  : 			if (_Mycont == 0
; 414  : 				|| this->_Myoff + _Off < _Mycont->_Myoff
; 415  : 				|| _Mycont->_Myoff + _Mycont->_Mysize < this->_Myoff + _Off)
; 416  : 				{	// report error
; 417  : 				_DEBUG_ERROR("deque iterator + offset out of range");
; 418  : 				_SCL_SECURE_OUT_OF_RANGE;
; 419  : 				}
; 420  : 			}
; 421  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 422  : 		if (_Off != 0)
; 423  : 			{
; 424  : 			const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 425  : 			_SCL_SECURE_VALIDATE(_Mycont != 0);
; 426  : 			_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff + _Off
; 427  : 				&& this->_Myoff + _Off <= _Mycont->_Myoff + _Mycont->_Mysize);
; 428  : 			}
; 429  :  #endif /* _ITERATOR_DEBUG_LEVEL == 1 */
; 430  : 
; 431  : 		_Myoff += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	add	DWORD PTR [ecx+8], eax

; 432  : 		return (*this);

	mov	eax, ecx

; 433  : 		}

	pop	ebp
	ret	4
??Y?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [ecx]
	push	esi
	test	eax, eax
	jne	SHORT $LN5@operator
	xor	esi, esi
	jmp	SHORT $LN6@operator
$LN5@operator:
	mov	esi, DWORD PTR [eax]
$LN6@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
	mov	ecx, edx
	mov	eax, DWORD PTR [esi+8]

; 323  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 324  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 325  : 		if (_Mycont == 0
; 326  : 			|| this->_Myoff < _Mycont->_Myoff
; 327  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 328  : 		{	// report error
; 329  : 		_DEBUG_ERROR("deque iterator not dereferencable");
; 330  : 		_SCL_SECURE_OUT_OF_RANGE;
; 331  : 		}
; 332  : 
; 333  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 334  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 335  : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myoff <= this->_Myoff
; 336  : 			&& this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 337  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 338  : 
; 339  : 		_Analysis_assume_(_Mycont != 0);
; 340  : 
; 341  : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	eax
	shr	ecx, 2
	and	ecx, eax

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [esi+4]
	pop	esi
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+edx*4]

; 344  : 		}

	ret	0
??D?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx

; 304  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp

; 303  : 		: _Myoff(_Off)

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Pdeque$[ebp]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN11@Deque_cons

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN11@Deque_cons:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 306  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-, COMDAT
; _this$ = ecx

; 648  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, edx

; 649  : 		return (*(_Mybase *)this - _Right);
; 650  : 		}

	pop	ebp
	ret	4
??G?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-=, COMDAT
; _this$ = ecx

; 626  : 		this->_Myoff += _Off;

	dec	DWORD PTR [ecx+8]

; 638  : 		return (*this += -_Off);

	mov	eax, ecx

; 639  : 		}

	ret	4
??Z?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+, COMDAT
; _this$ = ecx

; 631  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [ecx]
	push	esi

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	xor	esi, esi

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN17@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN17@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	esi, DWORD PTR [eax]
$LN17@operator:

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 626  : 		this->_Myoff += _Off;

	mov	edx, DWORD PTR [ecx+8]
	add	edx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], edx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	esi, esi
	je	SHORT $LN35@operator

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	ecx, DWORD PTR [esi]

; 150  : 		if (_Parent == 0)

	test	ecx, ecx
	je	SHORT $LN35@operator

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
$LN35@operator:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 634  : 		}

	pop	ebp
	ret	8
??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx

; 572  : 		{	// construct with offset _Off in *_Pdeque

	push	ebp
	mov	ebp, esp

; 303  : 		: _Myoff(_Off)

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Pdeque$[ebp]

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN13@Deque_iter

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@Deque_iter:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 573  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock, COMDAT
; _this$ = ecx

; 767  : 		{	// determine block from offset

	push	ebp
	mov	ebp, esp

; 768  : 			// NB: _Mapsize and _DEQUESIZ are guaranteed to be powers of 2
; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	mov	ecx, DWORD PTR __Off$[ebp]
	dec	eax
	shr	ecx, 2
	and	eax, ecx

; 770  : 		}

	pop	ebp
	ret	4
?_Getblock@?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QBEII@Z ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Getblock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::allocate, COMDAT
; _this$dead$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 976  : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 977  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN7@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN18@allocate:
$LN7@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN10@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN19@allocate:
$LN10@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 976  : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 977  : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 977  : 		}

	pop	ebp
	ret	4
$LN17@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAEPAPAPAVValue@Json@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value * *>::deallocate, COMDAT
; _this$dead$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	mov	eax, DWORD PTR __Count$[ebp]

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR __Ptr$[ebp]

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN4@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN14@deallocate:
$LN4@deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	je	SHORT $LN6@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN15@deallocate:
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jb	SHORT $LN7@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@deallocate:
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jae	SHORT $LN8@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@deallocate:
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	jbe	SHORT $LN9@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN18@deallocate:
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 721  : 		}

	pop	ebp
	ret	8
$LN13@deallocate:
?deallocate@?$allocator@PAPAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SA?AV?$allocator@PAVValue@Json@@@2@ABV32@@Z
_TEXT	SEGMENT
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SA?AV?$allocator@PAVValue@Json@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::select_on_container_copy_construction, COMDAT
; ___$ReturnUdt$ = ecx
; __Al$dead$ = edx

; 875  : 		return (_Al);

	mov	eax, ecx

; 876  : 		}

	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SA?AV?$allocator@PAVValue@Json@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABIXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myoff, COMDAT
; _this$ = ecx

; 931  : 		return (_Get_data()._Myoff);

	lea	eax, DWORD PTR [ecx+12]

; 932  : 		}

	ret	0
?_Myoff@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABIXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Get_data, COMDAT
; _this$ = ecx

; 901  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 902  : 		}

	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Get_data, COMDAT
; _this$ = ecx

; 896  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 897  : 		}

	ret	0
?_Get_data@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Swap_all@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXAAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Swap_all@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXAAV12@@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Swap_all, COMDAT
; _this$ = ecx

; 880  : 		{	// swap all iterators

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 235  : 	_Container_proxy *_Temp = _Myproxy;

	mov	edx, DWORD PTR [ecx]
	push	esi

; 236  : 	_Myproxy = _Right._Myproxy;

	mov	esi, DWORD PTR __Right$[ebp]
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax

; 237  : 	_Right._Myproxy = _Temp;

	mov	DWORD PTR [esi], edx

; 238  : 
; 239  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN16@Swap_all

; 240  : 		_Myproxy->_Mycont = (_Container_base12 *)this;

	mov	DWORD PTR [eax], ecx
$LN16@Swap_all:

; 241  : 	if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN17@Swap_all

; 242  : 		_Right._Myproxy->_Mycont = (_Container_base12 *)&_Right;

	mov	DWORD PTR [eax], esi
$LN17@Swap_all:
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 882  : 		}

	pop	ebp
	ret	4
?_Swap_all@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXAAV12@@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Swap_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myproxy, COMDAT
; _this$ = ecx

; 866  : 		return (_Get_data()._Myproxy);

	mov	eax, ecx

; 867  : 		}

	ret	0
?_Myproxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 841  : 		{	// construct proxy

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 841  : 		{	// construct proxy

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN81@Alloc_prox
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
$LN81@Alloc_prox:
	mov	DWORD PTR [eax], esi
	pop	esi

; 847  : 		}

	ret	0
?_Alloc_proxy@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen, COMDAT
; _this$dead$ = ecx

; 1776 : 		_Xlength_error("deque<T> too long");

	push	OFFSET ??_C@_0BC@KBDMBKEH@deque?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IBEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front, COMDAT
; _this$ = ecx

; 1467 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1468 : 		if (empty())
; 1469 : 			_DEBUG_ERROR("deque empty before pop");
; 1470 : 		else
; 1471 : 			{	// something to erase, do it
; 1472 : 			_Orphan_off(this->_Myoff());
; 1473 : 			size_type _Block = this->_Getblock(this->_Myoff());
; 1474 : 			this->_Getal().destroy(
; 1475 : 				_Unfancy(this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ));
; 1476 : 			if (--this->_Mysize() == 0)
; 1477 : 				this->_Myoff() = 0;
; 1478 : 			else
; 1479 : 				++this->_Myoff();
; 1480 : 			}
; 1481 : 
; 1482 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1483 : 		size_type _Block = this->_Getblock(this->_Myoff());
; 1484 : 		this->_Getal().destroy(
; 1485 : 			_Unfancy(this->_Map()[_Block] + this->_Myoff() % _DEQUESIZ));
; 1486 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [ecx+16], -1
	jne	SHORT $LN2@pop_front

; 1487 : 			this->_Myoff() = 0;

	mov	DWORD PTR [ecx+12], 0

; 1490 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1491 : 		}

	ret	0
$LN2@pop_front:

; 1488 : 		else
; 1489 : 			++this->_Myoff();

	inc	DWORD PTR [ecx+12]

; 1490 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1491 : 		}

	ret	0
?pop_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::pop_front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1388 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1389 : 		}

	ret	0
?max_size@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIXZ ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter, COMDAT
; _this$ = ecx

; 1301 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	edx, DWORD PTR __Where$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 303  : 		: _Myoff(_Off)

	mov	DWORD PTR [eax+8], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	test	ecx, ecx
	je	SHORT $LN19@Make_iter

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx
$LN19@Make_iter:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1303 : 		}

	pop	ebp
	ret	16					; 00000010H
?_Make_iter@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QBE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Make_iter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value *>::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	ret	4
?allocate@?$allocator@PAVValue@Json@@@std@@QAEPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value *>::deallocate, COMDAT
; _this$dead$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::deallocate, COMDAT
; _this$dead$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@I@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@ABV01@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$dead$ = 12					; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 49   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp

; 48   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 50   : 		this->_Adopt(_Pstring);
; 51   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$dead$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 976  : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 977  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN10@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN18@allocate:
$LN10@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 976  : 		return (_Mybase::allocate(_Count));

	mov	eax, ecx

; 977  : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 977  : 		}

	pop	ebp
	ret	4
$LN17@allocate:
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$dead$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$dead$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	DWORD PTR __Count$[ebp], 4096		; 00001000H

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	eax, DWORD PTR __Ptr$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	jb	SHORT $LN5@deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	je	SHORT $LN6@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN14@deallocate:
$LN6@deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN7@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN15@deallocate:
$LN7@deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN8@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN16@deallocate:
$LN8@deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN9@deallocate
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN17@deallocate:
$LN9@deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN5@deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 721  : 		}

	pop	ebp
	ret	8
$LN13@deallocate:
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z
_TEXT	SEGMENT
?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z PROC ; std::pointer_traits<std::_Container_proxy *>::pointer_to, COMDAT
; __Val$ = ecx

; 280  : 		return (_STD addressof(_Val));

	mov	eax, ecx

; 281  : 		}

	ret	0
?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z ENDP ; std::pointer_traits<std::_Container_proxy *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Count$dead$ = 8					; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$dead$ = ecx

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$dead$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 132  : 	::operator delete(_Ptr);

	push	DWORD PTR __Ptr$[ebp]
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));
; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 107374182				; 06666666H

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAIABV?$allocator@VErrorInfo@Reader@Json@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QBEABV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAEAAV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z
_TEXT	SEGMENT
__Pdeque$ = 8						; size = 4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Setcont, COMDAT
; _this$ = ecx

; 518  : 		{	// set container pointer

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 150  : 		if (_Parent == 0)

	mov	eax, DWORD PTR __Pdeque$[ebp]
	test	eax, eax
	je	SHORT $LN5@Setcont

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN5@Setcont:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 520  : 		}

	pop	ebp
	ret	4
?_Setcont@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEXPBV?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Setcont
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-, COMDAT
; _this$ = ecx

; 453  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 454  : 		_Compat(_Right);
; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [ecx+8]
	sub	eax, edx

; 456  : 			? this->_Myoff - _Right._Myoff
; 457  : 			: -(difference_type)(_Right._Myoff - this->_Myoff));
; 458  : 		}

	pop	ebp
	ret	4
??G?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=, COMDAT
; _this$ = ecx

; 625  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp

; 626  : 		this->_Myoff += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	add	DWORD PTR [ecx+8], eax

; 627  : 		return (*this);

	mov	eax, ecx

; 628  : 		}

	pop	ebp
	ret	4
??Y?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z PROC ; std::allocator<Json::Value * *>::allocate, COMDAT
; _this$dead$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	jbe	SHORT $LN5@allocate

; 56   : 		_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN5@allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN16@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	pop	ebp
	ret	4
$LN14@allocate:
?allocate@?$allocator@PAPAVValue@Json@@@std@@QAEPAPAPAVValue@Json@@I@Z ENDP ; std::allocator<Json::Value * *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::max_size, COMDAT
; _this$dead$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z PROC	; std::allocator<Json::Value *>::allocator<Json::Value *>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@PAVValue@Json@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<Json::Value *>::allocator<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	or	eax, -1

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SAIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$dead$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate

; 52   : 		return (_Ptr);

	xor	ecx, ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN8@allocate

; 67   : 			_Xbad_alloc();	// report no memory

	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
$LN15@allocate:
$LN8@allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ecx, DWORD PTR [eax+35]
	and	ecx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ecx-4], eax

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	mov	eax, ecx

; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	ecx, eax

; 726  : 		}

	pop	ebp
	ret	4
$LN14@allocate:
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 514  : 		}

	ret	4
?_Compat@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z
_TEXT	SEGMENT
?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::max_size, COMDAT
; __Al$dead$ = ecx

; 869  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 870  : 		}

	ret	0
?max_size@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAIABV?$allocator@PAVValue@Json@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ PROC ; std::allocator<Json::Reader::ErrorInfo>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 107374182				; 06666666H

; 750  : 		}

	ret	0
?max_size@?$allocator@VErrorInfo@Reader@Json@@@std@@QBEIXZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 750  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ PROC	; std::allocator<Json::Value *>::max_size, COMDAT
; _this$dead$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@PAVValue@Json@@@std@@QBEIXZ ENDP	; std::allocator<Json::Value *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
__Delim$dead$ = 8					; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 151  : 	return (getline(_STD move(_Istr), _Str, _Delim));

	jmp	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0PBDX@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$dead$ = 16						; size = 4
??$?0PBDX@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0ABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char const *,void>, COMDAT
; _this$ = ecx

; 867  : 		{	// construct from [_First, _Last) with optional allocator

	push	ebp
	mov	ebp, esp

; 905  : 		if (_First != _Last)

	mov	eax, DWORD PTR __Last$[ebp]
	push	esi

; 867  : 		{	// construct from [_First, _Last) with optional allocator

	mov	esi, ecx

; 905  : 		if (_First != _Last)

	mov	ecx, DWORD PTR __First$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 905  : 		if (_First != _Last)

	cmp	ecx, eax
	je	SHORT $LN120@allocator

; 906  : 			assign(_First, _Last - _First);

	sub	eax, ecx
	push	eax
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN120@allocator:

; 868  : 		_DEBUG_RANGE(_First, _Last);
; 869  : 		_Tidy();
; 870  : 		_Construct(_Unchecked(_First), _Unchecked(_Last), _Iter_cat_t<_Iter>());
; 871  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	12					; 0000000cH
??$?0PBDX@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD0ABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> ><char const *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = -20					; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$dead$ = edx

; 2327 : 	{	// return NTCS + string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR ___$ReturnUdt$[ebp], esi
	mov	DWORD PTR $T1[ebp], 0

; 496  : 		_Mysize(0),

	mov	DWORD PTR [esi+16], 0

; 497  : 		_Myres(0)

	mov	DWORD PTR [esi+20], 0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN105@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN106@operator
$LN105@operator:
	mov	eax, esi
$LN106@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2332 : 	return (_Ans);

	mov	ebx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	mov	edi, DWORD PTR [esi+16]
	mov	DWORD PTR $T1[ebp], 1

; 2328 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 2329 : 	_Ans.reserve(_Traits::length(_Left) + _Right.size());

	mov	eax, DWORD PTR [ebx+16]
	add	eax, 2

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	cmp	edi, eax
	ja	SHORT $LN182@operator
	cmp	DWORD PTR [esi+20], eax
	je	SHORT $LN182@operator

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	mov	ecx, esi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN182@operator

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN169@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN170@operator
$LN169@operator:
	mov	eax, esi
$LN170@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN182@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02KNHHEEKP@?5?5?$AA@
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	ebx
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2332 : 	return (_Ans);

	mov	eax, esi

; 2333 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN4@operator
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@operator:
	ret	0
__ehhandler$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBDABV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
___$ReturnUdt$ = -4					; size = 4
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 2417 : 	{	// return NTCS + string

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [edx], 0
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2417 : 	{	// return NTCS + string

	mov	edi, ecx
	mov	DWORD PTR $T1[ebp], 0
	mov	DWORD PTR ___$ReturnUdt$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	jne	SHORT $LN9@operator
	xor	esi, esi
	jmp	SHORT $LN10@operator
$LN9@operator:
	mov	esi, edx
	lea	ecx, DWORD PTR [esi+1]
$LL14@operator:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL14@operator
	sub	esi, ecx
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	push	esi
	push	edx
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 2418 : 	return (_STD move(_Right.insert(0, _Left)));

	push	eax
	mov	ecx, edi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, edi
	pop	edi
	pop	esi

; 2419 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z
_TEXT	SEGMENT
$T1 = -8						; size = 4
___$ReturnUdt$ = -4					; size = 4
__Right$ = 8						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; ___$ReturnUdt$ = ecx
; __Left$ = edx

; 2439 : 	{	// return string + NTCS

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edi, DWORD PTR __Right$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2439 : 	{	// return string + NTCS

	mov	ebx, ecx
	mov	DWORD PTR ___$ReturnUdt$[ebp], ebx
	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [edi], 0
	jne	SHORT $LN9@operator
	xor	esi, esi
	jmp	SHORT $LN10@operator
$LN9@operator:
	mov	esi, edi
	lea	ecx, DWORD PTR [esi+1]
$LL14@operator:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL14@operator
	sub	esi, ecx
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	esi
	push	edi
	mov	ecx, edx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2440 : 	return (_STD move(_Left.append(_Right)));

	push	eax
	mov	ecx, ebx
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx

; 2441 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z
_TEXT	SEGMENT
??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z PROC ; std::move<Json::Value * &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAPAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ENDP ; std::move<Json::Value * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@0@AAV10@@Z PROC ; std::move<std::deque<Json::Value *,std::allocator<Json::Value *> > &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@0@AAV10@@Z ENDP ; std::move<std::deque<Json::Value *,std::allocator<Json::Value *> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@PAV123@@Z
_TEXT	SEGMENT
??$_Unfancy@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@PAV123@@Z PROC ; std::_Unfancy<Json::Reader::ErrorInfo>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@VErrorInfo@Reader@Json@@@std@@YAPAVErrorInfo@Reader@Json@@PAV123@@Z ENDP ; std::_Unfancy<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edi, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edi, edi
	je	SHORT $LN13@construct
	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [edi], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	lea	eax, DWORD PTR [esi+12]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+36], eax
$LN13@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z$2:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$emplace_back@$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
??$emplace_back@$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>, COMDAT
; _this$ = ecx

; 1185 : 		{	// insert element at end

	push	esi
	mov	esi, ecx

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+16]
	inc	eax
	cmp	DWORD PTR [esi+8], eax
	ja	SHORT $LN2@emplace_ba
	push	ecx
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@emplace_ba:
	mov	eax, DWORD PTR [esi+8]
	dec	eax
	and	DWORD PTR [esi+12], eax
	mov	ecx, DWORD PTR [esi+16]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [esi+8]

; 1187 : 		_PUSH_BACK_BEGIN;

	add	ecx, DWORD PTR [esi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	eax
	and	ecx, eax

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	push	edi
	lea	edi, DWORD PTR [ecx*4]
	cmp	DWORD PTR [edi+eax], 0
	jne	SHORT $LN3@emplace_ba
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	DWORD PTR [edi+ecx], eax
$LN3@emplace_ba:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [edi+eax]
	pop	edi
	test	eax, eax
	je	SHORT $LN273@emplace_ba
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+32], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+12], 0
$LN273@emplace_ba:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1191 : 		_PUSH_BACK_END;

	inc	DWORD PTR [esi+16]
	pop	esi

; 1192 : 		}

	ret	0
??$emplace_back@$$V@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXXZ ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
??$?9V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z PROC ; std::operator!=<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1026 : 	return (!(_Left == _Right));

	xor	al, al

; 1027 : 	}

	ret	0
??$?9V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 12
??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z PROC ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2371 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2372 : 	_DEPRECATE_UNCHECKED(copy, _Dest);
; 2373 : 	return (_Copy_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	esi, ecx
	mov	edx, esp
	mov	DWORD PTR [edx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [edx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
	test	eax, eax
	je	SHORT $LN41@copy

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN41@copy

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN41@copy:
	mov	eax, DWORD PTR __Dest$[ebp+8]

; 2372 : 	_DEPRECATE_UNCHECKED(copy, _Dest);
; 2373 : 	return (_Copy_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]
	test	eax, eax
	je	SHORT $LN55@copy

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN55@copy

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN55@copy:
	mov	eax, DWORD PTR __Last$[ebp+8]

; 2372 : 	_DEPRECATE_UNCHECKED(copy, _Dest);
; 2373 : 	return (_Copy_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN69@copy

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN69@copy

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN69@copy:
	mov	eax, DWORD PTR __First$[ebp+8]
	mov	DWORD PTR [ecx+8], eax

; 2372 : 	_DEPRECATE_UNCHECKED(copy, _Dest);
; 2373 : 	return (_Copy_no_deprecate(_First, _Last, _Dest));

	mov	ecx, esi
	call	??$_Copy_no_deprecate@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::_Copy_no_deprecate<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H
	mov	eax, esi

; 2374 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ENDP ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0V32@@Z@SAXU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0V32@@Z@SAXU?$integral_constant@_N$00@2@@Z PROC ; `std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >'::`2'::_Unchecked_iterators::_Deprecate, COMDAT

; 2372 : 	_DEPRECATE_UNCHECKED(copy, _Dest);

	ret	0
?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@0V32@@Z@SAXU?$integral_constant@_N$00@2@@Z ENDP ; `std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >'::`2'::_Unchecked_iterators::_Deprecate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z
_TEXT	SEGMENT
$T126 = -72						; size = 12
$T122 = -72						; size = 12
$T71 = -72						; size = 12
$T124 = -60						; size = 12
$T69 = -60						; size = 12
$T125 = -48						; size = 12
$T66 = -48						; size = 12
$T67 = -36						; size = 12
$T63 = -36						; size = 12
$T1 = -36						; size = 12
_this$ = -24						; size = 4
__Oldsize$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
__First$ = 24						; size = 12
__Last$ = 36						; size = 12
??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; _this$ = ecx

; 1580 : 		{	// insert [_First, _Last) at _Where, input iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 1581 : 		size_type _Off = _Where - begin();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	ebx, DWORD PTR __Where$[ebp+8]

; 468  : 		return (this->_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR __First$[ebp+8]
	mov	ecx, DWORD PTR __Last$[ebp+8]

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	eax, DWORD PTR [eax+8]
	sub	ebx, eax

; 1582 : 
; 1583 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1584 : 		if (this->_Mysize() < _Off)
; 1585 : 			_DEBUG_ERROR("deque insert iterator outside range");
; 1586 : 		_DEBUG_RANGE(_First, _Last);
; 1587 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1588 : 
; 1589 : 		size_type _Oldsize = this->_Mysize();

	mov	esi, DWORD PTR [edi+16]
	mov	DWORD PTR __Oldsize$[ebp], esi

; 468  : 		return (this->_Myoff == _Right._Myoff);

	cmp	edx, ecx

; 1590 : 
; 1591 : 		if (_First == _Last)

	je	$LN17@insert

; 1592 : 			;
; 1593 : 		else if (_Off <= this->_Mysize() / 2)

	mov	eax, esi
	shr	eax, 1
	cmp	ebx, eax
	ja	$LN16@insert

; 1594 : 			{	// closer to front, push to front then rotate
; 1595 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LL4@insert:

; 468  : 		return (this->_Myoff == _Right._Myoff);

	cmp	edx, ecx

; 1596 : 			for (; _First != _Last; ++_First)

	je	$LN3@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN78@insert
$LN77@insert:
	mov	eax, DWORD PTR [eax]
$LN78@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [eax+8]

; 1597 : 				push_front(*_First);	// prepend flipped

	mov	eax, DWORD PTR [eax+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, edx

; 1597 : 				push_front(*_First);	// prepend flipped

	push	DWORD PTR [eax+ecx*4]
	mov	ecx, edi
	call	?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front

; 368  : 		++_Myoff;

	mov	edx, DWORD PTR __First$[ebp+8]
	mov	ecx, DWORD PTR __Last$[ebp+8]
	inc	edx
	mov	DWORD PTR __First$[ebp+8], edx
	jmp	SHORT $LL4@insert
__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$0:

; 936  : 		return (_Get_data()._Mysize);

	mov	esi, DWORD PTR _this$[ebp]

; 1598 : 
; 1599 : 			_CATCH_ALL
; 1600 : 			for (; _Oldsize < this->_Mysize(); )

	mov	ebx, DWORD PTR __Oldsize$[ebp]
	cmp	ebx, DWORD PTR [esi+16]
	jae	SHORT $LN6@insert
$LL5@insert:

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [esi+8]

; 1484 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [esi+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, DWORD PTR [esi+12]

; 1484 : 		this->_Getal().destroy(

	mov	edi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+32]
	add	edi, 12					; 0000000cH
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN158@insert

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [edi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN158@insert:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN247@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN247@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1486 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [esi+16], -1
	jne	SHORT $LN91@insert

; 1487 : 			this->_Myoff() = 0;

	mov	DWORD PTR [esi+12], 0

; 1488 : 		else

	jmp	SHORT $LN92@insert
$LN91@insert:

; 1489 : 			++this->_Myoff();

	inc	DWORD PTR [esi+12]
$LN92@insert:

; 1598 : 
; 1599 : 			_CATCH_ALL
; 1600 : 			for (; _Oldsize < this->_Mysize(); )

	cmp	ebx, DWORD PTR [esi+16]
	jb	SHORT $LL5@insert
$LN6@insert:

; 1601 : 				pop_front();	// restore old size, at least
; 1602 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN567@insert:
$LN3@insert:

; 1603 : 			_CATCH_END
; 1604 : 
; 1605 : 			size_type _Num = this->_Mysize() - _Oldsize;

	mov	esi, DWORD PTR [edi+16]

; 1606 : 			_STD reverse(begin(), begin() + _Num);	// flip new stuff in place

	sub	esp, 12					; 0000000cH
	sub	esi, DWORD PTR __Oldsize$[ebp]
	mov	eax, esp
	mov	ecx, edi
	push	esi
	push	eax
	lea	eax, DWORD PTR $T63[ebp]
	push	eax
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	sub	esp, 12					; 0000000cH
	mov	ecx, edi
	push	esp
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	call	??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >

; 1607 : 			_STD rotate(begin(), begin() + _Num, begin() + _Num + _Off);

	add	esp, 12					; 0000000cH
	mov	ecx, edi
	mov	eax, esp
	push	ebx
	push	eax
	push	esi
	lea	eax, DWORD PTR $T66[ebp]
	push	eax
	lea	eax, DWORD PTR $T67[ebp]
	push	eax
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	sub	esp, 12					; 0000000cH
	mov	ecx, edi
	mov	eax, esp
	push	esi
	push	eax
	lea	eax, DWORD PTR $T69[ebp]
	push	eax
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	sub	esp, 12					; 0000000cH
	mov	ecx, edi
	push	esp
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	lea	ecx, DWORD PTR $T71[ebp]

; 1608 : 			}
; 1609 : 		else

	jmp	$LN566@insert
$LN16@insert:

; 1610 : 			{	// closer to back
; 1611 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2
$LL10@insert:

; 468  : 		return (this->_Myoff == _Right._Myoff);

	cmp	edx, ecx

; 1612 : 			for (; _First != _Last; ++_First)

	je	$LN9@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN360@insert
$LN359@insert:
	mov	eax, DWORD PTR [eax]
$LN360@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [eax+8]

; 1613 : 				push_back(*_First);	// append

	mov	eax, DWORD PTR [eax+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, edx

; 1613 : 				push_back(*_First);	// append

	push	DWORD PTR [eax+ecx*4]
	mov	ecx, edi
	call	?push_back@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_back

; 368  : 		++_Myoff;

	mov	edx, DWORD PTR __First$[ebp+8]
	mov	ecx, DWORD PTR __Last$[ebp+8]
	inc	edx
	mov	DWORD PTR __First$[ebp+8], edx
	jmp	SHORT $LL10@insert
__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z$2:

; 936  : 		return (_Get_data()._Mysize);

	mov	edi, DWORD PTR _this$[ebp]

; 1614 : 
; 1615 : 			_CATCH_ALL
; 1616 : 			for (; _Oldsize < this->_Mysize(); )

	mov	ebx, DWORD PTR __Oldsize$[ebp]
	mov	ecx, DWORD PTR [edi+16]
	cmp	ebx, ecx
	jae	SHORT $LN12@insert
$LL11@insert:

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [edi+12]
	dec	eax
	add	ecx, eax

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [edi+8]
	dec	eax
	and	ecx, eax

; 1521 : 		this->_Getal().destroy(

	mov	eax, DWORD PTR [edi+4]
	mov	esi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	add	esi, 12					; 0000000cH
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN439@insert

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN439@insert:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN528@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN528@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [edi+16], -1
	jne	SHORT $LN373@insert

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [edi+12], 0
$LN373@insert:

; 1614 : 
; 1615 : 			_CATCH_ALL
; 1616 : 			for (; _Oldsize < this->_Mysize(); )

	mov	ecx, DWORD PTR [edi+16]
	cmp	ebx, ecx
	jb	SHORT $LL11@insert
$LN12@insert:

; 1617 : 				pop_back();	// restore old size, at least
; 1618 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN568@insert:
$LN9@insert:

; 1619 : 			_CATCH_END
; 1620 : 
; 1621 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());

	sub	esp, 12					; 0000000cH
	mov	ecx, edi
	push	esp
	call	?end@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::end
	sub	esp, 12					; 0000000cH
	mov	ecx, edi
	mov	eax, esp
	push	esi
	push	eax
	lea	eax, DWORD PTR $T122[ebp]
	push	eax
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	sub	esp, 12					; 0000000cH
	mov	ecx, edi
	mov	eax, esp
	push	ebx
	push	eax
	lea	eax, DWORD PTR $T124[ebp]
	push	eax
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	lea	ecx, DWORD PTR $T125[ebp]
$LN566@insert:
	call	??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H
$LN17@insert:

; 1622 : 			}
; 1623 : 		return (begin() + _Off);

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	lea	eax, DWORD PTR $T126[ebp]
	push	ebx
	push	esi
	push	eax
	mov	ecx, edi
	call	?begin@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
	mov	eax, esi

; 1624 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
$LN565@insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@00@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAV?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAV?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAV10@@Z PROC ; std::forward<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAV?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$move@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@X@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@X@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,void>, COMDAT
; _this$ = ecx

; 817  : 		{	// construct allocator from _Al

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN73@ErrorInfo
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN73@ErrorInfo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 818  : 		_Alloc_proxy();
; 819  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@X@?$_Deque_alloc@U?$_Deque_base_types@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > >::_Deque_alloc<std::_Deque_base_types<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> > ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; _this$ = ecx

; 1040 : 		{	// initialize from [_First, _Last), input iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 1041 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	eax, DWORD PTR __First$[ebp+8]
	npad	6
$LL4@Construct:

; 468  : 		return (this->_Myoff == _Right._Myoff);

	cmp	eax, DWORD PTR __Last$[ebp+8]

; 1042 : 
; 1043 : 		for (; _First != _Last; ++_First)

	je	SHORT $LN3@Construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	ecx, DWORD PTR __First$[ebp]
	test	ecx, ecx
	jne	SHORT $LN23@Construct
	xor	edx, edx
	jmp	SHORT $LN24@Construct
$LN23@Construct:
	mov	edx, DWORD PTR [ecx]
$LN24@Construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [edx+8]
	dec	ecx
	and	ecx, eax

; 1044 : 			emplace_back(*_First);

	mov	eax, DWORD PTR [edx+4]
	push	DWORD PTR [eax+ecx*4]
	mov	ecx, esi
	call	??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<Json::Reader::ErrorInfo const &>

; 368  : 		++_Myoff;

	mov	eax, DWORD PTR __First$[ebp+8]
	inc	eax
	mov	DWORD PTR __First$[ebp+8], eax
	jmp	SHORT $LL4@Construct
__catch$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z$0:

; 1045 : 
; 1046 : 		_CATCH_ALL
; 1047 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Tidy

; 1048 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN32@Construct:
$LN3@Construct:

; 1049 : 		_CATCH_END
; 1050 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN31@Construct:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@0@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1026 : 	return (!(_Left == _Right));

	xor	al, al

; 1027 : 	}

	ret	0
??$?9V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT
; _this$ = ecx

; 1202 : 		{	// assign [_First, _Last), input iterators

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edi, DWORD PTR [esi+20]
	cmp	edi, 16					; 00000010H
	jb	SHORT $LN14@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN15@assign
$LN14@assign:
	mov	eax, esi
$LN15@assign:

; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

	mov	edx, DWORD PTR [esi+16]
	add	edx, eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	edi, 16					; 00000010H
	jb	SHORT $LN49@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
$LN49@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 222  : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]

; 211  : 		return (_Ptr - _Right._Ptr);

	sub	edx, ecx

; 222  : 		return (_Ptr == _Right._Ptr);

	mov	ebx, DWORD PTR __Last$[ebp]
	cmp	eax, ebx

; 1585 : 		if (_First2 == _Last2)

	jne	SHORT $LN72@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	edi, 16					; 00000010H
	jb	SHORT $LN94@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 211  : 		return (_Ptr - _Right._Ptr);

	sub	ecx, eax

; 1586 : 			erase(_First - begin(), _Last - _First);

	push	edx
	push	ecx
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1203 : 		return (replace(begin(), end(), _First, _Last));

	mov	eax, esi
	pop	esi
	pop	ebx

; 1204 : 		}

	pop	ebp
	ret	8
$LN94@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi

; 211  : 		return (_Ptr - _Right._Ptr);

	sub	ecx, eax

; 1586 : 			erase(_First - begin(), _Last - _First);

	push	edx
	push	ecx
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1203 : 		return (replace(begin(), end(), _First, _Last));

	mov	eax, esi
	pop	esi
	pop	ebx

; 1204 : 		}

	pop	ebp
	ret	8
$LN72@assign:

; 211  : 		return (_Ptr - _Right._Ptr);

	sub	ebx, eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	edi, 16					; 00000010H
	jb	SHORT $LN146@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN147@assign
$LN146@assign:
	mov	edi, esi
$LN147@assign:

; 1588 : 			replace(_First - begin(), _Last - _First,

	push	ebx
	push	eax

; 211  : 		return (_Ptr - _Right._Ptr);

	sub	ecx, edi

; 1588 : 			replace(_First - begin(), _Last - _First,

	push	edx
	push	ecx
	mov	ecx, esi
	call	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
	pop	edi

; 1203 : 		return (replace(begin(), end(), _First, _Last));

	mov	eax, esi
	pop	esi
	pop	ebx

; 1204 : 		}

	pop	ebp
	ret	8
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 598  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 598  : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@VErrorInfo@Reader@Json@@@std@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??$?0V?$allocator@VErrorInfo@Reader@Json@@@std@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> ><std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@VErrorInfo@Reader@Json@@@std@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> ><std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Pocma@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);
; 1065 : 	}

	ret	0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@ABU10@@Z
_TEXT	SEGMENT
??$_Pocca@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1><>, COMDAT
; _this$ = ecx

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [ecx+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [ecx+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [ecx+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::_Wrap_alloc<std::allocator<Json::Value * *> ><std::_Wrap_alloc<std::allocator<Json::Value *> > &>, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value * *> >::_Wrap_alloc<std::allocator<Json::Value * *> ><std::_Wrap_alloc<std::allocator<Json::Value *> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAV12@@Z
_TEXT	SEGMENT
??$addressof@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAV12@@Z PROC ; std::addressof<Json::Value * *>, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@PAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@AAPAPAV12@@Z ENDP ; std::addressof<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value * *>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAPAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAPAVValue@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@PAVValue@Json@@@std@@YAPAPAVValue@Json@@PAPAV12@@Z
_TEXT	SEGMENT
??$_Unfancy@PAVValue@Json@@@std@@YAPAPAVValue@Json@@PAPAV12@@Z PROC ; std::_Unfancy<Json::Value *>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@PAVValue@Json@@@std@@YAPAPAVValue@Json@@PAPAV12@@Z ENDP ; std::_Unfancy<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value *>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAVValue@Json@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::destroy<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
??$?9V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z PROC ; std::operator!=<std::allocator<Json::Value *>,std::allocator<Json::Value *> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1026 : 	return (!(_Left == _Right));

	xor	al, al

; 1027 : 	}

	ret	0
??$?9V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<Json::Value *>,std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 12
??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z PROC ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2371 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2372 : 	_DEPRECATE_UNCHECKED(copy, _Dest);
; 2373 : 	return (_Copy_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	esi, ecx
	mov	edx, esp
	mov	DWORD PTR [edx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [edx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
	test	eax, eax
	je	SHORT $LN37@copy

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN37@copy

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN37@copy:
	mov	eax, DWORD PTR __Dest$[ebp+8]

; 2372 : 	_DEPRECATE_UNCHECKED(copy, _Dest);
; 2373 : 	return (_Copy_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]
	test	eax, eax
	je	SHORT $LN51@copy

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN51@copy

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN51@copy:
	mov	eax, DWORD PTR __Last$[ebp+8]

; 2372 : 	_DEPRECATE_UNCHECKED(copy, _Dest);
; 2373 : 	return (_Copy_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN65@copy

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN65@copy

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN65@copy:
	mov	eax, DWORD PTR __First$[ebp+8]
	mov	DWORD PTR [ecx+8], eax

; 2372 : 	_DEPRECATE_UNCHECKED(copy, _Dest);
; 2373 : 	return (_Copy_no_deprecate(_First, _Last, _Dest));

	mov	ecx, esi
	call	??$_Copy_no_deprecate@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ; std::_Copy_no_deprecate<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H
	mov	eax, esi

; 2374 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ENDP ; std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0V32@@Z@SAXU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0V32@@Z@SAXU?$integral_constant@_N$00@2@@Z PROC ; `std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >'::`2'::_Unchecked_iterators::_Deprecate, COMDAT

; 2372 : 	_DEPRECATE_UNCHECKED(copy, _Dest);

	ret	0
?_Deprecate@_Unchecked_iterators@?1???$copy@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@0V32@@Z@SAXU?$integral_constant@_N$00@2@@Z ENDP ; `std::copy<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >'::`2'::_Unchecked_iterators::_Deprecate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z
_TEXT	SEGMENT
$T175 = -84						; size = 12
$T171 = -84						; size = 12
$T97 = -84						; size = 12
$T173 = -72						; size = 12
$T95 = -72						; size = 12
$T174 = -60						; size = 12
$T92 = -60						; size = 12
$T93 = -48						; size = 12
$T89 = -48						; size = 12
$T1 = -48						; size = 12
__Val$1$ = -36						; size = 4
__Val$1$ = -36						; size = 4
_this$ = -32						; size = 4
tv1825 = -28						; size = 4
tv1822 = -28						; size = 4
__Off$1$ = -24						; size = 4
__Oldsize$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
__First$ = 24						; size = 12
__Last$ = 36						; size = 12
??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; _this$ = ecx

; 1580 : 		{	// insert [_First, _Last) at _Where, input iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 1581 : 		size_type _Off = _Where - begin();

	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	ebx, DWORD PTR __Where$[ebp+8]

; 468  : 		return (this->_Myoff == _Right._Myoff);

	mov	edi, DWORD PTR __First$[ebp+8]

; 1582 : 
; 1583 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1584 : 		if (this->_Mysize() < _Off)
; 1585 : 			_DEBUG_ERROR("deque insert iterator outside range");
; 1586 : 		_DEBUG_RANGE(_First, _Last);
; 1587 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1588 : 
; 1589 : 		size_type _Oldsize = this->_Mysize();

	mov	ecx, DWORD PTR [esi+16]

; 455  : 		return (_Right._Myoff <= this->_Myoff

	mov	eax, DWORD PTR [eax+8]
	sub	ebx, eax
	mov	DWORD PTR __Off$1$[ebp], ebx

; 1582 : 
; 1583 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1584 : 		if (this->_Mysize() < _Off)
; 1585 : 			_DEBUG_ERROR("deque insert iterator outside range");
; 1586 : 		_DEBUG_RANGE(_First, _Last);
; 1587 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1588 : 
; 1589 : 		size_type _Oldsize = this->_Mysize();

	mov	DWORD PTR __Oldsize$[ebp], ecx

; 468  : 		return (this->_Myoff == _Right._Myoff);

	cmp	edi, DWORD PTR __Last$[ebp+8]

; 1590 : 
; 1591 : 		if (_First == _Last)

	je	$LN17@insert

; 1592 : 			;
; 1593 : 		else if (_Off <= this->_Mysize() / 2)

	mov	eax, ecx
	shr	eax, 1
	cmp	ebx, eax
	ja	$LN16@insert

; 1594 : 			{	// closer to front, push to front then rotate
; 1595 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	npad	7
$LL4@insert:

; 468  : 		return (this->_Myoff == _Right._Myoff);

	cmp	edi, DWORD PTR __Last$[ebp+8]

; 1596 : 			for (; _First != _Last; ++_First)

	je	$LN3@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN77@insert
	xor	ebx, ebx
	jmp	SHORT $LN78@insert
$LN77@insert:
	mov	eax, DWORD PTR __First$[ebp]
	mov	ebx, DWORD PTR [eax]
$LN78@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, edi
	shr	eax, 2
	dec	edx
	and	edx, eax

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	mov	ecx, edi

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [ebx+4]
	and	ecx, 3

; 1459 : 		_PUSH_FRONT_BEGIN;

	test	BYTE PTR [esi+12], 3

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR __Val$1$[ebp], eax

; 1459 : 		_PUSH_FRONT_BEGIN;

	jne	SHORT $LN82@insert
	mov	eax, DWORD PTR [esi+16]
	add	eax, 4
	shr	eax, 2
	cmp	DWORD PTR [esi+8], eax
	ja	SHORT $LN82@insert
	push	ecx
	mov	ecx, esi
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
	mov	edi, DWORD PTR __First$[ebp+8]
$LN82@insert:
	mov	eax, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax*4-1]
	and	DWORD PTR [esi+12], eax
	mov	ebx, DWORD PTR [esi+12]
	jne	SHORT $LN86@insert
	mov	ebx, DWORD PTR [esi+8]
	shl	ebx, 2
$LN86@insert:

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [esi+8]

; 1459 : 		_PUSH_FRONT_BEGIN;

	dec	ebx

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	mov	eax, ebx
	shr	eax, 2
	and	ecx, eax

; 1459 : 		_PUSH_FRONT_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	shl	ecx, 2
	mov	DWORD PTR tv1825[ebp], ecx
	cmp	DWORD PTR [ecx+eax], 0
	jne	SHORT $LN690@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1459 : 		_PUSH_FRONT_BEGIN;

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1459 : 		_PUSH_FRONT_BEGIN;

	mov	edx, DWORD PTR tv1825[ebp]
	mov	DWORD PTR [edx+ecx], eax
	mov	edi, DWORD PTR __First$[ebp+8]
	jmp	SHORT $LN83@insert
__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$0:

; 936  : 		return (_Get_data()._Mysize);

	mov	eax, DWORD PTR _this$[ebp]

; 1597 : 				push_front(*_First);	// prepend flipped
; 1598 : 
; 1599 : 			_CATCH_ALL
; 1600 : 			for (; _Oldsize < this->_Mysize(); )

	mov	ecx, DWORD PTR __Oldsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN6@insert
	npad	7
$LL5@insert:

; 1486 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [eax+16], -1
	jne	SHORT $LN274@insert

; 1487 : 			this->_Myoff() = 0;

	mov	DWORD PTR [eax+12], 0

; 1488 : 		else

	jmp	SHORT $LN275@insert
$LN274@insert:

; 1489 : 			++this->_Myoff();

	inc	DWORD PTR [eax+12]
$LN275@insert:

; 1597 : 				push_front(*_First);	// prepend flipped
; 1598 : 
; 1599 : 			_CATCH_ALL
; 1600 : 			for (; _Oldsize < this->_Mysize(); )

	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LL5@insert
$LN6@insert:

; 1601 : 				pop_front();	// restore old size, at least
; 1602 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN694@insert:
$LN690@insert:
	mov	edx, DWORD PTR tv1825[ebp]
$LN83@insert:

; 1460 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, ebx
	and	ecx, 3
	mov	eax, DWORD PTR [edx+eax]
	lea	ecx, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN238@insert
	mov	eax, DWORD PTR __Val$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	edi, DWORD PTR __First$[ebp+8]
$LN238@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1462 : 		_PUSH_FRONT_END;

	mov	DWORD PTR [esi+12], ebx
	inc	DWORD PTR [esi+16]

; 368  : 		++_Myoff;

	inc	edi
	mov	DWORD PTR __First$[ebp+8], edi
	jmp	$LL4@insert
$LN3@insert:

; 1603 : 			_CATCH_END
; 1604 : 
; 1605 : 			size_type _Num = this->_Mysize() - _Oldsize;

	mov	edi, DWORD PTR [esi+16]

; 1606 : 			_STD reverse(begin(), begin() + _Num);	// flip new stuff in place

	sub	esp, 12					; 0000000cH
	sub	edi, DWORD PTR __Oldsize$[ebp]
	mov	eax, esp
	mov	ecx, esi
	push	edi
	push	eax
	lea	eax, DWORD PTR $T89[ebp]
	push	eax
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	sub	esp, 12					; 0000000cH
	mov	ecx, esi
	push	esp
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	call	??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >

; 1607 : 			_STD rotate(begin(), begin() + _Num, begin() + _Num + _Off);

	mov	ebx, DWORD PTR __Off$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, esi
	push	ebx
	push	eax
	push	edi
	lea	eax, DWORD PTR $T92[ebp]
	push	eax
	lea	eax, DWORD PTR $T93[ebp]
	push	eax
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	sub	esp, 12					; 0000000cH
	mov	ecx, esi
	mov	eax, esp
	push	edi
	push	eax
	lea	eax, DWORD PTR $T95[ebp]
	push	eax
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	sub	esp, 12					; 0000000cH
	mov	ecx, esi
	push	esp
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	lea	ecx, DWORD PTR $T97[ebp]

; 1608 : 			}
; 1609 : 		else

	jmp	$LN693@insert
$LN16@insert:

; 1610 : 			{	// closer to back
; 1611 : 			_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 2
	npad	8
$LL10@insert:

; 468  : 		return (this->_Myoff == _Right._Myoff);

	cmp	edi, DWORD PTR __Last$[ebp+8]

; 1612 : 			for (; _First != _Last; ++_First)

	je	$LN9@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN428@insert
	xor	ebx, ebx
	jmp	SHORT $LN429@insert
$LN428@insert:
	mov	eax, DWORD PTR __First$[ebp]
	mov	ebx, DWORD PTR [eax]
$LN429@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, edi
	shr	eax, 2
	dec	edx
	and	edx, eax

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	mov	ecx, edi

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [ebx+4]
	and	ecx, 3
	mov	eax, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR [esi+16]

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	DWORD PTR __Val$1$[ebp], eax

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+12]
	add	eax, ecx
	test	al, 3
	jne	SHORT $LN433@insert
	lea	eax, DWORD PTR [ecx+4]
	shr	eax, 2
	cmp	DWORD PTR [esi+8], eax
	ja	SHORT $LN433@insert
	push	ecx
	mov	ecx, esi
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
	mov	edi, DWORD PTR __First$[ebp+8]
$LN433@insert:
	mov	eax, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax*4-1]
	and	DWORD PTR [esi+12], eax
	mov	ebx, DWORD PTR [esi+16]
	add	ebx, DWORD PTR [esi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [esi+8]
	mov	ecx, ebx
	shr	ecx, 2
	dec	eax
	and	ecx, eax

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	shl	ecx, 2
	mov	DWORD PTR tv1822[ebp], ecx
	cmp	DWORD PTR [ecx+eax], 0
	jne	SHORT $LN434@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	mov	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR tv1822[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	DWORD PTR [eax+ecx], edx
	mov	ecx, eax
	mov	edi, DWORD PTR __First$[ebp+8]
$LN434@insert:

; 1497 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [esi+4]
	and	ebx, 3
	mov	eax, DWORD PTR [ecx+eax]
	lea	ecx, DWORD PTR [eax+ebx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN587@insert
	mov	eax, DWORD PTR __Val$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	edi, DWORD PTR __First$[ebp+8]
$LN587@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1499 : 		_PUSH_BACK_END;

	inc	DWORD PTR [esi+16]

; 368  : 		++_Myoff;

	inc	edi
	mov	DWORD PTR __First$[ebp+8], edi
	jmp	$LL10@insert
__catch$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z$2:

; 936  : 		return (_Get_data()._Mysize);

	mov	eax, DWORD PTR _this$[ebp]

; 1613 : 				push_back(*_First);	// append
; 1614 : 
; 1615 : 			_CATCH_ALL
; 1616 : 			for (; _Oldsize < this->_Mysize(); )

	mov	ecx, DWORD PTR __Oldsize$[ebp]
	cmp	ecx, DWORD PTR [eax+16]
	jae	SHORT $LN12@insert
	npad	2
$LL11@insert:

; 1523 : 		if (--this->_Mysize() == 0)

	add	DWORD PTR [eax+16], -1
	jne	SHORT $LN613@insert

; 1524 : 			this->_Myoff() = 0;

	mov	DWORD PTR [eax+12], 0
$LN613@insert:

; 1613 : 				push_back(*_First);	// append
; 1614 : 
; 1615 : 			_CATCH_ALL
; 1616 : 			for (; _Oldsize < this->_Mysize(); )

	cmp	ecx, DWORD PTR [eax+16]
	jb	SHORT $LL11@insert
$LN12@insert:

; 1617 : 				pop_back();	// restore old size, at least
; 1618 : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN695@insert:
$LN9@insert:

; 1619 : 			_CATCH_END
; 1620 : 
; 1621 : 			_STD rotate(begin() + _Off, begin() + _Oldsize, end());

	sub	esp, 12					; 0000000cH
	mov	ecx, esi
	push	esp
	call	?end@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::end
	sub	esp, 12					; 0000000cH
	mov	ecx, esi
	mov	eax, esp
	push	DWORD PTR __Oldsize$[ebp]
	push	eax
	lea	eax, DWORD PTR $T171[ebp]
	push	eax
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	ebx, DWORD PTR __Off$1$[ebp]
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	ecx, esi
	push	ebx
	push	eax
	lea	eax, DWORD PTR $T173[ebp]
	push	eax
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	lea	ecx, DWORD PTR $T174[ebp]
$LN693@insert:
	call	??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H
$LN17@insert:

; 1622 : 			}
; 1623 : 		return (begin() + _Off);

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	lea	eax, DWORD PTR $T175[ebp]
	push	ebx
	push	edi
	push	eax
	mov	ecx, esi
	call	?begin@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::begin
	mov	ecx, eax
	call	??H?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
	mov	eax, edi

; 1624 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	40					; 00000028H
$LN692@insert:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-88]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$insert@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAE?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@00@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::insert<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z
_TEXT	SEGMENT
??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z PROC ; std::forward<Json::Value *>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@PAVValue@Json@@@std@@YA$$QAPAVValue@Json@@AAPAV12@@Z ENDP ; std::forward<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PAVValue@Json@@PAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@0@AAV10@@Z PROC ; std::forward<std::deque<Json::Value *,std::allocator<Json::Value *> > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAV?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::deque<Json::Value *,std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$move@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<Json::Value *> > &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<Json::Value *> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@X@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@X@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z PROC ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > ><std::_Wrap_alloc<std::allocator<Json::Value *> >,void>, COMDAT
; _this$ = ecx

; 817  : 		{	// construct allocator from _Al

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [esi+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [esi+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [esi+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 844  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	eax, eax
	je	SHORT $LN73@Value
	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
$LN73@Value:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 846  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], esi

; 818  : 		_Alloc_proxy();
; 819  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@X@?$_Deque_alloc@U?$_Deque_base_types@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ENDP ; std::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > >::_Deque_alloc<std::_Deque_base_types<Json::Value *,std::allocator<Json::Value *> > ><std::_Wrap_alloc<std::allocator<Json::Value *> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
_<_Val_0>$1$ = -28					; size = 4
_this$ = -24						; size = 4
tv641 = -20						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; _this$ = ecx

; 1040 : 		{	// initialize from [_First, _Last), input iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 1041 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0
	mov	edi, DWORD PTR __First$[ebp+8]
	npad	6
$LL4@Construct:

; 468  : 		return (this->_Myoff == _Right._Myoff);

	cmp	edi, DWORD PTR __Last$[ebp+8]

; 1042 : 
; 1043 : 		for (; _First != _Last; ++_First)

	je	$LN3@Construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	cmp	DWORD PTR __First$[ebp], 0
	jne	SHORT $LN23@Construct
	xor	ebx, ebx
	jmp	SHORT $LN24@Construct
$LN23@Construct:
	mov	eax, DWORD PTR __First$[ebp]
	mov	ebx, DWORD PTR [eax]
$LN24@Construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ebx+8]
	mov	eax, edi
	shr	eax, 2
	dec	edx
	and	edx, eax

; 342  : 		size_type _Off = _Myoff % _DEQUESIZ;

	mov	ecx, edi

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [ebx+4]
	and	ecx, 3
	mov	eax, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [eax+ecx*4]

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR [esi+16]

; 343  : 		return (_Mycont->_Map[_Block][_Off]);

	mov	DWORD PTR _<_Val_0>$1$[ebp], eax

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+12]
	add	eax, ecx
	test	al, 3
	jne	SHORT $LN28@Construct
	lea	eax, DWORD PTR [ecx+4]
	shr	eax, 2
	cmp	DWORD PTR [esi+8], eax
	ja	SHORT $LN28@Construct
	push	ecx
	mov	ecx, esi
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
	mov	edi, DWORD PTR __First$[ebp+8]
$LN28@Construct:
	mov	eax, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax*4-1]
	and	DWORD PTR [esi+12], eax
	mov	ebx, DWORD PTR [esi+16]
	add	ebx, DWORD PTR [esi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, ebx
	dec	ecx
	shr	eax, 2
	and	ecx, eax

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	shl	ecx, 2
	mov	DWORD PTR tv641[ebp], ecx
	cmp	DWORD PTR [ecx+eax], 0
	jne	SHORT $LN29@Construct
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	mov	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR tv641[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	DWORD PTR [eax+ecx], edx
	mov	ecx, eax
	mov	edi, DWORD PTR __First$[ebp+8]
$LN29@Construct:

; 1188 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [esi+4]
	and	ebx, 3
	mov	eax, DWORD PTR [ecx+eax]
	lea	ecx, DWORD PTR [eax+ebx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN185@Construct
	mov	eax, DWORD PTR _<_Val_0>$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
	mov	edi, DWORD PTR __First$[ebp+8]
$LN185@Construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1191 : 		_PUSH_BACK_END;

	inc	DWORD PTR [esi+16]

; 368  : 		++_Myoff;

	inc	edi
	mov	DWORD PTR __First$[ebp+8], edi
	jmp	$LL4@Construct
__catch$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z$0:

; 1044 : 			emplace_back(*_First);
; 1045 : 
; 1046 : 		_CATCH_ALL
; 1047 : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXXZ ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Tidy

; 1048 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN207@Construct:
$LN3@Construct:

; 1049 : 		_CATCH_END
; 1050 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN206@Construct:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Construct@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXV?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@0@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Construct<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo *> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAV123@@Z
_TEXT	SEGMENT
??$addressof@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAV123@@Z PROC ; std::addressof<Json::Reader::ErrorInfo *>, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@PAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@AAPAV123@@Z ENDP ; std::addressof<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAVErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 265  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,
; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	ret	0
??$_Uninitialized_default_fill_n@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::Reader::ErrorInfo * *,unsigned int,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo * *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T6 = -8						; size = 1
$T7 = -4						; size = 1
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 12
??$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2704 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]

; 2705 : 	_DEPRECATE_UNCHECKED(move_backward, _Dest);
; 2706 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2707 : 	return (_Move_backward1(_Unchecked(_First), _Unchecked(_Last),

	mov	BYTE PTR $T6[esp+12], 0
	mov	BYTE PTR $T7[esp+12], 0
	push	esi
	mov	esi, ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN99@move_backw

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN99@move_backw

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN99@move_backw
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN46@move_backw
$LN99@move_backw:
	xor	eax, eax
$LN46@move_backw:

; 2705 : 	_DEPRECATE_UNCHECKED(move_backward, _Dest);
; 2706 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2707 : 	return (_Move_backward1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __Last$[ebp+8]
	push	eax

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN100@move_backw

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN100@move_backw

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN100@move_backw
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN74@move_backw
$LN100@move_backw:
	xor	eax, eax
$LN74@move_backw:

; 2705 : 	_DEPRECATE_UNCHECKED(move_backward, _Dest);
; 2706 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2707 : 	return (_Move_backward1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __First$[ebp+8]
	push	eax
	push	DWORD PTR $T6[esp+32]
	push	DWORD PTR $T7[esp+36]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
	test	eax, eax
	je	SHORT $LN93@move_backw

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN93@move_backw

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN93@move_backw:
	mov	eax, DWORD PTR __Dest$[ebp+8]
	mov	DWORD PTR [ecx+8], eax

; 2705 : 	_DEPRECATE_UNCHECKED(move_backward, _Dest);
; 2706 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2707 : 	return (_Move_backward1(_Unchecked(_First), _Unchecked(_Last),

	mov	ecx, esi
	call	??$_Move_backward1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Move_backward1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H
	mov	eax, esi

; 2708 : 		_Dest, _Iter_cat_t<_BidIt1>(), _Iter_cat_t<_BidIt2>()));
; 2709 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Deprecate@_Unchecked_iterators@?1???$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Deprecate@_Unchecked_iterators@?1???$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z PROC ; `std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >'::`2'::_Unchecked_iterators::_Deprecate, COMDAT

; 2705 : 	_DEPRECATE_UNCHECKED(move_backward, _Dest);

	ret	0
?_Deprecate@_Unchecked_iterators@?1???$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z ENDP ; `std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >'::`2'::_Unchecked_iterators::_Deprecate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 12
??$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2635 : 	{	// move [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2636 : 	_DEPRECATE_UNCHECKED(move, _Dest);
; 2637 : 	return (_Move_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	esi, ecx
	mov	edx, esp
	mov	DWORD PTR [edx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [edx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
	test	eax, eax
	je	SHORT $LN37@move

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN37@move

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN37@move:
	mov	eax, DWORD PTR __Dest$[ebp+8]

; 2636 : 	_DEPRECATE_UNCHECKED(move, _Dest);
; 2637 : 	return (_Move_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]
	test	eax, eax
	je	SHORT $LN53@move

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN53@move

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN53@move:
	mov	eax, DWORD PTR __Last$[ebp+8]

; 2636 : 	_DEPRECATE_UNCHECKED(move, _Dest);
; 2637 : 	return (_Move_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN69@move

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN69@move

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN69@move:
	mov	eax, DWORD PTR __First$[ebp+8]
	mov	DWORD PTR [ecx+8], eax

; 2636 : 	_DEPRECATE_UNCHECKED(move, _Dest);
; 2637 : 	return (_Move_no_deprecate(_First, _Last, _Dest));

	mov	ecx, esi
	call	??$_Move_no_deprecate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_no_deprecate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H
	mov	eax, esi

; 2638 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Deprecate@_Unchecked_iterators@?1???$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Deprecate@_Unchecked_iterators@?1???$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z PROC ; `std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >'::`2'::_Unchecked_iterators::_Deprecate, COMDAT

; 2636 : 	_DEPRECATE_UNCHECKED(move, _Dest);

	ret	0
?_Deprecate@_Unchecked_iterators@?1???$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z ENDP ; `std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >'::`2'::_Unchecked_iterators::_Deprecate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>, COMDAT
; _this$dead$ = ecx

; 1002 : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN20@destroy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi+12]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN20@destroy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+32], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+32], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+28], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN108@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+12]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	pop	ebp
	ret	4
$LN108@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+12], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	pop	ebp
	ret	4
??$destroy@VErrorInfo@Reader@Json@@@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);
; 1065 : 	}

	ret	0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z
_TEXT	SEGMENT
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YAPAPADAAPAD@Z
_TEXT	SEGMENT
??$addressof@PAD@std@@YAPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@PAD@std@@YAPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPADPAD@Z
_TEXT	SEGMENT
??$_Unfancy@D@std@@YAPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@D@std@@YAPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT
; _this$dead$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT
; __Ptr$ = ecx

; 740  : 	return (_Ptr);

	mov	eax, ecx

; 741  : 	}

	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[ebp]
	test	edx, edx
	je	SHORT $LN13@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@PAVValue@Json@@@std@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??$?0V?$allocator@PAVValue@Json@@@std@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> ><std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@PAVValue@Json@@@std@@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> ><std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Json::Value *> > &>, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Json::Value *> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Pocma@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Value *> > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);
; 1065 : 	}

	ret	0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@ABU10@@Z
_TEXT	SEGMENT
??$_Pocca@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Value *> > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1><>, COMDAT
; _this$ = ecx

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [ecx+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [ecx+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [ecx+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 265  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,std::allocator<Json::Value * *> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 480  : 	typedef _Iter_value_t<_FwdIt> _Ty;
; 481  : 	_Uninitialized_default_fill_n1(_First, _Count, _Al,
; 482  : 		typename conjunction<
; 483  : 			is_pointer<_FwdIt>,
; 484  : 			is_scalar<_Ty>,
; 485  : 			negation<is_volatile<_Ty>>,
; 486  : 			negation<is_member_pointer<_Ty>>,
; 487  : 			_Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>::type());
; 488  : 	}

	ret	0
??$_Uninitialized_default_fill_n@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_default_fill_n<Json::Value * * *,unsigned int,std::allocator<Json::Value * *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Json::Value * *>,Json::Value * * *>, COMDAT
; __First$dead$ = ecx
; __Last$dead$ = edx

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	0
??$_Destroy_range@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Json::Value * *>,Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T6 = -8						; size = 1
$T7 = -4						; size = 1
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 12
??$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2704 : 	{	// move [_First, _Last) backwards to [..., _Dest)

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]

; 2705 : 	_DEPRECATE_UNCHECKED(move_backward, _Dest);
; 2706 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2707 : 	return (_Move_backward1(_Unchecked(_First), _Unchecked(_Last),

	mov	BYTE PTR $T6[esp+12], 0
	mov	BYTE PTR $T7[esp+12], 0
	push	esi
	mov	esi, ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN99@move_backw

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN99@move_backw

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN99@move_backw
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN46@move_backw
$LN99@move_backw:
	xor	eax, eax
$LN46@move_backw:

; 2705 : 	_DEPRECATE_UNCHECKED(move_backward, _Dest);
; 2706 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2707 : 	return (_Move_backward1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __Last$[ebp+8]
	push	eax

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN100@move_backw

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN100@move_backw

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN100@move_backw
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN74@move_backw
$LN100@move_backw:
	xor	eax, eax
$LN74@move_backw:

; 2705 : 	_DEPRECATE_UNCHECKED(move_backward, _Dest);
; 2706 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2707 : 	return (_Move_backward1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __First$[ebp+8]
	push	eax
	push	DWORD PTR $T6[esp+32]
	push	DWORD PTR $T7[esp+36]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
	test	eax, eax
	je	SHORT $LN93@move_backw

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN93@move_backw

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN93@move_backw:
	mov	eax, DWORD PTR __Dest$[ebp+8]
	mov	DWORD PTR [ecx+8], eax

; 2705 : 	_DEPRECATE_UNCHECKED(move_backward, _Dest);
; 2706 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2707 : 	return (_Move_backward1(_Unchecked(_First), _Unchecked(_Last),

	mov	ecx, esi
	call	??$_Move_backward1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Move_backward1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H
	mov	eax, esi

; 2708 : 		_Dest, _Iter_cat_t<_BidIt1>(), _Iter_cat_t<_BidIt2>()));
; 2709 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Deprecate@_Unchecked_iterators@?1???$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Deprecate@_Unchecked_iterators@?1???$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z PROC ; `std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >'::`2'::_Unchecked_iterators::_Deprecate, COMDAT

; 2705 : 	_DEPRECATE_UNCHECKED(move_backward, _Dest);

	ret	0
?_Deprecate@_Unchecked_iterators@?1???$move_backward@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z ENDP ; `std::move_backward<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >'::`2'::_Unchecked_iterators::_Deprecate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 12
??$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2635 : 	{	// move [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 2636 : 	_DEPRECATE_UNCHECKED(move, _Dest);
; 2637 : 	return (_Move_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	esi, ecx
	mov	edx, esp
	mov	DWORD PTR [edx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [edx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
	test	eax, eax
	je	SHORT $LN37@move

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN37@move

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN37@move:
	mov	eax, DWORD PTR __Dest$[ebp+8]

; 2636 : 	_DEPRECATE_UNCHECKED(move, _Dest);
; 2637 : 	return (_Move_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]
	test	eax, eax
	je	SHORT $LN53@move

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN53@move

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN53@move:
	mov	eax, DWORD PTR __Last$[ebp+8]

; 2636 : 	_DEPRECATE_UNCHECKED(move, _Dest);
; 2637 : 	return (_Move_no_deprecate(_First, _Last, _Dest));

	sub	esp, 12					; 0000000cH
	mov	DWORD PTR [ecx+8], eax
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN69@move

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN69@move

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN69@move:
	mov	eax, DWORD PTR __First$[ebp+8]
	mov	DWORD PTR [ecx+8], eax

; 2636 : 	_DEPRECATE_UNCHECKED(move, _Dest);
; 2637 : 	return (_Move_no_deprecate(_First, _Last, _Dest));

	mov	ecx, esi
	call	??$_Move_no_deprecate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ; std::_Move_no_deprecate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H
	mov	eax, esi

; 2638 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Deprecate@_Unchecked_iterators@?1???$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Deprecate@_Unchecked_iterators@?1???$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z PROC ; `std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >'::`2'::_Unchecked_iterators::_Deprecate, COMDAT

; 2636 : 	_DEPRECATE_UNCHECKED(move, _Dest);

	ret	0
?_Deprecate@_Unchecked_iterators@?1???$move@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@V32@00@Z@SAXU?$integral_constant@_N$00@2@@Z ENDP ; `std::move<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >'::`2'::_Unchecked_iterators::_Deprecate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPADAAD@Z
_TEXT	SEGMENT
??$addressof@D@std@@YAPADAAD@Z PROC			; std::addressof<char>, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@D@std@@YAPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 764  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=, COMDAT
; _this$ = ecx

; 472  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, DWORD PTR [eax+8]
	setne	al

; 473  : 		return (!(*this == _Right));
; 474  : 		}

	pop	ebp
	ret	4
??9?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==, COMDAT
; _this$ = ecx

; 466  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx+8]
	cmp	ecx, DWORD PTR [eax+8]
	sete	al

; 467  : 		_Compat(_Right);
; 468  : 		return (this->_Myoff == _Right._Myoff);
; 469  : 		}

	pop	ebp
	ret	4
??8?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++, COMDAT
; _this$ = ecx

; 353  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 354  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 355  : 		if (_Mycont == 0
; 356  : 			|| _Mycont->_Myoff + _Mycont->_Mysize <= this->_Myoff)
; 357  : 		{	// report error
; 358  : 		_DEBUG_ERROR("deque iterator not incrementable");
; 359  : 		_SCL_SECURE_OUT_OF_RANGE;
; 360  : 		}
; 361  : 
; 362  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 363  : 		const auto _Mycont = static_cast<const _Mydeque *>(this->_Getcont());
; 364  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 365  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Myoff < _Mycont->_Myoff + _Mycont->_Mysize);
; 366  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 367  : 
; 368  : 		++_Myoff;

	inc	DWORD PTR [ecx+8]

; 369  : 		return (*this);

	mov	eax, ecx

; 370  : 		}

	ret	0
??E?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Deque_val<std::_Deque_simple_types<Json::Value *> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 764  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	ret	0
??0?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Deque_val<std::_Deque_simple_types<Json::Value *> >::_Deque_val<std::_Deque_simple_types<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back, COMDAT
; _this$ = ecx

; 1494 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+16]
	add	eax, ecx
	test	al, 3
	jne	SHORT $LN2@push_back
	lea	eax, DWORD PTR [ecx+4]
	shr	eax, 2
	cmp	DWORD PTR [esi+8], eax
	ja	SHORT $LN2@push_back
	push	ecx
	mov	ecx, esi
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN2@push_back:
	mov	eax, DWORD PTR [esi+8]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [eax*4-1]
	and	DWORD PTR [esi+12], eax
	mov	edi, DWORD PTR [esi+16]
	add	edi, DWORD PTR [esi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, edi
	shr	eax, 2
	dec	ecx
	and	ecx, eax

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	lea	ebx, DWORD PTR [ecx*4]
	cmp	DWORD PTR [ebx+eax], 0
	jne	SHORT $LN3@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1496 : 		_PUSH_BACK_BEGIN;

	mov	DWORD PTR [ebx+ecx], eax
$LN3@push_back:

; 1497 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [esi+4]
	and	edi, 3
	mov	eax, DWORD PTR [ebx+eax]
	lea	ecx, DWORD PTR [eax+edi*4]
	pop	edi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN172@push_back
	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN172@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1499 : 		_PUSH_BACK_END;

	inc	DWORD PTR [esi+16]
	pop	esi

; 1500 : 		}

	pop	ebp
	ret	4
?push_back@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_front, COMDAT
; _this$ = ecx

; 1457 : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1459 : 		_PUSH_FRONT_BEGIN;

	test	BYTE PTR [esi+12], 3
	jne	SHORT $LN2@push_front
	mov	eax, DWORD PTR [esi+16]
	add	eax, 4
	shr	eax, 2
	cmp	DWORD PTR [esi+8], eax
	ja	SHORT $LN2@push_front
	push	ecx
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN2@push_front:
	mov	eax, DWORD PTR [esi+8]
	lea	eax, DWORD PTR [eax*4-1]
	and	DWORD PTR [esi+12], eax
	mov	edi, DWORD PTR [esi+12]
	jne	SHORT $LN6@push_front
	mov	edi, DWORD PTR [esi+8]
	shl	edi, 2
$LN6@push_front:

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [esi+8]

; 1459 : 		_PUSH_FRONT_BEGIN;

	dec	edi

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, edi
	dec	ecx
	shr	eax, 2
	and	ecx, eax

; 1459 : 		_PUSH_FRONT_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	push	ebx
	lea	ebx, DWORD PTR [ecx*4]
	cmp	DWORD PTR [ebx+eax], 0
	jne	SHORT $LN3@push_front
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1459 : 		_PUSH_FRONT_BEGIN;

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1459 : 		_PUSH_FRONT_BEGIN;

	mov	DWORD PTR [ebx+ecx], eax
$LN3@push_front:

; 1460 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, edi
	and	ecx, 3
	mov	eax, DWORD PTR [ebx+eax]
	pop	ebx
	lea	ecx, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN158@push_front
	mov	eax, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN158@push_front:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1462 : 		_PUSH_FRONT_END;

	mov	DWORD PTR [esi+12], edi
	inc	DWORD PTR [esi+16]
	pop	edi
	pop	esi

; 1463 : 		}

	pop	ebp
	ret	4
?push_front@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::push_front
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
$T45 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front, COMDAT
; _this$ = ecx

; 1457 : 		{	// insert element at beginning

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 1459 : 		_PUSH_FRONT_BEGIN;

	mov	eax, DWORD PTR [edi+16]
	inc	eax
	cmp	DWORD PTR [edi+8], eax
	ja	SHORT $LN2@push_front
	push	ecx
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@push_front:
	mov	eax, DWORD PTR [edi+8]
	dec	eax
	and	DWORD PTR [edi+12], eax
	mov	ebx, DWORD PTR [edi+12]
	jne	SHORT $LN6@push_front
	mov	ebx, DWORD PTR [edi+8]
$LN6@push_front:

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [edi+8]

; 1459 : 		_PUSH_FRONT_BEGIN;

	dec	ebx

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	eax
	and	eax, ebx

; 1459 : 		_PUSH_FRONT_BEGIN;

	lea	esi, DWORD PTR [eax*4]
	mov	eax, DWORD PTR [edi+4]
	cmp	DWORD PTR [esi+eax], 0
	jne	SHORT $LN3@push_front
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1459 : 		_PUSH_FRONT_BEGIN;

	mov	ecx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1459 : 		_PUSH_FRONT_BEGIN;

	mov	DWORD PTR [esi+ecx], eax
$LN3@push_front:

; 1460 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [esi+eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR $T45[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN158@push_front
	mov	esi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [ecx], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx+8], eax
	add	ecx, 12					; 0000000cH
	lea	eax, DWORD PTR [esi+12]
	push	eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	ecx, DWORD PTR $T45[ebp]
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [ecx+36], eax
$LN158@push_front:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1462 : 		_PUSH_FRONT_END;

	mov	DWORD PTR [edi+12], ebx
	inc	DWORD PTR [edi+16]

; 1463 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z$41:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_front@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::push_front
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 499  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

	push	ebp
	mov	ebp, esp

; 222  : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First2$[ebp]
	mov	edx, DWORD PTR __Last2$[ebp]
	push	esi

; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

	mov	esi, ecx

; 222  : 		return (_Ptr == _Right._Ptr);

	cmp	eax, edx

; 1585 : 		if (_First2 == _Last2)

	jne	SHORT $LN2@replace

; 211  : 		return (_Ptr - _Right._Ptr);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	sub	ecx, eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN24@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 211  : 		return (_Ptr - _Right._Ptr);

	sub	eax, edx

; 1586 : 			erase(_First - begin(), _Last - _First);

	push	ecx
	push	eax
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1591 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN24@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi

; 1586 : 			erase(_First - begin(), _Last - _First);

	push	ecx

; 211  : 		return (_Ptr - _Right._Ptr);

	sub	eax, edx

; 1586 : 			erase(_First - begin(), _Last - _First);

	mov	ecx, esi
	push	eax
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1591 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN2@replace:

; 211  : 		return (_Ptr - _Right._Ptr);

	mov	ecx, DWORD PTR __First$[ebp]
	sub	edx, eax
	push	ebx
	mov	ebx, DWORD PTR __Last$[ebp]
	sub	ebx, ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	push	edi
	jb	SHORT $LN76@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN77@replace
$LN76@replace:
	mov	edi, esi
$LN77@replace:

; 1587 : 		else
; 1588 : 			replace(_First - begin(), _Last - _First,

	push	edx
	push	eax

; 211  : 		return (_Ptr - _Right._Ptr);

	sub	ecx, edi

; 1587 : 		else
; 1588 : 			replace(_First - begin(), _Last - _First,

	push	ebx
	push	ecx
	mov	ecx, esi
	call	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
	pop	edi
	pop	ebx

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1591 : 		}

	pop	ebp
	ret	16					; 00000010H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1271 : 		{	// insert [_Ptr, <null>) at _Off

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@insert
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	push	ecx
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi

; 1274 : 		}

	pop	ebp
	ret	8
$LN5@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@insert:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@insert
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	push	ecx
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi

; 1274 : 		}

	pop	ebp
	ret	8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPBD0Urandom_access_iterator_tag@2@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPBD0Urandom_access_iterator_tag@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct, COMDAT
; _this$ = ecx

; 904  : 		{	// initialize from [_First, _Last), const pointers

	push	ebp
	mov	ebp, esp

; 905  : 		if (_First != _Last)

	mov	edx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR __Last$[ebp]
	cmp	edx, eax
	je	SHORT $LN2@Construct

; 906  : 			assign(_First, _Last - _First);

	sub	eax, edx
	push	eax
	push	edx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN2@Construct:

; 907  : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Construct@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXPBD0Urandom_access_iterator_tag@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAVValue@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ PROC		; std::allocator<Json::Value *>::allocator<Json::Value *>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@PAVValue@Json@@@std@@QAE@XZ ENDP		; std::allocator<Json::Value *>::allocator<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ PROC ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@VErrorInfo@Reader@Json@@@std@@QAE@XZ ENDP ; std::allocator<Json::Reader::ErrorInfo>::allocator<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==, COMDAT
; _this$ = ecx

; 220  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 221  : 		_Compat(_Right);
; 222  : 		return (_Ptr == _Right._Ptr);
; 223  : 		}

	pop	ebp
	ret	4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 209  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 210  : 		_Compat(_Right);
; 211  : 		return (_Ptr - _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[ebp]
	sub	eax, DWORD PTR [ecx]

; 212  : 		}

	pop	ebp
	ret	4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 398  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 211  : 		return (_Ptr - _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[ebp]
	sub	eax, DWORD PTR [ecx]

; 399  : 		return (*(_Mybase *)this - _Right);
; 400  : 		}

	pop	ebp
	ret	4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 340  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 341  : 		}

	ret	0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z
_TEXT	SEGMENT
__Nm$1$ = -8						; size = 4
tv1074 = -4						; size = 4
tv1071 = -4						; size = 4
__Off$ = 8						; size = 4
tv1075 = 12						; size = 4
tv1072 = 12						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	edx, DWORD PTR __Ptr$[ebp]

; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	edx, edx
	je	SHORT $LN2@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN24@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN25@replace
$LN24@replace:
	mov	eax, esi
$LN25@replace:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	edx, eax
	jb	SHORT $LN2@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN38@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN39@replace
$LN38@replace:
	mov	edi, esi
$LN39@replace:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edi
	cmp	eax, edx
	jbe	SHORT $LN2@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN61@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN62@replace
$LN61@replace:
	mov	eax, esi
$LN62@replace:

; 1454 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1455 : 		if (_Inside(_Ptr))
; 1456 : 			return (replace(_Off, _N0, *this,

	push	DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	ecx, esi
	push	edx
	push	esi
	push	DWORD PTR __N0$[ebp]
	push	DWORD PTR __Off$[ebp]
	call	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
	pop	edi
	pop	esi

; 1480 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN2@replace:

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Off$[ebp]
	cmp	ecx, eax
	jae	SHORT $LN66@replace

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN411@replace:
$LN66@replace:

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);
; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

	mov	edx, DWORD PTR __Count$[ebp]

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	mov	edi, ecx
	sub	edi, eax

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);
; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

	mov	eax, edx
	push	ebx

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	ebx, DWORD PTR __N0$[ebp]

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);
; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

	not	eax

; 2113 : 		if (_Size <= _Max_effective_size)

	cmp	ebx, edi
	cmova	ebx, edi

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);
; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

	sub	ecx, ebx
	cmp	eax, ecx
	ja	SHORT $LN3@replace

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN412@replace:
$LN3@replace:

; 1462 : 			_Xlen();	// result too long
; 1463 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;

	sub	edi, ebx
	mov	DWORD PTR __Nm$1$[ebp], edi

; 1464 : 
; 1465 : 		if (_Count < _N0)

	cmp	edx, ebx
	jae	SHORT $LN145@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN124@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv1075[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN125@replace
$LN124@replace:
	mov	DWORD PTR tv1075[ebp], esi
$LN125@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN138@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv1074[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN139@replace
$LN138@replace:
	mov	DWORD PTR tv1074[ebp], esi
$LN139@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN145@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1075[ebp]
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1074[ebp]
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	mov	edx, DWORD PTR __Count$[ebp]
	add	esp, 12					; 0000000cH
$LN145@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1469 : 		const size_type _Num = this->_Mysize() + _Count - _N0;

	mov	eax, DWORD PTR [esi+16]
	mov	edi, eax
	sub	edi, ebx
	add	edi, edx

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

	test	edx, edx
	jne	SHORT $LN6@replace
	test	ebx, ebx
	je	$LN404@replace
$LN6@replace:

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN156@replace

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN413@replace:
$LN156@replace:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN157@replace

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	edx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

	je	$LN404@replace
$LN409@replace:

; 1472 : 			{	// make room and rearrange
; 1473 : 			if (_N0 < _Count)

	cmp	ebx, edx
	jae	SHORT $LN370@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN349@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv1072[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN350@replace
$LN157@replace:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN409@replace

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN332@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	ebx
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1479 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1480 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN332@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	ebx
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1480 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN349@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	DWORD PTR tv1072[ebp], esi
$LN350@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN363@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv1071[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN364@replace
$LN363@replace:
	mov	DWORD PTR tv1071[ebp], esi
$LN364@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Nm$1$[ebp]
	test	eax, eax
	je	SHORT $LN370@replace
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1072[ebp]
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1071[ebp]
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	mov	edx, DWORD PTR __Count$[ebp]
	add	esp, 12					; 0000000cH
$LN370@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN381@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN382@replace
$LN381@replace:
	mov	eax, esi
$LN382@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edx, edx
	je	SHORT $LN388@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1476 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

	add	eax, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edx
	push	DWORD PTR __Ptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN388@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN399@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1479 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1480 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN399@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN404@replace:
	pop	ebx
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1479 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1480 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN410@replace:
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
tv954 = 12						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

	push	ebp
	mov	ebp, esp
	push	ebx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

	mov	esi, ecx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN21@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN22@insert
$LN21@insert:
	mov	eax, esi
$LN22@insert:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN35@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN36@insert
$LN35@insert:
	mov	edx, esi
$LN36@insert:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN58@insert

; 1253 : 			return (insert(_Off, *this,

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1253 : 			return (insert(_Off, *this,

	sub	ebx, eax
	push	ebx
	push	esi
	push	ecx
	mov	ecx, esi
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi
	pop	ebx

; 1268 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN58@insert:

; 1253 : 			return (insert(_Off, *this,

	push	DWORD PTR __Count$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi

; 1253 : 			return (insert(_Off, *this,

	sub	ebx, eax
	push	ebx
	push	esi
	push	ecx
	mov	ecx, esi
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi
	pop	ebx

; 1268 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@insert:

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);
; 1256 : 		if (npos - this->_Mysize() <= _Count)

	mov	edx, DWORD PTR [esi+16]
	mov	eax, edx
	mov	ecx, DWORD PTR __Count$[ebp]
	not	eax
	cmp	eax, ecx
	ja	SHORT $LN3@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN363@insert:
$LN3@insert:
	push	edi

; 1257 : 			_Xlen();	// result too long
; 1258 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [edx+ecx]

; 1259 : 		if (0 < _Count && _Grow(_Num))

	test	ecx, ecx
	je	$LN356@insert

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN99@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN364@insert:
$LN99@insert:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN100@insert

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	edx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1259 : 		if (0 < _Count && _Grow(_Num))

	je	$LN356@insert
$LN361@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN301@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR tv954[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN302@insert
$LN100@insert:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN361@insert

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN275@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1268 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN275@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1268 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN301@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	DWORD PTR tv954[ebp], esi
$LN302@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN315@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN316@insert
$LN315@insert:
	mov	eax, esi
$LN316@insert:

; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	edx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edx, edx
	je	SHORT $LN322@insert
	push	edx
	push	DWORD PTR tv954[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN322@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN333@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN334@insert
$LN333@insert:
	mov	ecx, esi
$LN334@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	je	SHORT $LN340@insert
	push	eax
	push	ebx
	push	ecx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN340@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN351@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1268 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN351@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN356@insert:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1268 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN362@insert:
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat, COMDAT
; _this$dead$ = ecx

; 270  : 		}

	ret	4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 68   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 69   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 70   : 		const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
; 71   : 		if (_Mycont == 0
; 72   : 			|| _Ptr == nullptr_t{}
; 73   : 			|| _Unfancy(_Ptr) < _Contptr
; 74   : 			|| _Contptr + _Mycont->_Mysize <= _Unfancy(_Ptr))
; 75   : 			{	// report error
; 76   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 77   : 			_SCL_SECURE_OUT_OF_RANGE;
; 78   : 			}
; 79   : 
; 80   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 81   : 		_SCL_SECURE_VALIDATE(_Ptr != nullptr_t{});
; 82   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 83   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 84   : 		const auto _Contptr = _Mycont->_Myptr();
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(_Contptr <= _Unfancy(_Ptr) && _Unfancy(_Ptr) < _Contptr + _Mycont->_Mysize);
; 86   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 87   : 
; 88   : 		_Analysis_assume_(_Ptr != nullptr_t{});
; 89   : 
; 90   : 		return (*_Ptr);

	mov	eax, DWORD PTR [ecx]

; 91   : 		}

	ret	0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z
_TEXT	SEGMENT
tv1971 = -8						; size = 4
__Max_effective_size$1$ = -8				; size = 4
__Nm$1$ = -4						; size = 4
__Off$ = 8						; size = 4
tv1970 = 12						; size = 4
tv1965 = 12						; size = 4
__N0$ = 12						; size = 4
tv1967 = 16						; size = 4
tv1963 = 16						; size = 4
__Right$ = 16						; size = 4
__Roff$ = 20						; size = 4
tv1944 = 24						; size = 4
__Newsize$1$ = 24					; size = 4
__Count$ = 24						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1389 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Off$[ebp]
	mov	edx, DWORD PTR [esi+16]
	cmp	edx, ecx
	jae	SHORT $LN16@replace

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN679@replace:
$LN16@replace:
	push	ebx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	edi
	mov	edi, DWORD PTR [ebx+16]
	cmp	edi, DWORD PTR __Roff$[ebp]
	jae	SHORT $LN32@replace

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN680@replace:
$LN32@replace:

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	mov	eax, edx

; 1390 : 		_Check_offset(_Off);
; 1391 : 		_Right._Check_offset(_Roff);
; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)

	mov	ebx, edx

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	sub	eax, ecx
	mov	DWORD PTR __Nm$1$[ebp], eax

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	eax, DWORD PTR __N0$[ebp]
	cmp	eax, DWORD PTR __Nm$1$[ebp]
	cmova	eax, DWORD PTR __Nm$1$[ebp]

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	sub	edi, DWORD PTR __Roff$[ebp]
	mov	DWORD PTR __Max_effective_size$1$[ebp], edi

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	edi, DWORD PTR __Count$[ebp]
	cmp	edi, DWORD PTR __Max_effective_size$1$[ebp]
	mov	DWORD PTR __N0$[ebp], eax
	cmova	edi, DWORD PTR __Max_effective_size$1$[ebp]

; 1390 : 		_Check_offset(_Off);
; 1391 : 		_Right._Check_offset(_Roff);
; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)

	sub	ebx, eax
	mov	eax, edi
	mov	DWORD PTR tv1944[ebp], ebx
	not	eax
	cmp	eax, ebx
	mov	ebx, DWORD PTR __Right$[ebp]
	ja	SHORT $LN2@replace

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN681@replace:
$LN2@replace:

; 1395 : 			_Xlen();	// result too long
; 1396 : 
; 1397 : 		const size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1398 : 		const size_type _Newsize = this->_Mysize() + _Count - _N0;

	mov	ecx, DWORD PTR tv1944[ebp]
	mov	eax, DWORD PTR __Nm$1$[ebp]
	add	ecx, edi
	sub	eax, DWORD PTR __N0$[ebp]

; 1399 : 		if (this->_Mysize() < _Newsize)

	cmp	edx, ecx
	mov	DWORD PTR __Newsize$1$[ebp], ecx
	mov	ecx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Nm$1$[ebp], eax
	jae	SHORT $LN292@replace

; 2225 : 		if (max_size() < _Newsize)

	cmp	DWORD PTR __Newsize$1$[ebp], -2		; fffffffeH
	jbe	SHORT $LN111@replace

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN682@replace:
$LN111@replace:

; 2227 : 		if (this->_Myres() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$1$[ebp]
	cmp	DWORD PTR [esi+20], ebx
	mov	ebx, DWORD PTR __Right$[ebp]
	jae	SHORT $LN112@replace

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	edx
	push	DWORD PTR __Newsize$1$[ebp]
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Off$[ebp]
	jmp	SHORT $LN676@replace
$LN112@replace:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$1$[ebp], 0
	jne	SHORT $LN292@replace

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN287@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN288@replace
$LN287@replace:
	mov	eax, esi
$LN288@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
$LN676@replace:
	mov	eax, DWORD PTR __Nm$1$[ebp]
$LN292@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1402 : 		if (_Count == _N0)

	mov	edx, DWORD PTR __N0$[ebp]
	cmp	edi, edx
	jne	SHORT $LN4@replace

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN304@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN304@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	$LN510@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	$LN511@replace
$LN4@replace:

; 1403 : 			{	// only one movement required, so _Traits::move handles any overlap
; 1404 : 			_Traits::move(this->_Myptr() + _Off,
; 1405 : 				_Right._Myptr() + _Roff, _Count);	// fill hole
; 1406 : 			}
; 1407 : 		else if (this != &_Right)

	cmp	esi, ebx
	je	SHORT $LN6@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN336@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR tv1971[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, DWORD PTR __N0$[ebp]
	jmp	SHORT $LN337@replace
$LN336@replace:
	mov	DWORD PTR tv1971[ebp], esi
$LN337@replace:
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN350@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR tv1970[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ebx, DWORD PTR __Right$[ebp]
	jmp	SHORT $LN351@replace
$LN350@replace:
	mov	DWORD PTR tv1970[ebp], esi
$LN351@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	eax, eax
	je	SHORT $LN357@replace
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1971[ebp]
	add	eax, ecx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1970[ebp]
	add	eax, ecx
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN357@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN368@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN368@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN382@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN383@replace
$LN382@replace:
	mov	ecx, esi
$LN383@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	$LN13@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1411 : 			_Traits::copy(this->_Myptr() + _Off,

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1411 : 			_Traits::copy(this->_Myptr() + _Off,

	mov	eax, DWORD PTR __Off$[ebp]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	jmp	$LN13@replace
$LN6@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1414 : 		else if (_Count < _N0)

	cmp	edi, edx
	jae	$LN8@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN400@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR tv1967[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN401@replace
$LN400@replace:
	mov	DWORD PTR tv1967[ebp], esi
$LN401@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN414@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN415@replace
$LN414@replace:
	mov	ebx, esi
$LN415@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN421@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1416 : 			_Traits::move(this->_Myptr() + _Off,

	mov	eax, DWORD PTR tv1967[ebp]
	add	eax, DWORD PTR __Roff$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1416 : 			_Traits::move(this->_Myptr() + _Off,

	lea	eax, DWORD PTR [ebx+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	mov	edx, DWORD PTR __N0$[ebp]
	add	esp, 12					; 0000000cH
$LN421@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN432@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv1965[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN433@replace
$LN432@replace:
	mov	DWORD PTR tv1965[ebp], esi
$LN433@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN446@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN447@replace
$LN446@replace:
	mov	ecx, esi
$LN447@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Nm$1$[ebp]
	test	eax, eax
	je	$LN13@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	ebx, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1965[ebp]
	add	eax, ebx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	lea	eax, DWORD PTR [ecx+ebx]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

	jmp	$LN13@replace
$LN8@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1421 : 		else if (_Roff <= _Off)

	mov	ebx, DWORD PTR __Roff$[ebp]
	cmp	ebx, ecx
	ja	SHORT $LN10@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ebx, DWORD PTR [esi+20]
	cmp	ebx, 16					; 00000010H
	jb	SHORT $LN464@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR tv1963[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, DWORD PTR __N0$[ebp]
	jmp	SHORT $LN465@replace
$LN464@replace:
	mov	DWORD PTR tv1963[ebp], esi
$LN465@replace:
	cmp	ebx, 16					; 00000010H
	jb	SHORT $LN478@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN479@replace
$LN478@replace:
	mov	ebx, esi
$LN479@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	eax, eax
	je	SHORT $LN485@replace
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1963[ebp]
	add	eax, ecx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	lea	eax, DWORD PTR [ebx+ecx]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	mov	ecx, DWORD PTR __Off$[ebp]
	add	esp, 12					; 0000000cH
$LN485@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN496@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN497@replace
$LN496@replace:
	mov	ebx, esi
$LN497@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN510@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN511@replace
$LN510@replace:
	mov	edx, esi
$LN511@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	$LN13@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1425 : 			_Traits::move(this->_Myptr() + _Off,

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1425 : 			_Traits::move(this->_Myptr() + _Off,

	lea	eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

	jmp	$LN13@replace
$LN10@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1428 : 		else if (_Off + _N0 <= _Roff)

	lea	eax, DWORD PTR [ecx+edx]
	cmp	eax, ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]

; 1428 : 		else if (_Off + _N0 <= _Roff)

	ja	SHORT $LN12@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN528@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN529@replace
$LN528@replace:
	mov	edx, esi
$LN529@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN542@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN543@replace
$LN542@replace:
	mov	eax, esi
$LN543@replace:

; 1429 : 			{	// hole gets larger, substring begins after hole
; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	push	DWORD PTR __Nm$1$[ebp]
	mov	ebx, DWORD PTR __N0$[ebp]
	add	edx, ecx
	add	ecx, eax
	add	edx, ebx
	add	ecx, edi
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]

; 1429 : 			{	// hole gets larger, substring begins after hole
; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	add	esp, 4

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN556@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN557@replace
$LN556@replace:
	mov	edx, esi
$LN557@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN570@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1432 : 			_Traits::move(this->_Myptr() + _Off,

	sub	edx, ebx
	mov	ecx, DWORD PTR __Off$[ebp]
	push	edi
	lea	ecx, DWORD PTR [eax+ecx]

; 1433 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1434 : 				_Count);	// fill hole
; 1435 : 			}
; 1436 : 		else

	jmp	$LN677@replace
$LN570@replace:

; 1432 : 			_Traits::move(this->_Myptr() + _Off,

	mov	ecx, DWORD PTR __Off$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi

; 1432 : 			_Traits::move(this->_Myptr() + _Off,

	push	edi
	sub	edx, ebx
	lea	ecx, DWORD PTR [eax+ecx]

; 1433 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1434 : 				_Count);	// fill hole
; 1435 : 			}
; 1436 : 		else

	jmp	SHORT $LN677@replace
$LN12@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN584@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN585@replace
$LN584@replace:
	mov	ebx, esi
$LN585@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN598@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN599@replace
$LN598@replace:
	mov	eax, esi
$LN599@replace:

; 1437 : 			{	// hole gets larger, substring begins in hole
; 1438 : 			_Traits::move(this->_Myptr() + _Off,

	push	edx
	mov	edx, DWORD PTR __Roff$[ebp]
	add	ecx, eax
	add	edx, ebx
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]

; 1437 : 			{	// hole gets larger, substring begins in hole
; 1438 : 			_Traits::move(this->_Myptr() + _Off,

	add	esp, 4

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN612@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN613@replace
$LN612@replace:
	mov	ecx, esi
$LN613@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN626@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN627@replace
$LN626@replace:
	mov	eax, esi
$LN627@replace:

; 1439 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	ebx, DWORD PTR __Off$[ebp]
	push	DWORD PTR __Nm$1$[ebp]
	lea	edx, DWORD PTR [ecx+ebx]
	add	edx, DWORD PTR __N0$[ebp]
	lea	ecx, DWORD PTR [eax+ebx]
	add	ecx, edi
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]

; 1439 : 				this->_Myptr() + _Roff, _N0);	// fill old hole
; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	add	esp, 4

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN640@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN641@replace
$LN640@replace:
	mov	edx, esi
$LN641@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN654@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN655@replace
$LN654@replace:
	mov	ecx, esi
$LN655@replace:

; 1441 : 				this->_Myptr() + _Off + _N0, _Nm);	// move tail down
; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,

	mov	eax, edi
	add	ecx, ebx
	sub	eax, DWORD PTR __N0$[ebp]
	add	ecx, DWORD PTR __N0$[ebp]
	push	eax
$LN677@replace:
	add	edx, DWORD PTR __Roff$[ebp]
	add	edx, edi
	call	?move@?$char_traits@D@std@@SAPADPADPBDI@Z ; std::char_traits<char>::move
	add	esp, 4
$LN13@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	pop	edi
	mov	DWORD PTR [esi+16], ecx
	pop	ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN668@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1448 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN668@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN678@replace:
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
__Off$dead$ = 8						; size = 4
__Right$ = 12						; size = 4
tv1008 = 16						; size = 4
__Roff$ = 16						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

	push	ebp
	mov	ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Right$[ebp]
	push	ebx
	push	esi

; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	mov	eax, DWORD PTR [eax+16]
	push	edi
	cmp	eax, ecx
	jae	SHORT $LN26@insert

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	DWORD PTR __imp_?_Xout_of_range@std@@YAXPBD@Z
$LN384@insert:
$LN26@insert:

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	edi, DWORD PTR __Count$[ebp]
	sub	eax, ecx

; 1224 : 		_Check_offset(_Off);
; 1225 : 		_Right._Check_offset(_Roff);
; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1227 : 		if (npos - this->_Mysize() <= _Count)

	mov	ecx, DWORD PTR [esi+16]

; 2113 : 		if (_Size <= _Max_effective_size)

	cmp	edi, eax
	cmova	edi, eax

; 1224 : 		_Check_offset(_Off);
; 1225 : 		_Right._Check_offset(_Roff);
; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1227 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, ecx
	not	eax
	cmp	eax, edi
	ja	SHORT $LN2@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN385@insert:
$LN2@insert:

; 1228 : 			_Xlen();	// result too long
; 1229 : 
; 1230 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	ebx, DWORD PTR [ecx+edi]

; 1231 : 		if (0 < _Count && _Grow(_Num))

	test	edi, edi
	je	$LN377@insert

; 2225 : 		if (max_size() < _Newsize)

	cmp	ebx, -2					; fffffffeH
	jbe	SHORT $LN74@insert

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN386@insert:
$LN74@insert:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], ebx
	jae	SHORT $LN75@insert

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	ebx, ebx

; 1231 : 		if (0 < _Count && _Grow(_Num))

	je	$LN377@insert
$LN381@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN276@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN277@insert
$LN75@insert:

; 2232 : 		else if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN381@insert

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN250@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN250@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN276@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi
$LN277@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN290@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN291@insert
$LN290@insert:
	mov	eax, esi
$LN291@insert:

; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	ecx, ecx
	je	SHORT $LN297@insert
	push	ecx
	push	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
$LN297@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1236 : 			if (this == &_Right)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	esi, eax
	jne	SHORT $LN4@insert
	mov	eax, DWORD PTR __Roff$[ebp]
	test	eax, eax
	lea	edx, DWORD PTR [eax+edi]
	cmove	edx, eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN308@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv1008[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN309@insert
$LN308@insert:
	mov	DWORD PTR tv1008[ebp], esi
$LN309@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN322@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN323@insert
$LN322@insert:
	mov	ecx, esi
$LN323@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN361@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

	mov	eax, DWORD PTR tv1008[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	push	ecx
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1240 : 			else

	jmp	SHORT $LN382@insert
$LN4@insert:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN340@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN340@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN354@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN355@insert
$LN354@insert:
	mov	edx, esi
$LN355@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN361@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

	add	eax, DWORD PTR __Roff$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
	push	edx
	call	_memcpy
$LN382@insert:
	add	esp, 12					; 0000000cH
$LN361@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN372@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN372@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
$LN377@insert:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN383@insert:
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
__Ok$ = -40						; size = 8
__State$ = -32						; size = 4
__Istr$ = -28						; size = 4
__Str$1$ = -24						; size = 4
__Changed$ = -17					; size = 1
__$EHRec$ = -16						; size = 16
__Delim$dead$ = 8					; size = 1
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Istr$ = ecx
; __Str$ = edx

; 77   : 	{	// get characters into string, discard delimiter

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Str$1$[ebp], edx
	mov	esi, ecx
	mov	DWORD PTR __Istr$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 80   : 	ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi

; 81   : 	bool _Changed = false;

	xor	bl, bl
	mov	DWORD PTR __State$[ebp], edi
	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 93   : 			: _Myistr(_Istr)

	mov	DWORD PTR __Ok$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 95   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN24@getline

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN24@getline:

; 118  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	push	1
	mov	ecx, esi
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	call	DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	BYTE PTR __Ok$[ebp+4], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 82   : 	const typename _Myis::sentry _Ok(_Istr, true);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 83   : 
; 84   : 	if (_Ok)

	test	al, al
	je	$LN135@getline
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	eax, DWORD PTR __Str$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 86   : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN60@getline
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN60@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 90   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
$LN138@getline:
	mov	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	edx, -1
	sete	cl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 93   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	test	cl, cl
	je	SHORT $LN7@getline

; 94   : 				{	// end of file, quit
; 95   : 				_State |= ios_base::eofbit;

	mov	edi, 1

; 96   : 				break;

	jmp	SHORT $LN3@getline
$LN7@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	edx, 255				; 000000ffH
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 98   : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

	test	al, al
	je	SHORT $LN9@getline
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 100  : 				_Changed = true;

	mov	bl, 1
	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 101  : 				_Istr.rdbuf()->sbumpc();

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ

; 102  : 				break;

	jmp	SHORT $LN3@getline
$LN9@getline:

; 103  : 				}
; 104  : 			else if (_Str.max_size() <= _Str.size())

	mov	eax, DWORD PTR __Str$1$[ebp]
	cmp	DWORD PTR [eax+16], -2			; fffffffeH
	jb	SHORT $LN11@getline

; 105  : 				{	// string too large, quit
; 106  : 				_State |= ios_base::failbit;

	mov	edi, 2
	jmp	SHORT $LN3@getline
$LN11@getline:

; 107  : 				break;
; 108  : 				}
; 109  : 			else
; 110  : 				{	// got a character, add it to string
; 111  : 				_Str += _Traits::to_char_type(_Meta);

	push	edx
	mov	ecx, eax
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 112  : 				_Changed = true;

	mov	bl, 1
	mov	BYTE PTR __Changed$[ebp], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 92   : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

	mov	ecx, DWORD PTR [eax+esi+56]
	call	DWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHXZ
	jmp	SHORT $LN138@getline
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:

; 113  : 				}
; 114  : 		_CATCH_IO_(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN19@getline
	ret	0
$LN19@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	esi, DWORD PTR __Istr$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
	mov	bl, BYTE PTR __Changed$[ebp]
$LN3@getline:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 115  : 		}
; 116  : 
; 117  : 	if (!_Changed)

	test	bl, bl
	jne	SHORT $LN13@getline
$LN135@getline:

; 118  : 		_State |= ios_base::failbit;

	or	edi, 2
$LN13@getline:

; 119  : 	_Istr.setstate(_State);

	mov	eax, DWORD PTR [esi]
	push	0
	push	edi
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, esi
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 100  : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR __Ok$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN136@getline

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN136@getline:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 120  : 	return (_Istr);

	mov	eax, esi

; 121  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
__unwindfunclet$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$26:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QAV10@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QAV?$basic_istream@DU?$char_traits@D@std@@@0@AAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$dead$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 598  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 598  : 		}

	ret	4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PBD@std@@YAPBDPBD@Z
_TEXT	SEGMENT
??$_Unchecked@PBD@std@@YAPBDPBD@Z PROC			; std::_Unchecked<char const *>, COMDAT
; __Src$ = ecx

; 428  : 	return (_Src);

	mov	eax, ecx

; 429  : 	}

	ret	0
??$_Unchecked@PBD@std@@YAPBDPBD@Z ENDP			; std::_Unchecked<char const *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z
_TEXT	SEGMENT
??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z PROC ; std::forward<Json::Reader::ErrorInfo const &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@ABVErrorInfo@Reader@Json@@@std@@YAABVErrorInfo@Reader@Json@@ABV123@@Z ENDP ; std::forward<Json::Reader::ErrorInfo const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_<_Args_0>$ = 8						; size = 4
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edi, edi
	je	SHORT $LN8@construct
	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [edi], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	lea	eax, DWORD PTR [esi+12]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+36], eax
$LN8@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z$1:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@ABV345@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@$$V@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@VErrorInfo@Reader@Json@@$$V@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN7@construct
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+32], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+12], 0
$LN7@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	pop	ebp
	ret	4
??$construct@VErrorInfo@Reader@Json@@$$V@?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
??$?8V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1017 : 	return (static_cast<const _Ty&>(_Left)

	mov	al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

	ret	0
??$?8V?$allocator@VErrorInfo@Reader@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<Json::Reader::ErrorInfo>,std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 12
??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 421  : 	return {};

	xor	al, al

; 422  : 	}

	ret	0
??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_no_deprecate@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T2 = -8						; size = 1
$T1 = -4						; size = 1
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 12
??$_Copy_no_deprecate@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z PROC ; std::_Copy_no_deprecate<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2361 : 	{	// copy [_First, _Last) to [_Dest, ...), no _SCL_INSECURE_DEPRECATE_FN warnings

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi

; 2362 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2363 : 	return (_Copy_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	mov	BYTE PTR $T1[ebp], 0
	mov	esi, ecx
	push	DWORD PTR $T1[ebp]
	mov	BYTE PTR $T2[ebp], 0
	push	DWORD PTR $T2[ebp]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
	test	eax, eax
	je	SHORT $LN20@Copy_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN20@Copy_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN20@Copy_no_de:
	mov	eax, DWORD PTR __Dest$[ebp+8]
	mov	DWORD PTR [ecx+8], eax

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]
	test	eax, eax
	je	SHORT $LN73@Copy_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN73@Copy_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN73@Copy_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN43@Copy_no_de
$LN73@Copy_no_de:
	xor	eax, eax
$LN43@Copy_no_de:

; 2362 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2363 : 	return (_Copy_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __Last$[ebp+8]
	push	eax

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN74@Copy_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN74@Copy_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN74@Copy_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN67@Copy_no_de
$LN74@Copy_no_de:
	xor	eax, eax
$LN67@Copy_no_de:

; 2362 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2363 : 	return (_Copy_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __First$[ebp+8]
	mov	ecx, esi
	push	eax
	call	??$_Copy_no_deprecate1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Copy_no_deprecate1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H
	mov	eax, esi

; 2364 : 		_Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
; 2365 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_no_deprecate@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ENDP ; std::_Copy_no_deprecate<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z PROC ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 3553 : 	{	// reverse elements in [_First, _Last)

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]
	test	eax, eax
	je	SHORT $LN61@reverse

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN61@reverse

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN61@reverse
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@reverse
$LN61@reverse:
	xor	eax, eax
$LN26@reverse:

; 3554 : 	_DEBUG_RANGE(_First, _Last);
; 3555 : 	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));

	push	DWORD PTR __Last$[ebp+8]
	push	eax

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN62@reverse

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN62@reverse

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN62@reverse

; 3554 : 	_DEBUG_RANGE(_First, _Last);
; 3555 : 	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));

	push	DWORD PTR __First$[ebp+8]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 3554 : 	_DEBUG_RANGE(_First, _Last);
; 3555 : 	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));

	push	eax
	call	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 16					; 00000010H

; 3556 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@reverse:

; 3554 : 	_DEBUG_RANGE(_First, _Last);
; 3555 : 	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));

	push	DWORD PTR __First$[ebp+8]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	xor	eax, eax

; 3554 : 	_DEBUG_RANGE(_First, _Last);
; 3555 : 	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));

	push	eax
	call	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 16					; 00000010H

; 3556 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ENDP ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T13 = -12						; size = 4
$T12 = -8						; size = 1
$T10 = -8						; size = 8
__First$ = 8						; size = 12
__Mid$ = 20						; size = 12
__Last$ = 32						; size = 12
??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 3624 : 	{	// rotate [_First, _Last)

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]

; 3624 : 	{	// rotate [_First, _Last)

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN119@rotate

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN119@rotate

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN119@rotate
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN26@rotate
$LN119@rotate:
	xor	edx, edx
$LN26@rotate:

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Mid$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 49   : 		_Myoff(_Off)

	mov	ecx, DWORD PTR __Last$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN120@rotate

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN120@rotate

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN120@rotate
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR $T13[esp+24], ebx
	jmp	SHORT $LN54@rotate
$LN120@rotate:
	mov	DWORD PTR $T13[esp+24], 0
$LN54@rotate:

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN121@rotate

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	edi, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	edi, edi
	je	SHORT $LN121@rotate

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	edi, DWORD PTR [edi]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	edi, edi
	je	SHORT $LN121@rotate
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN82@rotate
$LN121@rotate:
	xor	edi, edi
$LN82@rotate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 49   : 		_Myoff(_Off)

	mov	ebx, DWORD PTR __First$[ebp+8]

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	ebx, DWORD PTR __Mid$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3615 : 	if (_First == _Mid)

	je	SHORT $LN87@rotate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	DWORD PTR __Mid$[ebp+8], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3617 : 	if (_Mid == _Last)

	jne	SHORT $LN89@rotate

; 3618 : 		return (_First);

	mov	ecx, ebx
	jmp	SHORT $LN87@rotate
$LN89@rotate:

; 3619 : 	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));

	push	ecx
	push	edx
	push	DWORD PTR __Mid$[ebp+8]
	mov	BYTE PTR $T12[esp+36], 0
	lea	ecx, DWORD PTR $T10[esp+36]
	push	DWORD PTR $T13[esp+36]
	push	ebx
	push	edi
	push	DWORD PTR $T12[esp+48]
	call	??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	mov	eax, DWORD PTR __First$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR $T10[esp+28]
$LN87@rotate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	DWORD PTR __First$[ebp+8], ecx
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN124@rotate

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN124@rotate

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
$LN124@rotate:

; 3625 : 	_DEBUG_RANGE(_First, _Mid);
; 3626 : 	_DEBUG_RANGE(_Mid, _Last);
; 3627 : 	return (_Rechecked(_First,
; 3628 : 		_Rotate_unchecked(_Unchecked(_First), _Unchecked(_Mid),
; 3629 : 		_Unchecked(_Last))));
; 3630 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [ecx+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [ecx+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [ecx+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >,std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> >,1><std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z PROC ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<Json::Reader::ErrorInfo const &>, COMDAT
; _this$ = ecx

; 1185 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [edi+16]
	inc	eax
	cmp	DWORD PTR [edi+8], eax
	ja	SHORT $LN2@emplace_ba
	push	ecx
	call	?_Growmap@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::_Growmap
$LN2@emplace_ba:
	mov	eax, DWORD PTR [edi+8]
	dec	eax
	and	DWORD PTR [edi+12], eax
	mov	eax, DWORD PTR [edi+16]
	add	eax, DWORD PTR [edi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [edi+8]
	dec	ecx
	and	ecx, eax

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [edi+4]
	lea	ebx, DWORD PTR [ecx*4]
	cmp	DWORD PTR [ebx+eax], 0
	jne	SHORT $LN3@emplace_ba
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	DWORD PTR [ebx+ecx], eax
$LN3@emplace_ba:

; 1188 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [edi+4]
	mov	ebx, DWORD PTR [ebx+eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ebx, ebx
	je	SHORT $LN304@emplace_ba
	mov	esi, DWORD PTR _<_Val_0>$[ebp]
	lea	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [ebx], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ebx+8], eax
	lea	eax, DWORD PTR [esi+12]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [ebx+36], eax
$LN304@emplace_ba:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1191 : 		_PUSH_BACK_END;

	inc	DWORD PTR [edi+16]

; 1192 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z$42:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$emplace_back@ABVErrorInfo@Reader@Json@@@?$deque@VErrorInfo@Reader@Json@@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEXABVErrorInfo@Reader@Json@@@Z ENDP ; std::deque<Json::Reader::ErrorInfo,std::allocator<Json::Reader::ErrorInfo> >::emplace_back<Json::Reader::ErrorInfo const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1017 : 	return (static_cast<const _Ty&>(_Left)

	mov	al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

	ret	0
??$?8V?$allocator@D@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@YA$$QAV?$allocator@VErrorInfo@Reader@Json@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@YA$$QAV?$allocator@VErrorInfo@Reader@Json@@@0@AAV10@@Z PROC ; std::forward<std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@YA$$QAV?$allocator@VErrorInfo@Reader@Json@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1052 : 	_Left = _STD move(_Right);
; 1053 : 	}

	ret	0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1039 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<Json::Value *> > &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<Json::Value *> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>, COMDAT
; _this$ = ecx

; 710  : 		}

	mov	eax, ecx
	ret	4
??$?0PAVValue@Json@@@?$allocator@PAPAVValue@Json@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::allocator<Json::Value * *>::allocator<Json::Value * *><Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value * *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAPAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAPAVValue@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z
_TEXT	SEGMENT
??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAVValue@Json@@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::destroy<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z
_TEXT	SEGMENT
??$?8V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z PROC ; std::operator==<std::allocator<Json::Value *>,std::allocator<Json::Value *> >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1017 : 	return (static_cast<const _Ty&>(_Left)

	mov	al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

	ret	0
??$?8V?$allocator@PAVValue@Json@@@std@@V01@@std@@YA_NABU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0@Z ENDP ; std::operator==<std::allocator<Json::Value *>,std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 12
??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 421  : 	return {};

	xor	al, al

; 422  : 	}

	ret	0
??$_Is_checked@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AU?$integral_constant@_N$00@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Is_checked<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_no_deprecate@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
$T2 = -4						; size = 1
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 12
??$_Copy_no_deprecate@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z PROC ; std::_Copy_no_deprecate<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2361 : 	{	// copy [_First, _Last) to [_Dest, ...), no _SCL_INSECURE_DEPRECATE_FN warnings

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]

; 2362 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2363 : 	return (_Copy_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	mov	BYTE PTR $T1[esp+12], 0
	mov	BYTE PTR $T2[esp+12], 0
	push	esi
	mov	esi, ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN70@Copy_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN70@Copy_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN70@Copy_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN24@Copy_no_de
$LN70@Copy_no_de:
	xor	eax, eax
$LN24@Copy_no_de:

; 2362 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2363 : 	return (_Copy_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __Last$[ebp+8]
	push	eax

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN71@Copy_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN71@Copy_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN71@Copy_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN48@Copy_no_de
$LN71@Copy_no_de:
	xor	eax, eax
$LN48@Copy_no_de:

; 2362 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2363 : 	return (_Copy_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __First$[ebp+8]
	push	eax
	push	DWORD PTR $T1[esp+32]
	push	DWORD PTR $T2[esp+36]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
	test	eax, eax
	je	SHORT $LN65@Copy_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN65@Copy_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN65@Copy_no_de:
	mov	eax, DWORD PTR __Dest$[ebp+8]
	mov	DWORD PTR [ecx+8], eax

; 2362 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2363 : 	return (_Copy_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	mov	ecx, esi
	call	??$_Copy_no_deprecate1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Copy_no_deprecate1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H
	mov	eax, esi

; 2364 : 		_Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
; 2365 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_no_deprecate@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ENDP ; std::_Copy_no_deprecate<std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z PROC ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 3553 : 	{	// reverse elements in [_First, _Last)

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]
	test	eax, eax
	je	SHORT $LN61@reverse

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN61@reverse

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN61@reverse
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@reverse
$LN61@reverse:
	xor	eax, eax
$LN26@reverse:

; 3554 : 	_DEBUG_RANGE(_First, _Last);
; 3555 : 	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));

	push	DWORD PTR __Last$[ebp+8]
	push	eax

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN62@reverse

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN62@reverse

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN62@reverse

; 3554 : 	_DEBUG_RANGE(_First, _Last);
; 3555 : 	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));

	push	DWORD PTR __First$[ebp+8]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 3554 : 	_DEBUG_RANGE(_First, _Last);
; 3555 : 	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));

	push	eax
	call	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 16					; 00000010H

; 3556 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
$LN62@reverse:

; 3554 : 	_DEBUG_RANGE(_First, _Last);
; 3555 : 	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));

	push	DWORD PTR __First$[ebp+8]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	xor	eax, eax

; 3554 : 	_DEBUG_RANGE(_First, _Last);
; 3555 : 	_Reverse_unchecked(_Unchecked(_First), _Unchecked(_Last));

	push	eax
	call	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 16					; 00000010H

; 3556 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$reverse@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ENDP ; std::reverse<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T13 = -12						; size = 4
$T12 = -8						; size = 1
$T10 = -8						; size = 8
__First$ = 8						; size = 12
__Mid$ = 20						; size = 12
__Last$ = 32						; size = 12
??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 3624 : 	{	// rotate [_First, _Last)

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]

; 3624 : 	{	// rotate [_First, _Last)

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN119@rotate

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN119@rotate

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN119@rotate
	mov	edx, DWORD PTR [eax]
	jmp	SHORT $LN26@rotate
$LN119@rotate:
	xor	edx, edx
$LN26@rotate:

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Mid$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 49   : 		_Myoff(_Off)

	mov	ecx, DWORD PTR __Last$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN120@rotate

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN120@rotate

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN120@rotate
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR $T13[esp+24], ebx
	jmp	SHORT $LN54@rotate
$LN120@rotate:
	mov	DWORD PTR $T13[esp+24], 0
$LN54@rotate:

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN121@rotate

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	edi, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	edi, edi
	je	SHORT $LN121@rotate

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	edi, DWORD PTR [edi]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	edi, edi
	je	SHORT $LN121@rotate
	mov	edi, DWORD PTR [edi]
	jmp	SHORT $LN82@rotate
$LN121@rotate:
	xor	edi, edi
$LN82@rotate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 49   : 		_Myoff(_Off)

	mov	ebx, DWORD PTR __First$[ebp+8]

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	ebx, DWORD PTR __Mid$[ebp+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3615 : 	if (_First == _Mid)

	je	SHORT $LN87@rotate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	DWORD PTR __Mid$[ebp+8], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3617 : 	if (_Mid == _Last)

	jne	SHORT $LN89@rotate

; 3618 : 		return (_First);

	mov	ecx, ebx
	jmp	SHORT $LN87@rotate
$LN89@rotate:

; 3619 : 	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));

	push	ecx
	push	edx
	push	DWORD PTR __Mid$[ebp+8]
	mov	BYTE PTR $T12[esp+36], 0
	lea	ecx, DWORD PTR $T10[esp+36]
	push	DWORD PTR $T13[esp+36]
	push	ebx
	push	edi
	push	DWORD PTR $T12[esp+48]
	call	??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	mov	eax, DWORD PTR __First$[ebp]
	add	esp, 28					; 0000001cH
	mov	ecx, DWORD PTR $T10[esp+28]
$LN87@rotate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	DWORD PTR __First$[ebp+8], ecx
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN124@rotate

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN124@rotate

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
$LN124@rotate:

; 3625 : 	_DEBUG_RANGE(_First, _Mid);
; 3626 : 	_DEBUG_RANGE(_Mid, _Last);
; 3627 : 	return (_Rechecked(_First,
; 3628 : 		_Rotate_unchecked(_Unchecked(_First), _Unchecked(_Mid),
; 3629 : 		_Unchecked(_Last))));
; 3630 : 	}

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$rotate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::rotate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	0
??$construct@PAVValue@Json@@PAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@$$QAPAV34@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<Json::Value *> > >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1><std::_Wrap_alloc<std::allocator<Json::Value *> > >, COMDAT
; _this$ = ecx

; 79   : 		: _Myproxy(0)

	mov	DWORD PTR [ecx], 0

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 759  : 		: _Map(),

	mov	DWORD PTR [ecx+4], 0

; 760  : 		_Mapsize(0),

	mov	DWORD PTR [ecx+8], 0

; 761  : 		_Myoff(0),

	mov	DWORD PTR [ecx+12], 0

; 762  : 		_Mysize(0)

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Json::Value *> >,std::_Deque_val<std::_Deque_simple_types<Json::Value *> >,1><std::_Wrap_alloc<std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$emplace_back@ABQAVValue@Json@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$emplace_back@ABQAVValue@Json@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z PROC ; std::deque<Json::Value *,std::allocator<Json::Value *> >::emplace_back<Json::Value * const &>, COMDAT
; _this$ = ecx

; 1185 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [esi+16]
	add	eax, ecx
	test	al, 3
	jne	SHORT $LN2@emplace_ba
	lea	eax, DWORD PTR [ecx+4]
	shr	eax, 2
	cmp	DWORD PTR [esi+8], eax
	ja	SHORT $LN2@emplace_ba
	push	ecx
	mov	ecx, esi
	call	?_Growmap@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@IAEXI@Z ; std::deque<Json::Value *,std::allocator<Json::Value *> >::_Growmap
$LN2@emplace_ba:
	mov	eax, DWORD PTR [esi+8]
	push	ebx
	push	edi
	lea	eax, DWORD PTR [eax*4-1]
	and	DWORD PTR [esi+12], eax
	mov	edi, DWORD PTR [esi+16]
	add	edi, DWORD PTR [esi+12]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [esi+8]
	mov	eax, edi
	shr	eax, 2
	dec	ecx
	and	ecx, eax

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	eax, DWORD PTR [esi+4]
	lea	ebx, DWORD PTR [ecx*4]
	cmp	DWORD PTR [ebx+eax], 0
	jne	SHORT $LN3@emplace_ba
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1187 : 		_PUSH_BACK_BEGIN;

	mov	DWORD PTR [ebx+ecx], eax
$LN3@emplace_ba:

; 1188 : 		this->_Getal().construct(

	mov	eax, DWORD PTR [esi+4]
	and	edi, 3
	mov	eax, DWORD PTR [ebx+eax]
	lea	ecx, DWORD PTR [eax+edi*4]
	pop	edi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN175@emplace_ba
	mov	eax, DWORD PTR _<_Val_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN175@emplace_ba:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 1191 : 		_PUSH_BACK_END;

	inc	DWORD PTR [esi+16]
	pop	esi

; 1192 : 		}

	pop	ebp
	ret	4
??$emplace_back@ABQAVValue@Json@@@?$deque@PAVValue@Json@@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXABQAVValue@Json@@@Z ENDP ; std::deque<Json::Value *,std::allocator<Json::Value *> >::emplace_back<Json::Value * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 710  : 		}

	mov	eax, ecx
	ret	4
??$?0VErrorInfo@Reader@Json@@@?$allocator@PAVErrorInfo@Reader@Json@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo *>::allocator<Json::Reader::ErrorInfo *><Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z
_TEXT	SEGMENT
??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z PROC ; std::_Unchecked<Json::Reader::ErrorInfo * *>, COMDAT
; __Src$ = ecx

; 428  : 	return (_Src);

	mov	eax, ecx

; 429  : 	}

	ret	0
??$_Unchecked@PAPAVErrorInfo@Reader@Json@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@@Z ENDP ; std::_Unchecked<Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy_al_unchecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 252  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z
_TEXT	SEGMENT
??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z PROC ; std::_Rechecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 458  : 	_Dest = _Src;

	mov	DWORD PTR [ecx], edx

; 459  : 	return (_Dest);

	mov	eax, ecx

; 460  : 	}

	ret	0
??$_Rechecked@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAAAPAPAVErrorInfo@Reader@Json@@AAPAPAV123@PAPAV123@@Z ENDP ; std::_Rechecked<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Json::Reader::ErrorInfo * *,unsigned int,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 472  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PAPAVErrorInfo@Reader@Json@@IV?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAXPAPAVErrorInfo@Reader@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Json::Reader::ErrorInfo * *,unsigned int,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo * *>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@PAPAVErrorInfo@Reader@Json@@@std@@YAXPAPAVErrorInfo@Reader@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Json::Reader::ErrorInfo *>,Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 12
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; ___$ReturnUdt$ = ecx

; 661  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR __Iter$[ebp]
	test	eax, eax
	jne	SHORT $LN7@Unchecked
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Iter$[ebp+8]
	mov	DWORD PTR [ecx+4], eax

; 662  : 	return (_Iter._Unchecked());

	mov	eax, ecx

; 663  : 	}

	pop	ebp
	ret	0
$LN7@Unchecked:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Iter$[ebp+8]
	mov	DWORD PTR [ecx+4], eax

; 662  : 	return (_Iter._Unchecked());

	mov	eax, ecx

; 663  : 	}

	pop	ebp
	ret	0
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_backward1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
_TEXT	SEGMENT
$T4 = -8						; size = 1
$T6 = -8						; size = 8
__Dest$ = 8						; size = 12
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
__First$ = 28						; size = 8
__Last$ = 36						; size = 8
??$_Move_backward1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z PROC ; std::_Move_backward1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2694 : 	{	// move [_First, _Last) backwards to [..., _Dest), random-access iterators

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]

; 2694 : 	{	// move [_First, _Last) backwards to [..., _Dest), random-access iterators

	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN57@Move_backw

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN57@Move_backw

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN57@Move_backw
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@Move_backw
$LN57@Move_backw:
	xor	eax, eax
$LN26@Move_backw:

; 800  : 	return {};

	mov	BYTE PTR $T4[esp+16], 0

; 2677 : 	return (_Move_backward_unchecked1(_First, _Last,

	lea	ecx, DWORD PTR $T6[esp+16]
	push	DWORD PTR $T4[esp+16]
	push	DWORD PTR __Dest$[ebp+8]
	push	eax
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_backward_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	ecx, DWORD PTR $T6[esp+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2677 : 	return (_Move_backward_unchecked1(_First, _Last,

	add	esp, 28					; 0000001cH

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	DWORD PTR __Dest$[ebp+8], ecx
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN60@Move_backw

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN60@Move_backw

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
$LN60@Move_backw:

; 2695 : 	_CHECK_RANIT_RANGE_BACKWARD(_First, _Last, _Dest);
; 2696 : 	return (_Rechecked(_Dest,

	mov	eax, esi

; 2697 : 		_Move_backward_unchecked(_First, _Last, _Unchecked(_Dest))));
; 2698 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ENDP ; std::_Move_backward1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_no_deprecate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
$T2 = -4						; size = 1
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 12
??$_Move_no_deprecate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Move_no_deprecate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2625 : 	{	// move [_First, _Last) to [_Dest, ...), no _SCL_INSECURE_DEPRECATE_FN warnings

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]

; 2626 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2627 : 	return (_Move_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	mov	BYTE PTR $T1[esp+12], 0
	mov	BYTE PTR $T2[esp+12], 0
	push	esi
	mov	esi, ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN78@Move_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN78@Move_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN78@Move_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@Move_no_de
$LN78@Move_no_de:
	xor	eax, eax
$LN26@Move_no_de:

; 2626 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2627 : 	return (_Move_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __Last$[ebp+8]
	push	eax

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN79@Move_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN79@Move_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN79@Move_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN54@Move_no_de
$LN79@Move_no_de:
	xor	eax, eax
$LN54@Move_no_de:

; 2626 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2627 : 	return (_Move_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __First$[ebp+8]
	push	eax
	push	DWORD PTR $T1[esp+32]
	push	DWORD PTR $T2[esp+36]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
	test	eax, eax
	je	SHORT $LN73@Move_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN73@Move_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN73@Move_no_de:
	mov	eax, DWORD PTR __Dest$[ebp+8]
	mov	DWORD PTR [ecx+8], eax

; 2626 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2627 : 	return (_Move_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	mov	ecx, esi
	call	??$_Move_no_deprecate1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Move_no_deprecate1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 36					; 00000024H
	mov	eax, esi

; 2628 : 		_Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
; 2629 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_no_deprecate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Move_no_deprecate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 863  : 		{	// destroy object at _Ptr

	push	esi
	mov	esi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN18@destroy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi+12]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN18@destroy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+32], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+32], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+28], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN106@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+12]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	ret	0
$LN106@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+12], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	ret	0
??$destroy@VErrorInfo@Reader@Json@@@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::destroy<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$allocator@D@std@@@std@@YA$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1052 : 	_Left = _STD move(_Right);
; 1053 : 	}

	ret	0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1039 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YAAAPADAAPAD@Z
_TEXT	SEGMENT
??$forward@AAPAD@std@@YAAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@AAPAD@std@@YAAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	0
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SAXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0VErrorInfo@Reader@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$?0VErrorInfo@Reader@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Reader::ErrorInfo>, COMDAT
; _this$ = ecx

; 710  : 		}

	mov	eax, ecx
	ret	4
??$?0VErrorInfo@Reader@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@VErrorInfo@Reader@Json@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
_TEXT	SEGMENT
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT
; __Al$dead$ = ecx
; __Ptr$dead$ = edx

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	0
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@PAVValue@Json@@@std@@@std@@YA$$QAV?$allocator@PAVValue@Json@@@0@AAV10@@Z
_TEXT	SEGMENT
??$forward@V?$allocator@PAVValue@Json@@@std@@@std@@YA$$QAV?$allocator@PAVValue@Json@@@0@AAV10@@Z PROC ; std::forward<std::allocator<Json::Value *> >, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@V?$allocator@PAVValue@Json@@@std@@@std@@YA$$QAV?$allocator@PAVValue@Json@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0PAVValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$?0PAVValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value *>, COMDAT
; _this$ = ecx

; 710  : 		}

	mov	eax, ecx
	ret	4
??$?0PAVValue@Json@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@PAVValue@Json@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Value *> > >, COMDAT
; __Left$dead$ = ecx
; __Right$dead$ = edx

; 1052 : 	_Left = _STD move(_Right);
; 1053 : 	}

	ret	0
??$_Pocma@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Value *> > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1039 : 	}

	ret	0
??$_Pocca@U?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@@std@@YAXAAU?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z
_TEXT	SEGMENT
??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z PROC ; std::_Unchecked<Json::Value * * *>, COMDAT
; __Src$ = ecx

; 428  : 	return (_Src);

	mov	eax, ecx

; 429  : 	}

	ret	0
??$_Unchecked@PAPAPAVValue@Json@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@@Z ENDP ; std::_Unchecked<Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Al$dead$ = 12						; size = 4
??$_Uninitialized_copy_al_unchecked@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 252  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@PAPAPAVValue@Json@@PAPAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<Json::Value * * *,Json::Value * * *,std::allocator<Json::Value * *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z
_TEXT	SEGMENT
??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z PROC ; std::_Rechecked<Json::Value * * *,Json::Value * * *>, COMDAT
; __Dest$ = ecx
; __Src$ = edx

; 458  : 	_Dest = _Src;

	mov	DWORD PTR [ecx], edx

; 459  : 	return (_Dest);

	mov	eax, ecx

; 460  : 	}

	ret	0
??$_Rechecked@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAAAPAPAPAVValue@Json@@AAPAPAPAV12@PAPAPAV12@@Z ENDP ; std::_Rechecked<Json::Value * * *,Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_default_fill_n1@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Uninitialized_default_fill_n1@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_default_fill_n1<Json::Value * * *,unsigned int,std::allocator<Json::Value * *> >, COMDAT
; __First$ = ecx
; __Count$ = edx

; 471  : 	_CSTD memset(_First, 0, _Count * sizeof(_Iter_value_t<_FwdIt>));

	lea	eax, DWORD PTR [edx*4]
	push	eax
	push	0
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH

; 472  : 	}

	ret	0
??$_Uninitialized_default_fill_n1@PAPAPAVValue@Json@@IV?$allocator@PAPAVValue@Json@@@std@@@std@@YAXPAPAPAVValue@Json@@IAAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_default_fill_n1<Json::Value * * *,unsigned int,std::allocator<Json::Value * *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
___formal$ = 12						; size = 1
??$_Destroy_range1@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Json::Value * *>,Json::Value * * *>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	0
??$_Destroy_range1@V?$allocator@PAPAVValue@Json@@@std@@PAPAPAVValue@Json@@@std@@YAXPAPAPAVValue@Json@@0AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Json::Value * *>,Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 12
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; ___$ReturnUdt$ = ecx

; 661  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR __Iter$[ebp]
	test	eax, eax
	jne	SHORT $LN7@Unchecked
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Iter$[ebp+8]
	mov	DWORD PTR [ecx+4], eax

; 662  : 	return (_Iter._Unchecked());

	mov	eax, ecx

; 663  : 	}

	pop	ebp
	ret	0
$LN7@Unchecked:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Iter$[ebp+8]
	mov	DWORD PTR [ecx+4], eax

; 662  : 	return (_Iter._Unchecked());

	mov	eax, ecx

; 663  : 	}

	pop	ebp
	ret	0
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_backward1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
_TEXT	SEGMENT
$T6 = -12						; size = 8
$T4 = -8						; size = 1
__Dest$ = 8						; size = 12
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
__First$ = 28						; size = 8
__Last$ = 36						; size = 8
??$_Move_backward1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z PROC ; std::_Move_backward1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2694 : 	{	// move [_First, _Last) backwards to [..., _Dest), random-access iterators

	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]

; 2694 : 	{	// move [_First, _Last) backwards to [..., _Dest), random-access iterators

	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN57@Move_backw

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN57@Move_backw

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN57@Move_backw
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@Move_backw
$LN57@Move_backw:
	xor	eax, eax
$LN26@Move_backw:

; 800  : 	return {};

	mov	BYTE PTR $T4[ebp], 0

; 2677 : 	return (_Move_backward_unchecked1(_First, _Last,

	lea	ecx, DWORD PTR $T6[ebp]
	push	DWORD PTR $T4[ebp]
	push	DWORD PTR __Dest$[ebp+8]
	push	eax
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_backward_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	ecx, DWORD PTR $T6[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2677 : 	return (_Move_backward_unchecked1(_First, _Last,

	add	esp, 28					; 0000001cH

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	DWORD PTR __Dest$[ebp+8], ecx
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN60@Move_backw

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN60@Move_backw

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
$LN60@Move_backw:

; 2695 : 	_CHECK_RANIT_RANGE_BACKWARD(_First, _Last, _Dest);
; 2696 : 	return (_Rechecked(_Dest,

	mov	eax, esi

; 2697 : 		_Move_backward_unchecked(_First, _Last, _Unchecked(_Dest))));
; 2698 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ENDP ; std::_Move_backward1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_no_deprecate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -8						; size = 1
$T2 = -4						; size = 1
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 12
??$_Move_no_deprecate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Move_no_deprecate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2625 : 	{	// move [_First, _Last) to [_Dest, ...), no _SCL_INSECURE_DEPRECATE_FN warnings

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Last$[ebp]

; 2626 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2627 : 	return (_Move_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	mov	BYTE PTR $T1[esp+12], 0
	mov	BYTE PTR $T2[esp+12], 0
	push	esi
	mov	esi, ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN78@Move_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN78@Move_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN78@Move_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@Move_no_de
$LN78@Move_no_de:
	xor	eax, eax
$LN26@Move_no_de:

; 2626 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2627 : 	return (_Move_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __Last$[ebp+8]
	push	eax

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __First$[ebp]
	test	eax, eax
	je	SHORT $LN79@Move_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN79@Move_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN79@Move_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN54@Move_no_de
$LN79@Move_no_de:
	xor	eax, eax
$LN54@Move_no_de:

; 2626 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2627 : 	return (_Move_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	push	DWORD PTR __First$[ebp+8]
	push	eax
	push	DWORD PTR $T1[esp+32]
	push	DWORD PTR $T2[esp+36]
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR [ecx], 0

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [ecx+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
	test	eax, eax
	je	SHORT $LN73@Move_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN73@Move_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN73@Move_no_de:
	mov	eax, DWORD PTR __Dest$[ebp+8]
	mov	DWORD PTR [ecx+8], eax

; 2626 : 	_DEBUG_RANGE_PTR(_First, _Last, _Dest);
; 2627 : 	return (_Move_no_deprecate1(_Unchecked(_First), _Unchecked(_Last),

	mov	ecx, esi
	call	??$_Move_no_deprecate1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ; std::_Move_no_deprecate1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 36					; 00000024H
	mov	eax, esi

; 2628 : 		_Dest, _Iter_cat_t<_InIt>(), _Iter_cat_t<_OutIt>()));
; 2629 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_no_deprecate@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Move_no_deprecate<std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@ABQAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVValue@Json@@ABQAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>, COMDAT
; _this$dead$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PAVValue@Json@@ABQAV12@@?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 100  : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN4@sentry

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN4@sentry:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked, COMDAT
; _this$ = ecx

; 584  : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN5@Unchecked
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 49   : 		_Myoff(_Off)

	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 585  : 		return (_Unchecked_type(this->_Myoff, this->_Getcont()));
; 586  : 		}

	pop	ebp
	ret	4
$LN5@Unchecked:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	edx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 49   : 		_Myoff(_Off)

	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 585  : 		return (_Unchecked_type(this->_Myoff, this->_Getcont()));
; 586  : 		}

	pop	ebp
	ret	4
?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??4?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::operator=, COMDAT
; _this$ = ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));
; 964  : 		return (*this);

	mov	eax, ecx

; 965  : 		}

	ret	4
??4?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >, COMDAT
; _this$ = ecx

; 947  : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >::_Wrap_alloc<std::allocator<Json::Reader::ErrorInfo> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 584  : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN5@Unchecked
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 49   : 		_Myoff(_Off)

	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 585  : 		return (_Unchecked_type(this->_Myoff, this->_Getcont()));
; 586  : 		}

	pop	ebp
	ret	4
$LN5@Unchecked:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	edx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 49   : 		_Myoff(_Off)

	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 585  : 		return (_Unchecked_type(this->_Myoff, this->_Getcont()));
; 586  : 		}

	pop	ebp
	ret	4
?_Unchecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??4?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::operator=, COMDAT
; _this$ = ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));
; 964  : 		return (*this);

	mov	eax, ecx

; 965  : 		}

	ret	4
??4?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >, COMDAT
; _this$ = ecx

; 947  : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@PAVValue@Json@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<Json::Value *> >::_Wrap_alloc<std::allocator<Json::Value *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 123  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 124  : 			}

	ret	0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Istr$ = 8						; size = 4
__Noskip$dead$ = 12					; size = 1
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 117  : 			{	// construct locking and calling _Ipfx

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 93   : 			: _Myistr(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	mov	DWORD PTR [esi], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream

; 95   : 			if (_Myistr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN5@sentry

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN5@sentry:

; 97   : 			}
; 98   : 
; 99   : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 100  : 			{	// destroy after unlocking
; 101  : 			if (_Myistr.rdbuf() != 0)
; 102  : 				_Myistr.rdbuf()->_Unlock();
; 103  : 			}
; 104  : 
; 105  : 		_Myt& _Myistr;	// the input stream, for _Unlock call at destruction
; 106  : 
; 107  : 	private:
; 108  : 		_Sentry_base& operator=(const _Sentry_base&);
; 109  : 		};
; 110  : 
; 111  : 	class sentry
; 112  : 		: public _Sentry_base
; 113  : 		{	// stores thread lock and result of _Ipfx call
; 114  : 	public:
; 115  : 		explicit __CLR_OR_THIS_CALL sentry(_Myt& _Istr, bool _Noskip = false)
; 116  : 			: _Sentry_base(_Istr)

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 118  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

	mov	ecx, DWORD PTR [esi]
	push	1
	call	DWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE_N_N@Z
	mov	BYTE PTR [esi+4], al

; 119  : 			}

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 101  : 			if (_Myistr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 102  : 				_Myistr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 103  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));
; 964  : 		return (*this);

	mov	eax, ecx

; 965  : 		}

	ret	4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 947  : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx

; 197  : 		{	// construct with offset _Off

	push	ebp
	mov	ebp, esp

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR __Pdeque$[ebp]
	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 198  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 197  : 		{	// construct with offset _Off

	push	ebp
	mov	ebp, esp

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR __Pdeque$[ebp]
	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 198  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Istr$ = 8						; size = 4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 94   : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 93   : 			: _Myistr(_Istr)

	mov	edx, DWORD PTR __Istr$[ebp]
	push	esi

; 94   : 			{	// lock the stream buffer, if there

	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 95   : 			if (_Myistr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 96   : 				_Myistr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 97   : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct with offset _Off

	push	ebp
	mov	ebp, esp

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR __Pdeque$[ebp]
	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 51   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Pdeque$ = 12						; size = 4
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; _this$ = ecx

; 50   : 		{	// construct with offset _Off

	push	ebp
	mov	ebp, esp

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR __Pdeque$[ebp]
	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Off$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 51   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAE@IPBU_Container_base12@1@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8VErrorInfo@Reader@Json@@V012@@std@@YA_NABV?$allocator@VErrorInfo@Reader@Json@@@0@0@Z
_TEXT	SEGMENT
??$?8VErrorInfo@Reader@Json@@V012@@std@@YA_NABV?$allocator@VErrorInfo@Reader@Json@@@0@0@Z PROC ; std::operator==<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 796  : 	return (true);

	mov	al, 1

; 797  : 	}

	ret	0
??$?8VErrorInfo@Reader@Json@@V012@@std@@YA_NABV?$allocator@VErrorInfo@Reader@Json@@@0@0@Z ENDP ; std::operator==<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 796  : 	return (true);

	mov	al, 1

; 797  : 	}

	ret	0
??$?8DD@std@@YA_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8PAVValue@Json@@PAV01@@std@@YA_NABV?$allocator@PAVValue@Json@@@0@0@Z
_TEXT	SEGMENT
??$?8PAVValue@Json@@PAV01@@std@@YA_NABV?$allocator@PAVValue@Json@@@0@0@Z PROC ; std::operator==<Json::Value *,Json::Value *>, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 796  : 	return (true);

	mov	al, 1

; 797  : 	}

	ret	0
??$?8PAVValue@Json@@PAV01@@std@@YA_NABV?$allocator@PAVValue@Json@@@0@0@Z ENDP ; std::operator==<Json::Value *,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 12
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; ___$ReturnUdt$ = ecx

; 528  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR __Iter$[ebp]
	test	eax, eax
	jne	SHORT $LN7@Unchecked
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Iter$[ebp+8]
	mov	DWORD PTR [ecx+4], eax

; 529  : 	return (_Iter._Unchecked());

	mov	eax, ecx

; 530  : 	}

	pop	ebp
	ret	0
$LN7@Unchecked:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Iter$[ebp+8]
	mov	DWORD PTR [ecx+4], eax

; 529  : 	return (_Iter._Unchecked());

	mov	eax, ecx

; 530  : 	}

	pop	ebp
	ret	0
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 12
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; ___$ReturnUdt$ = ecx

; 528  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR __Iter$[ebp]
	test	eax, eax
	jne	SHORT $LN7@Unchecked
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Iter$[ebp+8]
	mov	DWORD PTR [ecx+4], eax

; 529  : 	return (_Iter._Unchecked());

	mov	eax, ecx

; 530  : 	}

	pop	ebp
	ret	0
$LN7@Unchecked:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	DWORD PTR [ecx], eax

; 49   : 		_Myoff(_Off)

	mov	eax, DWORD PTR __Iter$[ebp+8]
	mov	DWORD PTR [ecx+4], eax

; 529  : 	return (_Iter._Unchecked());

	mov	eax, ecx

; 530  : 	}

	pop	ebp
	ret	0
??$_Unchecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@ABV?$allocator@D@std@@@std@@YAABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$dead$ = 12					; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edi, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edi, edi
	je	SHORT $LN3@construct
	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	lea	ecx, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [edi], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	lea	eax, DWORD PTR [esi+12]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+36], eax
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z$0:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$construct@VErrorInfo@Reader@Json@@ABV123@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@ABV234@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct<Json::Reader::ErrorInfo,Json::Reader::ErrorInfo const &>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN5@construct
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [edx], xmm0
	movups	XMMWORD PTR [edx+16], xmm0
	movq	QWORD PTR [edx+32], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edx+32], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edx+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+12], 0
$LN5@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	ret	0
??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator_traits@V?$allocator@VErrorInfo@Reader@Json@@@std@@@std@@SAXAAV?$allocator@VErrorInfo@Reader@Json@@@1@PAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator_traits<std::allocator<Json::Reader::ErrorInfo> >::construct<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_no_deprecate1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
_TEXT	SEGMENT
$T4 = -8						; size = 8
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 12
___formal$ = 36						; size = 1
___formal$ = 40						; size = 1
??$_Copy_no_deprecate1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z PROC ; std::_Copy_no_deprecate1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2351 : 	{	// copy [_First, _Last) to [_Dest, ...), random-access iterators

	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]

; 2351 : 	{	// copy [_First, _Last) to [_Dest, ...), random-access iterators

	sub	esp, 8
	push	esi
	mov	esi, ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN58@Copy_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN58@Copy_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN58@Copy_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN27@Copy_no_de
$LN58@Copy_no_de:
	xor	eax, eax
$LN27@Copy_no_de:

; 2352 : 	_CHECK_RANIT_RANGE(_First, _Last, _Dest);
; 2353 : 	return (_Rechecked(_Dest,

	push	DWORD PTR __Dest$[ebp+8]
	lea	ecx, DWORD PTR $T4[ebp]
	push	eax
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Copy_unchecked@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ; std::_Copy_unchecked<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	??$_Rechecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@AAV10@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ; std::_Rechecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
	mov	ecx, eax
	mov	DWORD PTR [esi], 0
	add	esp, 32					; 00000020H

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [esi+4], 0

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN54@Copy_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN54@Copy_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
$LN54@Copy_no_de:
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [esi+8], eax

; 2352 : 	_CHECK_RANIT_RANGE(_First, _Last, _Dest);
; 2353 : 	return (_Rechecked(_Dest,

	mov	eax, esi

; 2354 : 		_Copy_unchecked(_First, _Last, _Unchecked(_Dest))));
; 2355 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_no_deprecate1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ENDP ; std::_Copy_no_deprecate1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z PROC ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 3546 : 	{	// reverse elements in [_First, _Last), bidirectional iterators

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	ecx, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3546 : 	{	// reverse elements in [_First, _Last), bidirectional iterators

	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	edi, DWORD PTR __First$[ebp+4]
	cmp	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3547 : 	for (; _First != _Last && _First != --_Last; ++_First)

	je	SHORT $LN3@Reverse_un
	npad	1
$LL4@Reverse_un:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 80   : 		--_Myoff;

	dec	ecx
	mov	DWORD PTR __Last$[ebp+4], ecx

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3547 : 	for (; _First != _Last && _First != --_Last; ++_First)

	je	SHORT $LN3@Reverse_un
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR __Last$[ebp]
	mov	esi, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 23   : 	swap(*_Left, *_Right);

	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	esi
	and	esi, ecx
	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, DWORD PTR [ecx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 23   : 	swap(*_Left, *_Right);

	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 23   : 	swap(*_Left, *_Right);

	mov	edx, DWORD PTR [edx+esi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	and	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 23   : 	swap(*_Left, *_Right);

	mov	ecx, DWORD PTR [ecx+eax*4]
	call	??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ; std::swap<Json::Reader::ErrorInfo,void>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 67   : 		++_Myoff;

	mov	edi, DWORD PTR __First$[ebp+4]

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	ecx, DWORD PTR __Last$[ebp+4]

; 67   : 		++_Myoff;

	inc	edi
	mov	DWORD PTR __First$[ebp+4], edi

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3547 : 	for (; _First != _Last && _First != --_Last; ++_First)

	jne	SHORT $LL4@Reverse_un
$LN3@Reverse_un:

; 3548 : 		_STD iter_swap(_First, _Last);
; 3549 : 	}

	pop	edi
	pop	esi
	pop	ebp
	ret	0
??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ENDP ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rotate_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 8
__Mid$ = 16						; size = 8
__Last$ = 24						; size = 8
??$_Rotate_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Rotate_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 3614 : 	{	// rotate [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	eax, DWORD PTR __Mid$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3614 : 	{	// rotate [_First, _Last)

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	ecx, DWORD PTR __First$[ebp+4]
	cmp	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3615 : 	if (_First == _Mid)

	jne	SHORT $LN2@Rotate_unc

; 3616 : 		return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Last$[ebp+4]
	mov	DWORD PTR [esi+4], eax

; 3619 : 	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));

	mov	eax, esi

; 3620 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@Rotate_unc:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR __Last$[ebp+4]
	cmp	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3617 : 	if (_Mid == _Last)

	jne	SHORT $LN3@Rotate_unc

; 3618 : 		return (_First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi], eax

; 3619 : 	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));

	mov	eax, esi
	mov	DWORD PTR [esi+4], ecx

; 3620 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@Rotate_unc:

; 3619 : 	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));

	push	edx
	push	DWORD PTR __Last$[ebp]
	mov	BYTE PTR $T1[ebp], 0
	push	eax
	push	DWORD PTR __Mid$[ebp]
	push	ecx
	push	DWORD PTR __First$[ebp]
	mov	ecx, esi
	push	DWORD PTR $T1[ebp]
	call	??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 28					; 0000001cH
	mov	eax, esi

; 3620 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Rotate_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$_Rechecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@AAV10@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 8
??$_Rechecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@AAV10@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Rechecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >, COMDAT
; __Iter$ = ecx

; 670  : 	{	// convert to checked

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	eax, DWORD PTR __Right$[ebp+4]
	mov	DWORD PTR [ecx+8], eax

; 671  : 	return (_Iter._Rechecked(_Right));

	mov	eax, ecx

; 672  : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rechecked@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@YAAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@AAV10@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Rechecked<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z PROC ; std::allocator<Json::Value *>::destroy<Json::Value * *>, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAPAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value *>::destroy<Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z PROC ; std::allocator<Json::Value *>::destroy<Json::Value *>, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAVValue@Json@@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@@Z ENDP ; std::allocator<Json::Value *>::destroy<Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_no_deprecate1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
_TEXT	SEGMENT
$T6 = -12						; size = 8
$T4 = -8						; size = 1
__Dest$ = 8						; size = 12
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
__First$ = 28						; size = 8
__Last$ = 36						; size = 8
??$_Copy_no_deprecate1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z PROC ; std::_Copy_no_deprecate1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2351 : 	{	// copy [_First, _Last) to [_Dest, ...), random-access iterators

	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]

; 2351 : 	{	// copy [_First, _Last) to [_Dest, ...), random-access iterators

	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN57@Copy_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN57@Copy_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN57@Copy_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@Copy_no_de
$LN57@Copy_no_de:
	xor	eax, eax
$LN26@Copy_no_de:

; 783  : 	return {};

	mov	BYTE PTR $T4[ebp], 0

; 2334 : 	return (_Copy_unchecked1(_First, _Last,

	lea	ecx, DWORD PTR $T6[ebp]
	push	DWORD PTR $T4[ebp]
	push	DWORD PTR __Dest$[ebp+8]
	push	eax
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Copy_unchecked1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	ecx, DWORD PTR $T6[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2334 : 	return (_Copy_unchecked1(_First, _Last,

	add	esp, 28					; 0000001cH

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	DWORD PTR __Dest$[ebp+8], ecx
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN60@Copy_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN60@Copy_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
$LN60@Copy_no_de:

; 2352 : 	_CHECK_RANIT_RANGE(_First, _Last, _Dest);
; 2353 : 	return (_Rechecked(_Dest,

	mov	eax, esi

; 2354 : 		_Copy_unchecked(_First, _Last, _Unchecked(_Dest))));
; 2355 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_no_deprecate1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ENDP ; std::_Copy_no_deprecate1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z PROC ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 3546 : 	{	// reverse elements in [_First, _Last), bidirectional iterators

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	esi, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3546 : 	{	// reverse elements in [_First, _Last), bidirectional iterators

	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	edi, DWORD PTR __First$[ebp+4]
	cmp	edi, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3547 : 	for (; _First != _Last && _First != --_Last; ++_First)

	je	SHORT $LN3@Reverse_un
	npad	1
$LL4@Reverse_un:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 80   : 		--_Myoff;

	dec	esi
	mov	DWORD PTR __Last$[ebp+4], esi

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	edi, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3547 : 	for (; _First != _Last && _First != --_Last; ++_First)

	je	SHORT $LN3@Reverse_un
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	eax, esi
	shr	eax, 2

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
	dec	edx
	and	edx, eax

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [ecx+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR __First$[ebp]

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+edx*4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
	dec	edx

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	lea	esi, DWORD PTR [eax+esi*4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, edi
	shr	eax, 2

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edi, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	and	edx, eax

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 49   : 	_Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [eax+edi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	lea	edx, DWORD PTR [eax+edi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 50   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx], eax

; 51   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [esi], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 67   : 		++_Myoff;

	mov	edi, DWORD PTR __First$[ebp+4]

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	esi, DWORD PTR __Last$[ebp+4]

; 67   : 		++_Myoff;

	inc	edi
	mov	DWORD PTR __First$[ebp+4], edi

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	edi, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3547 : 	for (; _First != _Last && _First != --_Last; ++_First)

	jne	SHORT $LL4@Reverse_un
$LN3@Reverse_un:

; 3548 : 		_STD iter_swap(_First, _Last);
; 3549 : 	}

	pop	edi
	pop	esi
	pop	ebp
	ret	0
??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ENDP ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rotate_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 8
__Mid$ = 16						; size = 8
__Last$ = 24						; size = 8
??$_Rotate_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Rotate_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 3614 : 	{	// rotate [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	eax, DWORD PTR __Mid$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3614 : 	{	// rotate [_First, _Last)

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	ecx, DWORD PTR __First$[ebp+4]
	cmp	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3615 : 	if (_First == _Mid)

	jne	SHORT $LN2@Rotate_unc

; 3616 : 		return (_Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR __Last$[ebp+4]
	mov	DWORD PTR [esi+4], eax

; 3619 : 	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));

	mov	eax, esi

; 3620 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN2@Rotate_unc:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR __Last$[ebp+4]
	cmp	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3617 : 	if (_Mid == _Last)

	jne	SHORT $LN3@Rotate_unc

; 3618 : 		return (_First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR [esi], eax

; 3619 : 	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));

	mov	eax, esi
	mov	DWORD PTR [esi+4], ecx

; 3620 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@Rotate_unc:

; 3619 : 	return (_Rotate_unchecked1(_First, _Mid, _Last, _Iter_cat_t<_FwdIt>()));

	push	edx
	push	DWORD PTR __Last$[ebp]
	mov	BYTE PTR $T1[ebp], 0
	push	eax
	push	DWORD PTR __Mid$[ebp]
	push	ecx
	push	DWORD PTR __First$[ebp]
	mov	ecx, esi
	push	DWORD PTR $T1[ebp]
	call	??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z ; std::_Rotate_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 28					; 0000001cH
	mov	eax, esi

; 3620 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rotate_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Rotate_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??$_Rechecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YAAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@AAV10@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 8
??$_Rechecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YAAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@AAV10@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Rechecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >, COMDAT
; __Iter$ = ecx

; 670  : 	{	// convert to checked

	push	ebp
	mov	ebp, esp

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	eax, DWORD PTR __Right$[ebp+4]
	mov	DWORD PTR [ecx+8], eax

; 671  : 	return (_Iter._Rechecked(_Right));

	mov	eax, ecx

; 672  : 	}

	pop	ebp
	ret	0
??$_Rechecked@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@YAAAV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@AAV10@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Rechecked<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z PROC ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value *>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PAVValue@Json@@PAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@$$QAPAV23@@Z ENDP ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVValue@Json@@@std@@YAABQAVValue@Json@@ABQAV12@@Z
_TEXT	SEGMENT
??$forward@ABQAVValue@Json@@@std@@YAABQAVValue@Json@@ABQAV12@@Z PROC ; std::forward<Json::Value * const &>, COMDAT
; __Arg$ = ecx

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, ecx

; 1277 : 	}

	ret	0
??$forward@ABQAVValue@Json@@@std@@YAABQAVValue@Json@@ABQAV12@@Z ENDP ; std::forward<Json::Value * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo *>, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAVErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_copy_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@0@Z PROC ; std::_Ptr_copy_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 793  : 	return {};

	mov	eax, ecx

; 794  : 	}

	ret	0
??$_Ptr_copy_cat@PAVErrorInfo@Reader@Json@@PAV123@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAVErrorInfo@Reader@Json@@0@Z ENDP ; std::_Ptr_copy_cat<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@PAVErrorInfo@Reader@Json@@PAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_copy_al_unchecked1@PAVErrorInfo@Reader@Json@@PAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 239  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 239  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 241  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked1@PAVErrorInfo@Reader@Json@@PAV123@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00AAU?$_Wrap_alloc@V?$allocator@PAVErrorInfo@Reader@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<Json::Reader::ErrorInfo *,Json::Reader::ErrorInfo *,std::allocator<Json::Reader::ErrorInfo *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_backward_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
??$_Move_backward_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Move_backward_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2676 : 	{	// move [_First, _Last) backwards to [..., _Dest), choose optimization

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 800  : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2676 : 	{	// move [_First, _Last) backwards to [..., _Dest), choose optimization

	mov	esi, ecx

; 2677 : 	return (_Move_backward_unchecked1(_First, _Last,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_backward_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 28					; 0000001cH
	mov	eax, esi

; 2678 : 		_Dest, _Ptr_move_cat(_First, _Dest)));
; 2679 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Move_backward_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_no_deprecate1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
_TEXT	SEGMENT
$T4 = -8						; size = 1
$T6 = -8						; size = 8
__Dest$ = 8						; size = 12
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
__First$ = 28						; size = 8
__Last$ = 36						; size = 8
??$_Move_no_deprecate1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z PROC ; std::_Move_no_deprecate1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2615 : 	{	// move [_First, _Last) to [_Dest, ...), random-access iterators

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]

; 2615 : 	{	// move [_First, _Last) to [_Dest, ...), random-access iterators

	sub	esp, 12					; 0000000cH
	push	esi
	mov	esi, ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN57@Move_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN57@Move_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN57@Move_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@Move_no_de
$LN57@Move_no_de:
	xor	eax, eax
$LN26@Move_no_de:

; 800  : 	return {};

	mov	BYTE PTR $T4[esp+16], 0

; 2598 : 	return (_Move_unchecked1(_First, _Last,

	lea	ecx, DWORD PTR $T6[esp+16]
	push	DWORD PTR $T4[esp+16]
	push	DWORD PTR __Dest$[ebp+8]
	push	eax
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	ecx, DWORD PTR $T6[esp+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2598 : 	return (_Move_unchecked1(_First, _Last,

	add	esp, 28					; 0000001cH

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	DWORD PTR __Dest$[ebp+8], ecx
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN60@Move_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN60@Move_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
$LN60@Move_no_de:

; 2616 : 	_CHECK_RANIT_RANGE(_First, _Last, _Dest);
; 2617 : 	return (_Rechecked(_Dest,

	mov	eax, esi

; 2618 : 		_Move_unchecked(_First, _Last, _Unchecked(_Dest))));
; 2619 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_no_deprecate1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ENDP ; std::_Move_no_deprecate1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo>, COMDAT
; _this$dead$ = ecx

; 743  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN16@destroy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi+12]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN16@destroy:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+32], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+32], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+28], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN104@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+12]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	pop	ebp
	ret	4
$LN104@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+12], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	pop	ebp
	ret	4
??$destroy@VErrorInfo@Reader@Json@@@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::destroy<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$dead$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edx, DWORD PTR __Ptr$[ebp]
	test	edx, edx
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAPAVValue@Json@@0@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
??$_Ptr_copy_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAPAVValue@Json@@0@Z PROC ; std::_Ptr_copy_cat<Json::Value * *,Json::Value * *>, COMDAT
; ___$ReturnUdt$ = ecx
; ___formal$dead$ = edx

; 793  : 	return {};

	mov	eax, ecx

; 794  : 	}

	ret	0
??$_Ptr_copy_cat@PAPAVValue@Json@@PAPAV12@@std@@YA?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAPAVValue@Json@@0@Z ENDP ; std::_Ptr_copy_cat<Json::Value * *,Json::Value * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@PAPAVValue@Json@@PAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
___formal$dead$ = 12					; size = 4
___formal$ = 16						; size = 1
___formal$ = 20						; size = 1
??$_Uninitialized_copy_al_unchecked1@PAPAVValue@Json@@PAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<Json::Value * *,Json::Value * *,std::allocator<Json::Value * *> >, COMDAT
; __First$ = ecx
; __Last$ = edx

; 239  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 239  : 	{	// copy [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	mov	edi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	sub	edi, ecx

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 241  : 	}

	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked1@PAPAVValue@Json@@PAPAV12@V?$allocator@PAPAVValue@Json@@@std@@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00AAU?$_Wrap_alloc@V?$allocator@PAPAVValue@Json@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<Json::Value * *,Json::Value * *,std::allocator<Json::Value * *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_backward_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
??$_Move_backward_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Move_backward_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2676 : 	{	// move [_First, _Last) backwards to [..., _Dest), choose optimization

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 800  : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2676 : 	{	// move [_First, _Last) backwards to [..., _Dest), choose optimization

	mov	esi, ecx

; 2677 : 	return (_Move_backward_unchecked1(_First, _Last,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_backward_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 28					; 0000001cH
	mov	eax, esi

; 2678 : 		_Dest, _Ptr_move_cat(_First, _Dest)));
; 2679 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_backward_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Move_backward_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_no_deprecate1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z
_TEXT	SEGMENT
$T6 = -12						; size = 8
$T4 = -8						; size = 1
__Dest$ = 8						; size = 12
___formal$ = 20						; size = 1
___formal$ = 24						; size = 1
__First$ = 28						; size = 8
__Last$ = 36						; size = 8
??$_Move_no_deprecate1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z PROC ; std::_Move_no_deprecate1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2615 : 	{	// move [_First, _Last) to [_Dest, ...), random-access iterators

	push	ebp
	mov	ebp, esp

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]

; 2615 : 	{	// move [_First, _Last) to [_Dest, ...), random-access iterators

	sub	esp, 16					; 00000010H
	push	esi
	mov	esi, ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN57@Move_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN57@Move_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	test	eax, eax
	je	SHORT $LN57@Move_no_de
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN26@Move_no_de
$LN57@Move_no_de:
	xor	eax, eax
$LN26@Move_no_de:

; 800  : 	return {};

	mov	BYTE PTR $T4[ebp], 0

; 2598 : 	return (_Move_unchecked1(_First, _Last,

	lea	ecx, DWORD PTR $T6[ebp]
	push	DWORD PTR $T4[ebp]
	push	DWORD PTR __Dest$[ebp+8]
	push	eax
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	ecx, DWORD PTR $T6[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2598 : 	return (_Move_unchecked1(_First, _Last,

	add	esp, 28					; 0000001cH

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	DWORD PTR __Dest$[ebp+8], ecx
	mov	DWORD PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	DWORD PTR [esi+4], 0
	mov	DWORD PTR [esi+8], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	test	eax, eax
	je	SHORT $LN60@Move_no_de

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)
; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR [eax]

; 150  : 		if (_Parent == 0)

	test	eax, eax
	je	SHORT $LN60@Move_no_de

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);
; 154  : 			_Orphan_me();
; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}
; 157  : 		else
; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;
; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)
; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);
; 165  : 				_Orphan_me();
; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;
; 167  : 				_Parent_proxy->_Myfirstiter = this;
; 168  : 				_Myproxy = _Parent_proxy;
; 169  : 				}
; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
$LN60@Move_no_de:

; 2616 : 	_CHECK_RANIT_RANGE(_First, _Last, _Dest);
; 2617 : 	return (_Rechecked(_Dest,

	mov	eax, esi

; 2618 : 		_Move_unchecked(_First, _Last, _Unchecked(_Dest))));
; 2619 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_no_deprecate1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@Urandom_access_iterator_tag@0@2@Z ENDP ; std::_Move_no_deprecate1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@ABQAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@ABQAV34@@Z
_TEXT	SEGMENT
_<_Args_0>$ = 8						; size = 4
??$construct@PAVValue@Json@@ABQAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@ABQAV34@@Z PROC ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>, COMDAT
; __Al$dead$ = ecx
; __Ptr$ = edx

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	0
??$construct@PAVValue@Json@@ABQAV12@@?$allocator_traits@V?$allocator@PAVValue@Json@@@std@@@std@@SAXAAV?$allocator@PAVValue@Json@@@1@PAPAVValue@Json@@ABQAV34@@Z ENDP ; std::allocator_traits<std::allocator<Json::Value *> >::construct<Json::Value *,Json::Value * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
___that$ = 8						; size = 4
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z PROC		; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	push	edi
	mov	edi, ecx

; 782  : 		assign(_Right, 0, npos);

	push	-1
	movq	xmm0, QWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+12]
	push	0
	movq	QWORD PTR [edi], xmm0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	lea	eax, DWORD PTR [esi+12]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
	mov	DWORD PTR _this$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+36], eax
	mov	eax, edi
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0ErrorInfo@Reader@Json@@QAE@ABV012@@Z ENDP		; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??_GErrorInfo@Reader@Json@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$dead$ = 8					; size = 4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z PROC		; Json::Reader::ErrorInfo::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN13@scalar

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi+12]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN13@scalar:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+32], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+32], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+28], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN101@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
	mov	eax, esi
	pop	esi
	ret	4
$LN101@scalar:
	mov	BYTE PTR [esi+12], 0
	mov	eax, esi
	pop	esi
	ret	4
??_GErrorInfo@Reader@Json@@QAEPAXI@Z ENDP		; Json::Reader::ErrorInfo::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--, COMDAT
; _this$ = ecx

; 80   : 		--_Myoff;

	dec	DWORD PTR [ecx+4]

; 225  : 		--*(_Mybase *)this;
; 226  : 		return (*this);

	mov	eax, ecx

; 227  : 		}

	ret	0
??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++, COMDAT
; _this$ = ecx

; 67   : 		++_Myoff;

	inc	DWORD PTR [ecx+4]

; 212  : 		++*(_Mybase *)this;
; 213  : 		return (*this);

	mov	eax, ecx

; 214  : 		}

	ret	0
??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=, COMDAT
; _this$ = ecx

; 132  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	setne	al

; 133  : 		return (!(*this == _Right));
; 134  : 		}

	pop	ebp
	ret	4
??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==, COMDAT
; _this$ = ecx

; 127  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	sete	al

; 128  : 		return (_Myoff == _Right._Myoff);
; 129  : 		}

	pop	ebp
	ret	4
??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--, COMDAT
; _this$ = ecx

; 80   : 		--_Myoff;

	dec	DWORD PTR [ecx+4]

; 225  : 		--*(_Mybase *)this;
; 226  : 		return (*this);

	mov	eax, ecx

; 227  : 		}

	ret	0
??F?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++, COMDAT
; _this$ = ecx

; 67   : 		++_Myoff;

	inc	DWORD PTR [ecx+4]

; 212  : 		++*(_Mybase *)this;
; 213  : 		return (*this);

	mov	eax, ecx

; 214  : 		}

	ret	0
??E?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=, COMDAT
; _this$ = ecx

; 132  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	setne	al

; 133  : 		return (!(*this == _Right));
; 134  : 		}

	pop	ebp
	ret	4
??9?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==, COMDAT
; _this$ = ecx

; 127  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	cmp	ecx, DWORD PTR [eax+4]
	sete	al

; 128  : 		return (_Myoff == _Right._Myoff);
; 129  : 		}

	pop	ebp
	ret	4
??8?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked, COMDAT
; _this$ = ecx

; 317  : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN5@Unchecked
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 49   : 		_Myoff(_Off)

	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 318  : 		return (_Unchecked_type(_Myoff, this->_Getcont()));
; 319  : 		}

	pop	ebp
	ret	4
$LN5@Unchecked:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	edx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 49   : 		_Myoff(_Off)

	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 318  : 		return (_Unchecked_type(_Myoff, this->_Getcont()));
; 319  : 		}

	pop	ebp
	ret	4
?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Rechecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV12@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 8
?_Rechecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV12@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Rechecked, COMDAT
; _this$ = ecx

; 578  : 		{	// reset from unchecked iterator

	push	ebp
	mov	ebp, esp

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	eax, DWORD PTR __Right$[ebp+4]
	mov	DWORD PTR [ecx+8], eax

; 580  : 		return (*this);

	mov	eax, ecx

; 581  : 		}

	pop	ebp
	ret	8
?_Rechecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV12@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ PROC ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked, COMDAT
; _this$ = ecx

; 317  : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	jne	SHORT $LN5@Unchecked
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 49   : 		_Myoff(_Off)

	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 318  : 		return (_Unchecked_type(_Myoff, this->_Getcont()));
; 319  : 		}

	pop	ebp
	ret	4
$LN5@Unchecked:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	edx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 48   : 		: _Mycont(static_cast<const _Mydeque *>(_Pdeque)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 49   : 		_Myoff(_Off)

	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 318  : 		return (_Unchecked_type(_Myoff, this->_Getcont()));
; 319  : 		}

	pop	ebp
	ret	4
?_Unchecked@?$_Deque_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@XZ ENDP ; std::_Deque_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ?_Rechecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV12@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 8
?_Rechecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV12@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z PROC ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Rechecked, COMDAT
; _this$ = ecx

; 578  : 		{	// reset from unchecked iterator

	push	ebp
	mov	ebp, esp

; 579  : 		this->_Myoff = _Right._Myoff;

	mov	eax, DWORD PTR __Right$[ebp+4]
	mov	DWORD PTR [ecx+8], eax

; 580  : 		return (*this);

	mov	eax, ecx

; 581  : 		}

	pop	ebp
	ret	8
?_Rechecked@?$_Deque_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV12@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@Z ENDP ; std::_Deque_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--, COMDAT
; _this$ = ecx

; 80   : 		--_Myoff;

	dec	DWORD PTR [ecx+4]

; 81   : 		return (*this);

	mov	eax, ecx

; 82   : 		}

	ret	0
??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++, COMDAT
; _this$ = ecx

; 67   : 		++_Myoff;

	inc	DWORD PTR [ecx+4]

; 68   : 		return (*this);

	mov	eax, ecx

; 69   : 		}

	ret	0
??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--, COMDAT
; _this$ = ecx

; 80   : 		--_Myoff;

	dec	DWORD PTR [ecx+4]

; 81   : 		return (*this);

	mov	eax, ecx

; 82   : 		}

	ret	0
??F?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++, COMDAT
; _this$ = ecx

; 67   : 		++_Myoff;

	inc	DWORD PTR [ecx+4]

; 68   : 		return (*this);

	mov	eax, ecx

; 69   : 		}

	ret	0
??E?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$dead$ = 8					; size = 4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z PROC ; std::allocator<Json::Reader::ErrorInfo>::construct<Json::Reader::ErrorInfo>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	eax, eax
	je	SHORT $LN3@construct
	xorps	xmm0, xmm0
	movups	XMMWORD PTR [eax], xmm0
	movups	XMMWORD PTR [eax+16], xmm0
	movq	QWORD PTR [eax+32], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+32], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+12], 0
$LN3@construct:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	pop	ebp
	ret	4
??$construct@VErrorInfo@Reader@Json@@$$V@?$allocator@VErrorInfo@Reader@Json@@@std@@QAEXPAVErrorInfo@Reader@Json@@@Z ENDP ; std::allocator<Json::Reader::ErrorInfo>::construct<Json::Reader::ErrorInfo>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_unchecked@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
??$_Copy_unchecked@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z PROC ; std::_Copy_unchecked<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2332 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	esi

; 783  : 	return {};

	mov	BYTE PTR $T1[esp+8], 0

; 2332 : 	{	// copy [_First, _Last) to [_Dest, ...)

	mov	esi, ecx

; 2333 : 		// note: _Copy_unchecked is called directly elsewhere in the STL
; 2334 : 	return (_Copy_unchecked1(_First, _Last,

	push	DWORD PTR $T1[esp+8]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Copy_unchecked1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 28					; 0000001cH
	mov	eax, esi

; 2335 : 		_Dest, _Ptr_copy_cat(_First, _Dest)));
; 2336 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_unchecked@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@@Z ENDP ; std::_Copy_unchecked<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 8
__Right$ = 16						; size = 8
??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT

; 22   : 	{	// swap *_Left and *_Right

	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR __Left$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 22   : 	{	// swap *_Left and *_Right

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 23   : 	swap(*_Left, *_Right);

	mov	edx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	esi
	mov	eax, DWORD PTR [ecx+8]
	and	esi, DWORD PTR __Right$[ebp+4]
	dec	eax
	and	eax, DWORD PTR __Left$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 23   : 	swap(*_Left, *_Right);

	mov	ecx, DWORD PTR [ecx+4]
	mov	edx, DWORD PTR [edx+esi*4]
	mov	ecx, DWORD PTR [ecx+eax*4]
	call	??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ; std::swap<Json::Reader::ErrorInfo,void>

; 24   : 	}

	pop	esi
	pop	ecx
	pop	ebp
	ret	0
??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__First$ = 12						; size = 8
__Mid$ = 20						; size = 8
__Last$ = 28						; size = 8
??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 3605 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 3606 : 	_Reverse_unchecked(_First, _Mid);

	push	DWORD PTR __Mid$[ebp+4]
	mov	edi, ecx
	push	DWORD PTR __Mid$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >

; 3607 : 	_Reverse_unchecked(_Mid, _Last);

	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __Mid$[ebp+4]
	push	DWORD PTR __Mid$[ebp]
	call	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >

; 3608 : 	_Reverse_unchecked(_First, _Last);

	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 116  : 		return (_Right._Myoff <= _Myoff

	mov	ecx, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3608 : 	_Reverse_unchecked(_First, _Last);

	add	esp, 48					; 00000030H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 116  : 		return (_Right._Myoff <= _Myoff

	mov	eax, DWORD PTR __Mid$[ebp+4]
	mov	edx, ecx
	sub	edx, eax
	mov	esi, ecx
	sub	esi, eax
	cmp	eax, ecx

; 244  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR __First$[ebp+4]
	mov	ecx, DWORD PTR __First$[ebp]
	cmovbe	esi, edx

; 93   : 		_Myoff += _Off;

	add	eax, esi

; 245  : 		return (_Tmp += _Off);

	mov	DWORD PTR [edi], ecx
	mov	DWORD PTR [edi+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3609 : 	return (_First + (_Last - _Mid));

	mov	eax, edi

; 3610 : 	}

	pop	edi
	pop	esi
	pop	ecx
	pop	ebp
	ret	0
??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_unchecked@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
??$_Copy_unchecked@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z PROC ; std::_Copy_unchecked<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2332 : 	{	// copy [_First, _Last) to [_Dest, ...)

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 783  : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2332 : 	{	// copy [_First, _Last) to [_Dest, ...)

	mov	esi, ecx

; 2333 : 		// note: _Copy_unchecked is called directly elsewhere in the STL
; 2334 : 	return (_Copy_unchecked1(_First, _Last,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Copy_unchecked1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U_General_ptr_iterator_tag@0@@Z ; std::_Copy_unchecked1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 28					; 0000001cH
	mov	eax, esi

; 2335 : 		_Dest, _Ptr_copy_cat(_First, _Dest)));
; 2336 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_unchecked@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@@Z ENDP ; std::_Copy_unchecked<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 8
__Right$ = 16						; size = 8
??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z PROC ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT

; 22   : 	{	// swap *_Left and *_Right

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, DWORD PTR __Right$[ebp+4]
	mov	edx, esi
	shr	edx, 2

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx+8]
	dec	eax
	and	edx, eax

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [ecx+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR __Left$[ebp]
	push	edi

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+edx*4]
	lea	edi, DWORD PTR [eax+esi*4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR __Left$[ebp+4]
	mov	eax, DWORD PTR [ecx+8]
	mov	edx, esi
	dec	eax
	shr	edx, 2
	and	edx, eax

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [ecx+4]
	and	esi, 3
	mov	eax, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 49   : 	_Ty _Tmp = _STD move(_Left);

	mov	ecx, DWORD PTR [eax+esi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	lea	edx, DWORD PTR [eax+esi*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 50   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edx], eax

; 51   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [edi], ecx
	pop	edi
	pop	esi

; 23   : 	swap(*_Left, *_Right);
; 24   : 	}

	pop	ebp
	ret	0
??$iter_swap@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ENDP ; std::iter_swap<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__First$ = 12						; size = 8
__Mid$ = 20						; size = 8
__Last$ = 28						; size = 8
??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z PROC ; std::_Rotate_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 3605 : 	{	// rotate [_First, _Last), random-access iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi

; 3606 : 	_Reverse_unchecked(_First, _Mid);

	push	DWORD PTR __Mid$[ebp+4]
	mov	edi, ecx
	push	DWORD PTR __Mid$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >

; 3607 : 	_Reverse_unchecked(_Mid, _Last);

	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __Mid$[ebp+4]
	push	DWORD PTR __Mid$[ebp]
	call	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >

; 3608 : 	_Reverse_unchecked(_First, _Last);

	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Reverse_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YAXV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ; std::_Reverse_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 116  : 		return (_Right._Myoff <= _Myoff

	mov	ecx, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3608 : 	_Reverse_unchecked(_First, _Last);

	add	esp, 48					; 00000030H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 116  : 		return (_Right._Myoff <= _Myoff

	mov	eax, DWORD PTR __Mid$[ebp+4]
	mov	edx, ecx
	sub	edx, eax
	mov	esi, ecx
	sub	esi, eax
	cmp	eax, ecx

; 244  : 		_Myiter _Tmp = *this;

	mov	eax, DWORD PTR __First$[ebp+4]
	mov	ecx, DWORD PTR __First$[ebp]
	cmovbe	esi, edx

; 93   : 		_Myoff += _Off;

	add	eax, esi

; 245  : 		return (_Tmp += _Off);

	mov	DWORD PTR [edi], ecx
	mov	DWORD PTR [edi+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 3609 : 	return (_First + (_Last - _Mid));

	mov	eax, edi

; 3610 : 	}

	pop	edi
	pop	esi
	pop	ecx
	pop	ebp
	ret	0
??$_Rotate_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00Urandom_access_iterator_tag@0@@Z ENDP ; std::_Rotate_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00@Z PROC ; std::_Copy_memmove<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2301 : 	{	// implement copy-like function as memmove

	push	ebp
	mov	ebp, esp
	push	esi

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;
; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2308 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PAPAVErrorInfo@Reader@Json@@PAPAV123@@std@@YAPAPAVErrorInfo@Reader@Json@@PAPAV123@00@Z ENDP ; std::_Copy_memmove<Json::Reader::ErrorInfo * *,Json::Reader::ErrorInfo * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Ptr_move_cat@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z PROC ; std::_Ptr_move_cat<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 800  : 	return {};

	xor	al, al

; 801  : 	}

	ret	0
??$_Ptr_move_cat@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0@Z ENDP ; std::_Ptr_move_cat<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
___formal$ = 32						; size = 1
??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2658 : 	{	// move [_First, _Last) backwards to [..., _Dest), no special optimization

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR ___$ReturnUdt$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR __Last$[ebp+4]
	cmp	DWORD PTR __First$[ebp+4], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2659 : 	while (_First != _Last)

	je	$LN3@Move_backw
$LL2@Move_backw:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR __Last$[ebp]

; 80   : 		--_Myoff;

	dec	edx
	mov	DWORD PTR __Last$[ebp+4], edx

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, edx

; 80   : 		--_Myoff;

	mov	edx, DWORD PTR __Dest$[ebp+4]
	dec	edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	edi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR __Dest$[ebp]

; 80   : 		--_Myoff;

	mov	DWORD PTR __Dest$[ebp+4], edx
	movq	xmm0, QWORD PTR [edi]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2660 : 		*--_Dest = _STD move(*--_Last);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2660 : 		*--_Dest = _STD move(*--_Last);

	mov	ebx, DWORD PTR [eax+ecx*4]
	lea	ecx, DWORD PTR [edi+12]
	movq	QWORD PTR [ebx], xmm0
	lea	esi, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ebx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 929  : 		if (this != &_Right)

	cmp	esi, ecx
	je	SHORT $LN39@Move_backw

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN45@Move_backw

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
	lea	ecx, DWORD PTR [edi+12]
$LN45@Move_backw:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN133@Move_backw
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN134@Move_backw
$LN133@Move_backw:
	mov	eax, esi
$LN134@Move_backw:

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	push	ecx
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN39@Move_backw:
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [ebx+36], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR __Last$[ebp+4]
	cmp	DWORD PTR __First$[ebp+4], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2659 : 	while (_First != _Last)

	jne	$LL2@Move_backw
	mov	ecx, DWORD PTR ___$ReturnUdt$1$[ebp]
$LN3@Move_backw:

; 2661 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, ecx

; 2662 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
??$_Move_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Move_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2597 : 	{	// move [_First, _Last) to [_Dest, ...), choose optimization

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 800  : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2597 : 	{	// move [_First, _Last) to [_Dest, ...), choose optimization

	mov	esi, ecx

; 2598 : 	return (_Move_unchecked1(_First, _Last,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
	add	esp, 28					; 0000001cH
	mov	eax, esi

; 2599 : 		_Dest, _Ptr_move_cat(_First, _Dest)));
; 2600 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Move_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
??$_Copy_memmove@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00@Z PROC ; std::_Copy_memmove<Json::Value * * *,Json::Value * * *>, COMDAT
; __First$ = ecx
; __Last$ = edx

; 2301 : 	{	// implement copy-like function as memmove

	push	ebp
	mov	ebp, esp
	push	esi

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;
; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, edx
	sub	edi, ecx
	push	edi
	push	ecx
	push	esi
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2308 : 	}

	pop	ebp
	ret	0
??$_Copy_memmove@PAPAPAVValue@Json@@PAPAPAV12@@std@@YAPAPAPAVValue@Json@@PAPAPAV12@00@Z ENDP ; std::_Copy_memmove<Json::Value * * *,Json::Value * * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
??$_Ptr_move_cat@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z PROC ; std::_Ptr_move_cat<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 800  : 	return {};

	xor	al, al

; 801  : 	}

	ret	0
??$_Ptr_move_cat@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0@Z ENDP ; std::_Ptr_move_cat<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
___formal$ = 32						; size = 1
??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Move_backward_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2658 : 	{	// move [_First, _Last) backwards to [..., _Dest), no special optimization

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	esi, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2658 : 	{	// move [_First, _Last) backwards to [..., _Dest), no special optimization

	mov	ebx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	DWORD PTR __First$[ebp+4], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2659 : 	while (_First != _Last)

	je	SHORT $LN3@Move_backw
	push	edi
$LL2@Move_backw:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR __Last$[ebp]

; 80   : 		--_Myoff;

	dec	esi
	mov	DWORD PTR __Last$[ebp+4], esi

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, esi
	shr	eax, 2

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
	dec	edx
	and	edx, eax

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [ecx+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR __Dest$[ebp]

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+edx*4]
	lea	edi, DWORD PTR [eax+esi*4]

; 80   : 		--_Myoff;

	mov	esi, DWORD PTR __Dest$[ebp+4]
	dec	esi
	mov	DWORD PTR __Dest$[ebp+4], esi

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, esi
	mov	edx, DWORD PTR [ecx+8]

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2660 : 		*--_Dest = _STD move(*--_Last);

	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	edx
	shr	eax, 2
	and	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2660 : 		*--_Dest = _STD move(*--_Last);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+esi*4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	esi, DWORD PTR __Last$[ebp+4]
	cmp	DWORD PTR __First$[ebp+4], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2659 : 	while (_First != _Last)

	jne	SHORT $LL2@Move_backw
	pop	edi
$LN3@Move_backw:

; 2661 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR [ebx+4], eax
	mov	eax, ebx
	pop	esi
	pop	ebx

; 2662 : 	}

	pop	ebp
	ret	0
??$_Move_backward_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Move_backward_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z
_TEXT	SEGMENT
$T1 = -4						; size = 1
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
??$_Move_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z PROC ; std::_Move_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2597 : 	{	// move [_First, _Last) to [_Dest, ...), choose optimization

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 800  : 	return {};

	mov	BYTE PTR $T1[ebp], 0

; 2597 : 	{	// move [_First, _Last) to [_Dest, ...), choose optimization

	mov	esi, ecx

; 2598 : 	return (_Move_unchecked1(_First, _Last,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Dest$[ebp+4]
	push	DWORD PTR __Dest$[ebp]
	push	DWORD PTR __Last$[ebp+4]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp+4]
	push	DWORD PTR __First$[ebp]
	call	??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
	add	esp, 28					; 0000001cH
	mov	eax, esi

; 2599 : 		_Dest, _Ptr_move_cat(_First, _Dest)));
; 2600 : 	}

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_unchecked@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00@Z ENDP ; std::_Move_unchecked<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVValue@Json@@ABQAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVValue@Json@@ABQAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z PROC ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value * const &>, COMDAT
; _this$dead$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PAVValue@Json@@ABQAV12@@?$allocator@PAVValue@Json@@@std@@QAEXPAPAVValue@Json@@ABQAV23@@Z ENDP ; std::allocator<Json::Value *>::construct<Json::Value *,Json::Value * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___that$ = 8						; size = 4
??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z PROC	; Json::Reader::ErrorInfo::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebx, DWORD PTR ___that$[ebp]
	lea	esi, DWORD PTR [edi+12]
	movq	xmm0, QWORD PTR [ebx]
	lea	ecx, DWORD PTR [ebx+12]
	movq	QWORD PTR [edi], xmm0
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [edi+8], eax

; 929  : 		if (this != &_Right)

	cmp	esi, ecx
	je	SHORT $LN7@operator

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN13@operator

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
	lea	ecx, DWORD PTR [ebx+12]
$LN13@operator:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN101@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN102@operator
$LN101@operator:
	mov	eax, esi
$LN102@operator:

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	push	ecx
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN7@operator:
	mov	eax, DWORD PTR [ebx+36]
	mov	DWORD PTR [edi+36], eax
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4ErrorInfo@Reader@Json@@QAEAAV012@$$QAV012@@Z ENDP	; Json::Reader::ErrorInfo::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-, COMDAT
; _this$ = ecx

; 260  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 116  : 		return (_Right._Myoff <= _Myoff

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, edx

; 261  : 		return (*(_Mybase *)this - _Right);
; 262  : 		}

	pop	ebp
	ret	4
??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@1@@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+, COMDAT
; _this$ = ecx

; 243  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp

; 244  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]

; 245  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]

; 93   : 		_Myoff += _Off;

	add	ecx, DWORD PTR __Off$[ebp]

; 245  : 		return (_Tmp += _Off);

	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 246  : 		}

	pop	ebp
	ret	8
??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*, COMDAT
; _this$ = ecx

; 201  : 		{	// return designated object

	push	esi

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, esi
	mov	ecx, DWORD PTR [ecx]

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	shr	eax, 2
	mov	edx, DWORD PTR [ecx+8]
	dec	edx
	and	edx, eax

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 202  : 		return ((reference)**(_Mybase *)this);
; 203  : 		}

	ret	0
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEAAPAVValue@Json@@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-, COMDAT
; _this$ = ecx

; 260  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 116  : 		return (_Right._Myoff <= _Myoff

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, edx

; 261  : 		return (*(_Mybase *)this - _Right);
; 262  : 		}

	pop	ebp
	ret	4
??G?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@1@@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+, COMDAT
; _this$ = ecx

; 243  : 		{	// return this + integer

	push	ebp
	mov	ebp, esp

; 244  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]

; 245  : 		return (_Tmp += _Off);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]

; 93   : 		_Myoff += _Off;

	add	ecx, DWORD PTR __Off$[ebp]

; 245  : 		return (_Tmp += _Off);

	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx

; 246  : 		}

	pop	ebp
	ret	8
??H?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBE?AV01@H@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*, COMDAT
; _this$ = ecx

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]

; 202  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [eax+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	edx
	and	edx, DWORD PTR [ecx+4]

; 202  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [eax+edx*4]

; 203  : 		}

	ret	0
??D?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEAAVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=, COMDAT
; _this$ = ecx

; 237  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp

; 93   : 		_Myoff += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	add	DWORD PTR [ecx+4], eax

; 238  : 		*(_Mybase *)this += _Off;
; 239  : 		return (*this);

	mov	eax, ecx

; 240  : 		}

	pop	ebp
	ret	4
??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-, COMDAT
; _this$ = ecx

; 115  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 116  : 		return (_Right._Myoff <= _Myoff

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, edx

; 117  : 			? _Myoff - _Right._Myoff
; 118  : 			: -(difference_type)(_Right._Myoff - _Myoff));
; 119  : 		}

	pop	ebp
	ret	4
??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*, COMDAT
; _this$ = ecx

; 54   : 		{	// return designated object

	push	esi

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	esi, DWORD PTR [ecx+4]
	mov	eax, esi
	mov	ecx, DWORD PTR [ecx]

; 55   : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	esi, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	shr	eax, 2
	mov	edx, DWORD PTR [ecx+8]
	dec	edx
	and	edx, eax

; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+edx*4]
	lea	eax, DWORD PTR [eax+esi*4]
	pop	esi

; 58   : 		}

	ret	0
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QBEABQAVValue@Json@@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=, COMDAT
; _this$ = ecx

; 237  : 		{	// increment by integer

	push	ebp
	mov	ebp, esp

; 93   : 		_Myoff += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	add	DWORD PTR [ecx+4], eax

; 238  : 		*(_Mybase *)this += _Off;
; 239  : 		return (*this);

	mov	eax, ecx

; 240  : 		}

	pop	ebp
	ret	4
??Y?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-, COMDAT
; _this$ = ecx

; 115  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 116  : 		return (_Right._Myoff <= _Myoff

	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+4]
	sub	eax, edx

; 117  : 			? _Myoff - _Right._Myoff
; 118  : 			: -(difference_type)(_Right._Myoff - _Myoff));
; 119  : 		}

	pop	ebp
	ret	4
??G?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ
_TEXT	SEGMENT
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*, COMDAT
; _this$ = ecx

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+8]

; 55   : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;
; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+4]

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	edx
	and	edx, DWORD PTR [ecx+4]

; 55   : 		size_type _Block = _Mycont->_Getblock(_Myoff);
; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;
; 57   : 		return (_Mycont->_Map[_Block][_Off]);

	mov	eax, DWORD PTR [eax+edx*4]

; 58   : 		}

	ret	0
??D?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QBEABVErrorInfo@Reader@Json@@XZ ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=, COMDAT
; _this$ = ecx

; 92   : 		{	// increment by integer

	push	ebp
	mov	ebp, esp

; 93   : 		_Myoff += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	add	DWORD PTR [ecx+4], eax

; 94   : 		return (*this);

	mov	eax, ecx

; 95   : 		}

	pop	ebp
	ret	4
??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
;	COMDAT ??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z PROC ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=, COMDAT
; _this$ = ecx

; 92   : 		{	// increment by integer

	push	ebp
	mov	ebp, esp

; 93   : 		_Myoff += _Off;

	mov	eax, DWORD PTR __Off$[ebp]
	add	DWORD PTR [ecx+4], eax

; 94   : 		return (*this);

	mov	eax, ecx

; 95   : 		}

	pop	ebp
	ret	4
??Y?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@QAEAAV01@H@Z ENDP ; std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Ptr_copy_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z PROC ; std::_Ptr_copy_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 783  : 	return {};

	xor	al, al

; 784  : 	}

	ret	0
??$_Ptr_copy_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@@Z ENDP ; std::_Ptr_copy_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_unchecked1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
___formal$ = 32						; size = 1
??$_Copy_unchecked1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U_General_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2314 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR __First$[ebp+4]
	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2314 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	mov	ebx, ecx
	push	esi

; 2315 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	esi, DWORD PTR __Dest$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	edx, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2315 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	je	SHORT $LN3@Copy_unche
	push	edi
$LL4@Copy_unche:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2316 : 		*_Dest = *_First;

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2316 : 		*_Dest = *_First;

	mov	edi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR __Dest$[ebp]
	movq	xmm0, QWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2316 : 		*_Dest = *_First;

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2316 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [eax+ecx*4]
	movq	QWORD PTR [esi], xmm0
	lea	ecx, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax
	lea	eax, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	cmp	ecx, eax
	je	SHORT $LN29@Copy_unche

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN29@Copy_unche:
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 67   : 		++_Myoff;

	mov	edx, DWORD PTR __First$[ebp+4]
	mov	esi, DWORD PTR __Dest$[ebp+4]
	inc	edx
	inc	esi
	mov	DWORD PTR __First$[ebp+4], edx
	mov	DWORD PTR __Dest$[ebp+4], esi

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	edx, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2315 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	jne	SHORT $LL4@Copy_unche
	pop	edi
$LN3@Copy_unche:

; 2317 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ebx+4], esi
	mov	DWORD PTR [ebx], eax
	mov	eax, ebx
	pop	esi
	pop	ebx

; 2318 : 	}

	pop	ebp
	ret	0
??$_Copy_unchecked1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@0V10@U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
_TEXT	SEGMENT
__Left$GSCopy$1$ = -60					; size = 4
__Tmp$ = -56						; size = 40
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z PROC ; std::swap<Json::Reader::ErrorInfo,void>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 48   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, edx
	mov	esi, ecx
	mov	DWORD PTR __Left$GSCopy$1$[ebp], esi
	movq	xmm0, QWORD PTR [esi]
	lea	edi, DWORD PTR [esi+12]
	mov	eax, DWORD PTR [esi+8]
	lea	ecx, DWORD PTR __Tmp$[ebp+12]
	push	edi
	movq	QWORD PTR __Tmp$[ebp], xmm0
	mov	DWORD PTR __Tmp$[ebp+8], eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [esi+36]
	movq	xmm0, QWORD PTR [ebx]
	movq	QWORD PTR [esi], xmm0
	mov	DWORD PTR __Tmp$[ebp+36], eax
	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [esi+8], eax
	lea	esi, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 929  : 		if (this != &_Right)

	cmp	edi, esi
	je	SHORT $LN19@swap

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN25@swap

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [edi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN25@swap:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN113@swap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN114@swap
$LN113@swap:
	mov	eax, edi
$LN114@swap:

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi
	mov	ecx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN19@swap:
	mov	ecx, DWORD PTR __Left$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [ebx+36]
	movq	xmm0, QWORD PTR __Tmp$[ebp]
	mov	DWORD PTR [ecx+36], eax
	mov	eax, DWORD PTR __Tmp$[ebp+8]
	movq	QWORD PTR [ebx], xmm0
	mov	DWORD PTR [ebx+8], eax

; 929  : 		if (this != &_Right)

	lea	eax, DWORD PTR __Tmp$[ebp+12]
	cmp	esi, eax
	je	SHORT $LN249@swap

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN255@swap

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN255@swap:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN343@swap
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN344@swap
$LN343@swap:
	mov	eax, esi
$LN344@swap:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	mov	ecx, esi
	lea	eax, DWORD PTR __Tmp$[ebp+12]
	push	eax
	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN249@swap:
	mov	eax, DWORD PTR __Tmp$[ebp+36]
	mov	DWORD PTR [ebx+36], eax

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR __Tmp$[ebp+32]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN478@swap

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR __Tmp$[ebp+12]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN478@swap:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 52   : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z$4:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z$62:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$swap@VErrorInfo@Reader@Json@@X@std@@YAXAAVErrorInfo@Reader@Json@@0@Z ENDP ; std::swap<Json::Reader::ErrorInfo,void>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
??$_Ptr_copy_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z PROC ; std::_Ptr_copy_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___formal$dead$ = ecx
; ___formal$dead$ = edx

; 783  : 	return {};

	xor	al, al

; 784  : 	}

	ret	0
??$_Ptr_copy_cat@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AU_General_ptr_iterator_tag@0@ABV?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@ABV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@@Z ENDP ; std::_Ptr_copy_cat<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_unchecked1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$1$ = -4					; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
___formal$ = 32						; size = 1
??$_Copy_unchecked1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U_General_ptr_iterator_tag@0@@Z PROC ; std::_Copy_unchecked1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2314 : 	{	// copy [_First, _Last) to [_Dest, ...), arbitrary iterators

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	ebx, DWORD PTR __First$[ebp+4]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2315 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	edi, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR ___$ReturnUdt$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	ebx, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2315 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	je	SHORT $LN3@Copy_unche
	push	esi
$LL4@Copy_unche:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, ebx
	shr	eax, 2

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	ebx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
	dec	edx
	and	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2316 : 		*_Dest = *_First;

	mov	eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2316 : 		*_Dest = *_First;

	mov	esi, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, edi
	mov	edx, DWORD PTR [ecx+8]

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edi, 3
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2316 : 		*_Dest = *_First;

	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	edx
	shr	eax, 2
	and	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2316 : 		*_Dest = *_First;

	mov	eax, DWORD PTR [esi+ebx*4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+edi*4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 67   : 		++_Myoff;

	mov	ebx, DWORD PTR __First$[ebp+4]
	mov	edi, DWORD PTR __Dest$[ebp+4]
	inc	ebx
	inc	edi
	mov	DWORD PTR __First$[ebp+4], ebx
	mov	DWORD PTR __Dest$[ebp+4], edi

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	ebx, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2315 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	jne	SHORT $LL4@Copy_unche
	mov	ecx, DWORD PTR ___$ReturnUdt$1$[ebp]
	pop	esi
$LN3@Copy_unche:

; 2317 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx+4], edi
	pop	edi
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebx

; 2318 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_unchecked1@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@2@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V?$_Deque_unchecked_const_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@0V10@U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Copy_unchecked1<std::_Deque_unchecked_const_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@PAVValue@Json@@X@std@@YAXAAPAVValue@Json@@0@Z
_TEXT	SEGMENT
??$swap@PAVValue@Json@@X@std@@YAXAAPAVValue@Json@@0@Z PROC ; std::swap<Json::Value *,void>, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 49   : 	_Ty _Tmp = _STD move(_Left);
; 50   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR [edx]
	push	esi
	mov	esi, DWORD PTR [ecx]
	mov	DWORD PTR [ecx], eax

; 51   : 	_Right = _STD move(_Tmp);

	mov	DWORD PTR [edx], esi
	pop	esi

; 52   : 	}

	ret	0
??$swap@PAVValue@Json@@X@std@@YAXAAPAVValue@Json@@0@Z ENDP ; std::swap<Json::Value *,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z
_TEXT	SEGMENT
??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z PROC ; std::move<Json::Reader::ErrorInfo &>, COMDAT
; __Arg$ = ecx

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, ecx

; 1293 : 	}

	ret	0
??$move@AAVErrorInfo@Reader@Json@@@std@@YA$$QAVErrorInfo@Reader@Json@@AAV123@@Z ENDP ; std::move<Json::Reader::ErrorInfo &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
___formal$ = 32						; size = 1
??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Move_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2579 : 	{	// move [_First, _Last) to [_Dest, ...), no special optimization

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR ___$ReturnUdt$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	edx, DWORD PTR __First$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2580 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	esi, DWORD PTR __Dest$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	edx, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2580 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	je	$LN3@Move_unche
	npad	8
$LL4@Move_unche:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	edi, DWORD PTR [eax+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, DWORD PTR __Dest$[ebp]
	movq	xmm0, QWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2581 : 		*_Dest = _STD move(*_First);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	ecx
	and	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2581 : 		*_Dest = _STD move(*_First);

	mov	ebx, DWORD PTR [eax+ecx*4]
	lea	ecx, DWORD PTR [edi+12]
	movq	QWORD PTR [ebx], xmm0
	lea	esi, DWORD PTR [ebx+12]
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [ebx+8], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 929  : 		if (this != &_Right)

	cmp	esi, ecx
	je	SHORT $LN40@Move_unche

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN46@Move_unche

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR [esi]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
	lea	ecx, DWORD PTR [edi+12]
$LN46@Move_unche:

; 2259 : 			}
; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN134@Move_unche
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN135@Move_unche
$LN134@Move_unche:
	mov	eax, esi
$LN135@Move_unche:

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	push	ecx
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN40@Move_unche:
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [ebx+36], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 67   : 		++_Myoff;

	mov	edx, DWORD PTR __First$[ebp+4]
	mov	esi, DWORD PTR __Dest$[ebp+4]
	inc	edx
	inc	esi
	mov	DWORD PTR __First$[ebp+4], edx
	mov	DWORD PTR __Dest$[ebp+4], esi

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	edx, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2580 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	jne	$LL4@Move_unche
	mov	ecx, DWORD PTR ___$ReturnUdt$1$[ebp]
$LN3@Move_unche:

; 2582 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], esi

; 2583 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z$2:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-20]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@VErrorInfo@Reader@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Move_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Reader::ErrorInfo> > > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
___$ReturnUdt$1$ = -4					; size = 4
__First$ = 8						; size = 8
__Last$ = 16						; size = 8
__Dest$ = 24						; size = 8
___formal$ = 32						; size = 1
??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z PROC ; std::_Move_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >, COMDAT
; ___$ReturnUdt$ = ecx

; 2579 : 	{	// move [_First, _Last) to [_Dest, ...), no special optimization

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	mov	ebx, DWORD PTR __First$[ebp+4]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2580 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	mov	edi, DWORD PTR __Dest$[ebp+4]
	mov	DWORD PTR ___$ReturnUdt$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	ebx, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2580 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	je	SHORT $LN3@Move_unche
	push	esi
$LL4@Move_unche:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR __First$[ebp]
	mov	eax, ebx
	shr	eax, 2

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	ebx, 3

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	edx, DWORD PTR [ecx+8]
	dec	edx
	and	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2581 : 		*_Dest = _STD move(*_First);

	mov	eax, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	ecx, DWORD PTR __Dest$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2581 : 		*_Dest = _STD move(*_First);

	mov	esi, DWORD PTR [eax+edx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	mov	eax, edi
	mov	edx, DWORD PTR [ecx+8]

; 56   : 		size_type _Off = _Myoff % _DEQUESIZ;

	and	edi, 3
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2581 : 		*_Dest = _STD move(*_First);

	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 769  : 		return ((_Off / _DEQUESIZ) & (_Mapsize - 1));

	dec	edx
	shr	eax, 2
	and	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2581 : 		*_Dest = _STD move(*_First);

	mov	eax, DWORD PTR [esi+ebx*4]
	mov	ecx, DWORD PTR [ecx+edx*4]
	mov	DWORD PTR [ecx+edi*4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\deque

; 67   : 		++_Myoff;

	mov	ebx, DWORD PTR __First$[ebp+4]
	mov	edi, DWORD PTR __Dest$[ebp+4]
	inc	ebx
	inc	edi
	mov	DWORD PTR __First$[ebp+4], ebx
	mov	DWORD PTR __Dest$[ebp+4], edi

; 128  : 		return (_Myoff == _Right._Myoff);

	cmp	ebx, DWORD PTR __Last$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2580 : 	for (; _First != _Last; ++_Dest, (void)++_First)

	jne	SHORT $LL4@Move_unche
	mov	ecx, DWORD PTR ___$ReturnUdt$1$[ebp]
	pop	esi
$LN3@Move_unche:

; 2582 : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR [ecx+4], edi
	pop	edi
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebx

; 2583 : 	}

	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_unchecked1@V?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@std@@V12@@std@@YA?AV?$_Deque_unchecked_iterator@V?$_Deque_val@U?$_Deque_simple_types@PAVValue@Json@@@std@@@std@@@0@V10@00U_General_ptr_iterator_tag@0@@Z ENDP ; std::_Move_unchecked1<std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > >,std::_Deque_unchecked_iterator<std::_Deque_val<std::_Deque_simple_types<Json::Value *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z PROC	; Json::Reader::ErrorInfo::operator=, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, DWORD PTR ___that$[ebp]
	mov	esi, ecx
	movq	xmm0, QWORD PTR [edi]
	lea	ecx, DWORD PTR [esi+12]
	movq	QWORD PTR [esi], xmm0
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR [esi+8], eax
	lea	eax, DWORD PTR [edi+12]

; 1024 : 		if (this != &_Right)

	cmp	ecx, eax
	je	SHORT $LN4@operator

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@operator:
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+36], eax
	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??4ErrorInfo@Reader@Json@@QAEAAV012@ABV012@@Z ENDP	; Json::Reader::ErrorInfo::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??0ErrorInfo@Reader@Json@@QAE@$$QAV012@@Z
_TEXT	SEGMENT
___that$ = 8						; size = 4
??0ErrorInfo@Reader@Json@@QAE@$$QAV012@@Z PROC		; Json::Reader::ErrorInfo::ErrorInfo, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___that$[ebp]
	push	edi
	mov	edi, ecx
	movq	xmm0, QWORD PTR [esi]
	movq	QWORD PTR [edi], xmm0
	lea	ecx, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edi+8], eax
	lea	eax, DWORD PTR [esi+12]
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	eax, DWORD PTR [esi+36]
	mov	DWORD PTR [edi+36], eax
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??0ErrorInfo@Reader@Json@@QAE@$$QAV012@@Z ENDP		; Json::Reader::ErrorInfo::ErrorInfo
_TEXT	ENDS
END
