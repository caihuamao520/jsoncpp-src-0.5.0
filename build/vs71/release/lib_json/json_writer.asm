; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat


PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
PUBLIC	??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@		; `string'
PUBLIC	??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@	; `string'
PUBLIC	??_C@_01BJJEKLCA@?$CC?$AA@			; `string'
PUBLIC	??_C@_02MCKKLHBJ@?2?$CC?$AA@			; `string'
PUBLIC	??_C@_02HDBGODGB@?2?2?$AA@			; `string'
PUBLIC	??_C@_02DCNDPIBM@?2b?$AA@			; `string'
PUBLIC	??_C@_02FGLPDNBI@?2f?$AA@			; `string'
PUBLIC	??_C@_02JOGGLHBA@?2n?$AA@			; `string'
PUBLIC	??_C@_02HIBBOKEN@?2r?$AA@			; `string'
PUBLIC	??_C@_02COELENML@?2t?$AA@			; `string'
PUBLIC	??_C@_02DHFAHMIK@?2u?$AA@			; `string'
PUBLIC	??_C@_04MLLLIHIP@null?$AA@			; `string'
PUBLIC	??_C@_01OHGJGJJP@?$FL?$AA@			; `string'
PUBLIC	??_C@_01IHBHIGKO@?0?$AA@			; `string'
PUBLIC	??_C@_01LBDDMOBJ@?$FN?$AA@			; `string'
PUBLIC	??_C@_01HCONENDN@?$HL?$AA@			; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_01CELHOKLL@?$HN?$AA@			; `string'
PUBLIC	??_C@_02MCILKGOH@?$HL?$HN?$AA@			; `string'
PUBLIC	??_C@_03MCPBMLDJ@?5?3?5?$AA@			; `string'
PUBLIC	??_C@_02GPECMEKF@?$FL?$FN?$AA@			; `string'
PUBLIC	??_C@_02PFNDMDBO@?$FL?5?$AA@			; `string'
PUBLIC	??_C@_02KEGNLNML@?0?5?$AA@			; `string'
PUBLIC	??_C@_02DHOGEDBE@?5?$FN?$AA@			; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
EXTRN	__imp_?rdstate@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QBE_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QBEHXZ:PROC
EXTRN	__imp_?setf@ios_base@std@@QAEHH@Z:PROC
EXTRN	__imp_?setf@ios_base@std@@QAEHHH@Z:PROC
EXTRN	__imp_?width@ios_base@std@@QBE_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QAE_J_J@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	__imp_?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z:PROC
EXTRN	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync
EXTRN	__imp_?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
EXTRN	__imp_?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z:PROC
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z:PROC
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z:PROC
EXTRN	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow
EXTRN	__imp_?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ:PROC
EXTRN	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEPADXZ:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD0@Z:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXPAD00@Z:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAEXH@Z:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IBEPADXZ:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEDXZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QBEPAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEDD@Z:PROC
EXTRN	__imp____stdio_common_vsprintf_s:PROC
EXTRN	__imp_?setw@std@@YA?AU?$_Smanip@_J@1@_J@Z:PROC
EXTRN	__imp_?_BADOFF@std@@3_JB:QWORD
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp__strpbrk:PROC
;	COMDAT ??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@ios_base@std@@8
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD FLAT:??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	FLAT:??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD FLAT:??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	FLAT:??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	FLAT:??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
CONST	SEGMENT
??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@ DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	050H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD FLAT:??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
	DD	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAEXXZ
	DD	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
	DD	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JXZ
	DD	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
	DD	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPAD_J@Z
	DD	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAE_JPBD_J@Z
	DD	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DD	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DD	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEPAV12@PAD_J@Z
	DD	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEHXZ
	DD	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MAEXABVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	FLAT:??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allo'
	DB	'cator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	FLAT:??_R1A@A@3EA@ios_base@std@@8
	DD	FLAT:??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DD FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD FLAT:??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD FLAT:??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	FLAT:??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	FLAT:??_R2?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD FLAT:??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DD FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DD FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DD	00H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD FLAT:??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DD	FLAT:??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
CONST	ENDS
;	COMDAT ??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 00H ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	050H
	DD	04H
	DD	FLAT:??_R0?AV?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	FLAT:??_R3?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHOGEDBE@?5?$FN?$AA@
CONST	SEGMENT
??_C@_02DHOGEDBE@?5?$FN?$AA@ DB ' ]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02KEGNLNML@?0?5?$AA@
CONST	SEGMENT
??_C@_02KEGNLNML@?0?5?$AA@ DB ', ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PFNDMDBO@?$FL?5?$AA@
CONST	SEGMENT
??_C@_02PFNDMDBO@?$FL?5?$AA@ DB '[ ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02GPECMEKF@?$FL?$FN?$AA@
CONST	SEGMENT
??_C@_02GPECMEKF@?$FL?$FN?$AA@ DB '[]', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03MCPBMLDJ@?5?3?5?$AA@
CONST	SEGMENT
??_C@_03MCPBMLDJ@?5?3?5?$AA@ DB ' : ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCILKGOH@?$HL?$HN?$AA@
CONST	SEGMENT
??_C@_02MCILKGOH@?$HL?$HN?$AA@ DB '{}', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01CELHOKLL@?$HN?$AA@
CONST	SEGMENT
??_C@_01CELHOKLL@?$HN?$AA@ DB '}', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HCONENDN@?$HL?$AA@
CONST	SEGMENT
??_C@_01HCONENDN@?$HL?$AA@ DB '{', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LBDDMOBJ@?$FN?$AA@
CONST	SEGMENT
??_C@_01LBDDMOBJ@?$FN?$AA@ DB ']', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IHBHIGKO@?0?$AA@
CONST	SEGMENT
??_C@_01IHBHIGKO@?0?$AA@ DB ',', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OHGJGJJP@?$FL?$AA@
CONST	SEGMENT
??_C@_01OHGJGJJP@?$FL?$AA@ DB '[', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04MLLLIHIP@null?$AA@
CONST	SEGMENT
??_C@_04MLLLIHIP@null?$AA@ DB 'null', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02DHFAHMIK@?2u?$AA@
CONST	SEGMENT
??_C@_02DHFAHMIK@?2u?$AA@ DB '\u', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02COELENML@?2t?$AA@
CONST	SEGMENT
??_C@_02COELENML@?2t?$AA@ DB '\t', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HIBBOKEN@?2r?$AA@
CONST	SEGMENT
??_C@_02HIBBOKEN@?2r?$AA@ DB '\r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JOGGLHBA@?2n?$AA@
CONST	SEGMENT
??_C@_02JOGGLHBA@?2n?$AA@ DB '\n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FGLPDNBI@?2f?$AA@
CONST	SEGMENT
??_C@_02FGLPDNBI@?2f?$AA@ DB '\f', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCNDPIBM@?2b?$AA@
CONST	SEGMENT
??_C@_02DCNDPIBM@?2b?$AA@ DB '\b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02HDBGODGB@?2?2?$AA@
CONST	SEGMENT
??_C@_02HDBGODGB@?2?2?$AA@ DB '\\', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MCKKLHBJ@?2?$CC?$AA@
CONST	SEGMENT
??_C@_02MCKKLHBJ@?2?$CC?$AA@ DB '\"', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_01BJJEKLCA@?$CC?$AA@
CONST	SEGMENT
??_C@_01BJJEKLCA@?$CC?$AA@ DB '"', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@
CONST	SEGMENT
??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@ DB '"\', 08H, 0cH, 0aH, 0dH, 09H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@
CONST	SEGMENT
??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@ DB '%#.16g', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
PUBLIC	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??0?$_Fillobj@D@std@@QAE@D@Z			; std::_Fillobj<char>::_Fillobj<char>
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?6DU?$char_traits@D@std@@_J@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@_J@0@@Z ; std::operator<<<char,std::char_traits<char>,__int64>
PUBLIC	??$?6DU?$char_traits@D@std@@D@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z ; std::operator<<<char,std::char_traits<char>,char>
PUBLIC	??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z	; std::setfill<char>
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base0@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Compat
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
PUBLIC	?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
PUBLIC	??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
PUBLIC	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator!=
PUBLIC	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
PUBLIC	?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledStreamWriter::hasCommentForValue
PUBLIC	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine
PUBLIC	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue
PUBLIC	?unindent@StyledStreamWriter@Json@@AAEXXZ	; Json::StyledStreamWriter::unindent
PUBLIC	?indent@StyledStreamWriter@Json@@AAEXXZ		; Json::StyledStreamWriter::indent
PUBLIC	?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::writeWithIndent
PUBLIC	?writeIndent@StyledStreamWriter@Json@@AAEXXZ	; Json::StyledStreamWriter::writeIndent
PUBLIC	?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::pushValue
PUBLIC	?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledStreamWriter::isMultineArray
PUBLIC	?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeArrayValue
PUBLIC	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue
PUBLIC	?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z ; Json::StyledStreamWriter::write
PUBLIC	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
PUBLIC	?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::hasCommentForValue
PUBLIC	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
PUBLIC	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
PUBLIC	?unindent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::unindent
PUBLIC	?indent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::indent
PUBLIC	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
PUBLIC	?writeIndent@StyledWriter@Json@@AAEXXZ		; Json::StyledWriter::writeIndent
PUBLIC	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue
PUBLIC	?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::isMultineArray
PUBLIC	?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeArrayValue
PUBLIC	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
PUBLIC	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z	; Json::FastWriter::writeValue
PUBLIC	?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ ; Json::FastWriter::enableYAMLCompatibility
PUBLIC	??0FastWriter@Json@@QAE@XZ			; Json::FastWriter::FastWriter
PUBLIC	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
PUBLIC	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
PUBLIC	?uppercase@std@@YAAAVios_base@1@AAV21@@Z	; std::uppercase
PUBLIC	?hex@std@@YAAAVios_base@1@AAV21@@Z		; std::hex
PUBLIC	?not_eof@?$char_traits@D@std@@SAHABH@Z		; std::char_traits<char>::not_eof
PUBLIC	?eq@?$char_traits@D@std@@SA_NABD0@Z		; std::char_traits<char>::eq
PUBLIC	_sprintf_s
PUBLIC	__vsprintf_s_l
PUBLIC	?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::FastWriter::write
PUBLIC	??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledStreamWriter::StyledStreamWriter
PUBLIC	??1Writer@Json@@UAE@XZ				; Json::Writer::~Writer
PUBLIC	?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ; Json::StyledWriter::write
PUBLIC	??0StyledWriter@Json@@QAE@XZ			; Json::StyledWriter::StyledWriter
EXTRN	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z DD 019930522H
	DD	08H
	DD	FLAT:__unwindtable$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$3
	DD	02H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$125
	DD	03H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$126
	DD	04H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$128
	DD	02H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$4
	DD	06H
	DD	FLAT:__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	07H
	DD	FLAT:__unwindtable$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$5
	DD	05H
	DD	FLAT:__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$124
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$125
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z$24
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z$46
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z$47
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?indent@StyledWriter@Json@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?indent@StyledWriter@Json@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?indent@StyledWriter@Json@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?indent@StyledWriter@Json@@AAEXXZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	0bH
	DD	FLAT:__unwindtable$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
	ORG $+4
__unwindtable$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$6
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$7
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$8
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$9
	DD	06H
	DD	FLAT:__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$10
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$124
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$125
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z$24
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z$46
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z$47
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3
	DD	03H
	DD	FLAT:__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$33
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$88
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$10 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$10
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$11
__tryblocktable$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$12
__catchsym$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$12 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$15
	DD	04H
	DD	FLAT:__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$16
__tryblocktable$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$17
__catchsym$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$17 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??0StyledWriter@Json@@QAE@XZ
_TEXT	SEGMENT
??0StyledWriter@Json@@QAE@XZ PROC			; Json::StyledWriter::StyledWriter, COMDAT
; _this$ = ecx

; 272  : {

	mov	DWORD PTR [ecx], OFFSET ??_7StyledWriter@Json@@6B@

; 273  : }

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx+4], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+8], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+36], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+32], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+60], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+56], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+40], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 270  :    : rightMargin_( 74 )

	mov	DWORD PTR [ecx+64], 74			; 0000004aH

; 271  :    , indentSize_( 3 )

	mov	DWORD PTR [ecx+68], 3

; 273  : }

	ret	0
??0StyledWriter@Json@@QAE@XZ ENDP			; Json::StyledWriter::StyledWriter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_root$ = 12						; size = 4
?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z PROC ; Json::StyledWriter::write, COMDAT
; _this$ = ecx

; 278  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR $T1[esp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 279  :    document_ = "";

	lea	ebx, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, ebx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 281  :    indentString_ = "";

	lea	ecx, DWORD PTR [edi+40]
	mov	BYTE PTR [edi+72], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 282  :    writeCommentBeforeValue( root );

	mov	esi, DWORD PTR _root$[ebp]
	mov	ecx, edi
	push	esi
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue

; 283  :    writeValue( root );

	push	esi
	mov	ecx, edi
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue

; 284  :    writeCommentAfterValueOnSameLine( root );

	push	esi
	mov	ecx, edi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, ebx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 782  : 		assign(_Right, 0, npos);

	mov	ecx, esi
	push	-1
	push	0
	push	ebx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 287  : }

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
?write@StyledWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ENDP ; Json::StyledWriter::write
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??1Writer@Json@@UAE@XZ
_TEXT	SEGMENT
??1Writer@Json@@UAE@XZ PROC				; Json::Writer::~Writer, COMDAT
; _this$ = ecx

; 177  : {

	mov	DWORD PTR [ecx], OFFSET ??_7Writer@Json@@6B@

; 178  : }

	ret	0
??1Writer@Json@@UAE@XZ ENDP				; Json::Writer::~Writer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_this$GSCopy$ = -20					; size = 4
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_indentation$ = 8					; size = 24
??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledStreamWriter::StyledStreamWriter, COMDAT
; _this$ = ecx

; 548  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
	mov	DWORD PTR _this$GSCopy$[ebp], esi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [esi], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [esi+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [esi+8], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 548  : {

	lea	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [esi+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN117@StyledStre
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN117@StyledStre:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 548  : {

	mov	BYTE PTR __$EHRec$[ebp+8], 2

; 547  :    , indentation_( indentation )

	lea	ecx, DWORD PTR [esi+44]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 546  :    , rightMargin_( 74 )

	mov	DWORD PTR [esi+40], 74			; 0000004aH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	lea	eax, DWORD PTR _indentation$[ebp]
	push	0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR _indentation$[ebp+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN349@StyledStre

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR _indentation$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN349@StyledStre:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 549  : }

	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _indentation$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$2:
	mov	ecx, DWORD PTR _this$GSCopy$[ebp]
	add	ecx, 16					; 00000010H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0StyledStreamWriter@Json@@QAE@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledStreamWriter::StyledStreamWriter
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_root$ = 12						; size = 4
?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z PROC ; Json::FastWriter::write, COMDAT
; _this$ = ecx

; 199  : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR $T1[ebp], 0
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 200  :    document_ = "";

	lea	edi, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 201  :    writeValue( root );

	push	DWORD PTR _root$[ebp]
	mov	ecx, esi
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 782  : 		assign(_Right, 0, npos);

	mov	ecx, esi
	push	-1
	push	0
	push	edi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	edi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 203  :    return document_;

	mov	eax, esi
	pop	esi

; 204  : }

	mov	esp, ebp
	pop	ebp
	ret	8
?write@FastWriter@Json@@UAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABVValue@2@@Z ENDP ; Json::FastWriter::write
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_s_l
_TEXT	SEGMENT
__Format$ = 8						; size = 4
__Locale$dead$ = 12					; size = 4
__ArgList$ = 16						; size = 4
__vsprintf_s_l PROC					; COMDAT
; __Buffer$ = ecx
; __BufferCount$ = edx

; 1493 : {

	push	ebp
	mov	ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

	push	DWORD PTR __ArgList$[ebp]
	push	0
	push	DWORD PTR __Format$[ebp]
	push	edx
	push	ecx
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1499 : }

	pop	ebp
	ret	0
__vsprintf_s_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf_s
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
_sprintf_s PROC						; COMDAT

; 1834 :     {

	push	ebp
	mov	ebp, esp

; 1494 :     int const _Result = __stdio_common_vsprintf_s(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	push	DWORD PTR [eax+4]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp____stdio_common_vsprintf_s

; 1495 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS,
; 1496 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1497 : 
; 1498 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1835 :         int _Result;
; 1836 :         va_list _ArgList;
; 1837 :         __crt_va_start(_ArgList, _Format);
; 1838 :         _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, NULL, _ArgList);
; 1839 :         __crt_va_end(_ArgList);
; 1840 :         return _Result;
; 1841 :     }

	pop	ebp
	ret	0
_sprintf_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT
?eq@?$char_traits@D@std@@SA_NABD0@Z PROC		; std::char_traits<char>::eq, COMDAT
; __Left$ = ecx
; __Right$ = edx

; 570  : 		{	// test for element equality

	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [edx]
	sete	al

; 571  : 		return (_Left == _Right);
; 572  : 		}

	ret	0
?eq@?$char_traits@D@std@@SA_NABD0@Z ENDP		; std::char_traits<char>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHABH@Z
_TEXT	SEGMENT
?not_eof@?$char_traits@D@std@@SAHABH@Z PROC		; std::char_traits<char>::not_eof, COMDAT
; __Meta$ = ecx

; 601  : 		return (_Meta != eof() ? _Meta : !eof());

	mov	ecx, DWORD PTR [ecx]
	xor	eax, eax
	cmp	ecx, -1
	cmovne	eax, ecx

; 602  : 		}

	ret	0
?not_eof@?$char_traits@D@std@@SAHABH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?hex@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?hex@std@@YAAAVios_base@1@AAV21@@Z PROC			; std::hex, COMDAT

; 238  : 	{	// set basefield to hex

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 399  : 		_Fmtfl = (fmtflags)(((int)_Fmtfl & (int)~_Mask)

	mov	eax, DWORD PTR __Iosbase$[ebp]
	mov	ecx, DWORD PTR [eax+20]
	and	ecx, -1537				; fffff9ffH
	or	ecx, 2048				; 00000800H
	mov	DWORD PTR [eax+20], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 241  : 	}

	pop	ebp
	ret	0
?hex@std@@YAAAVios_base@1@AAV21@@Z ENDP			; std::hex
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
;	COMDAT ?uppercase@std@@YAAAVios_base@1@AAV21@@Z
_TEXT	SEGMENT
__Iosbase$ = 8						; size = 4
?uppercase@std@@YAAAVios_base@1@AAV21@@Z PROC		; std::uppercase, COMDAT

; 358  : 	{	// set uppercase

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 391  : 		_Fmtfl = (fmtflags)((int)_Fmtfl

	mov	eax, DWORD PTR __Iosbase$[ebp]
	or	DWORD PTR [eax+20], 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 361  : 	}

	pop	ebp
	ret	0
?uppercase@std@@YAAAVios_base@1@AAV21@@Z ENDP		; std::uppercase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?isControlCharacter@Json@@YA_ND@Z
_TEXT	SEGMENT
?isControlCharacter@Json@@YA_ND@Z PROC			; Json::isControlCharacter, COMDAT
; _ch$ = cl

; 18   :    return ch > 0 && ch <= 0x1F;

	dec	cl
	mov	eax, 30					; 0000001eH
	cmp	al, cl
	sbb	eax, eax
	inc	eax

; 19   : }

	ret	0
?isControlCharacter@Json@@YA_ND@Z ENDP			; Json::isControlCharacter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?containsControlCharacter@Json@@YA_NPBD@Z
_TEXT	SEGMENT
?containsControlCharacter@Json@@YA_NPBD@Z PROC		; Json::containsControlCharacter, COMDAT
; _str$ = ecx

; 23   :    while ( *str ) 

	mov	al, BYTE PTR [ecx]
	test	al, al
	je	SHORT $LN3@containsCo
$LL2@containsCo:

; 18   :    return ch > 0 && ch <= 0x1F;

	dec	al

; 24   :    {
; 25   :       if ( isControlCharacter( *(str++) ) )

	lea	ecx, DWORD PTR [ecx+1]

; 18   :    return ch > 0 && ch <= 0x1F;

	mov	dl, 30					; 0000001eH
	cmp	dl, al
	sbb	eax, eax
	inc	eax

; 24   :    {
; 25   :       if ( isControlCharacter( *(str++) ) )

	test	al, al
	jne	SHORT $LN11@containsCo

; 23   :    while ( *str ) 

	mov	al, BYTE PTR [ecx]
	test	al, al
	jne	SHORT $LL2@containsCo
$LN3@containsCo:

; 27   :    }
; 28   :    return false;

	xor	al, al

; 29   : }

	ret	0
$LN11@containsCo:

; 26   :          return true;

	mov	al, 1

; 29   : }

	ret	0
?containsControlCharacter@Json@@YA_NPBD@Z ENDP		; Json::containsControlCharacter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?uintToString@Json@@YAXIAAPAD@Z
_TEXT	SEGMENT
?uintToString@Json@@YAXIAAPAD@Z PROC			; Json::uintToString, COMDAT
; _value$ = ecx
; _current$ = edx

; 32   : {

	push	ebx
	push	esi
	push	edi
	mov	edi, edx

; 33   :    *--current = 0;

	dec	DWORD PTR [edi]
	mov	esi, DWORD PTR [edi]
	mov	BYTE PTR [esi], 0
	npad	4
$LL4@uintToStri:

; 34   :    do
; 35   :    {
; 36   :       *--current = (value % 10) + '0';

	mov	eax, -858993459				; cccccccdH
	dec	esi
	mul	ecx
	mov	DWORD PTR [edi], esi
	shr	edx, 3
	mov	al, dl
	shl	al, 2
	lea	ebx, DWORD PTR [eax+edx]
	add	bl, bl
	sub	cl, bl
	add	cl, 48					; 00000030H
	mov	BYTE PTR [esi], cl

; 37   :       value /= 10;

	mov	ecx, edx

; 38   :    }
; 39   :    while ( value != 0 );

	test	ecx, ecx
	jne	SHORT $LL4@uintToStri

; 40   : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?uintToString@Json@@YAXIAAPAD@Z ENDP			; Json::uintToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z
_TEXT	SEGMENT
$T1 = -48						; size = 4
tv450 = -44						; size = 4
_buffer$ = -40						; size = 32
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 4
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z PROC ; Json::valueToString, COMDAT

; 43   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 44   :    char buffer[32];
; 45   :    char *current = buffer + sizeof(buffer);
; 46   :    bool isNegative = value < 0;

	mov	eax, DWORD PTR _value$[ebp]
	mov	ecx, eax
	push	ebx
	shr	ecx, 31					; 0000001fH
	mov	ebx, eax
	neg	ebx
	mov	DWORD PTR $T1[ebp], 0
	push	esi
	test	cl, cl
	mov	DWORD PTR tv450[ebp], ecx
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]

; 33   :    *--current = 0;

	lea	esi, DWORD PTR _buffer$[ebp+31]
	cmove	ebx, eax
	mov	BYTE PTR _buffer$[ebp+31], 0
$LL10@valueToStr:

; 34   :    do
; 35   :    {
; 36   :       *--current = (value % 10) + '0';

	mov	eax, -858993459				; cccccccdH
	dec	esi
	mul	ebx
	shr	edx, 3
	mov	al, dl
	shl	al, 2
	lea	ecx, DWORD PTR [eax+edx]
	add	cl, cl
	sub	bl, cl
	add	bl, 48					; 00000030H
	mov	BYTE PTR [esi], bl

; 37   :       value /= 10;

	mov	ebx, edx

; 38   :    }
; 39   :    while ( value != 0 );

	test	ebx, ebx
	jne	SHORT $LL10@valueToStr

; 47   :    if ( isNegative )
; 48   :       value = -value;
; 49   :    uintToString( UInt(value), current );
; 50   :    if ( isNegative )

	cmp	BYTE PTR tv450[ebp], dl
	je	SHORT $LN3@valueToStr

; 51   :       *--current = '-';

	dec	esi
	mov	BYTE PTR [esi], 45			; 0000002dH
$LN3@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN122@valueToStr
	xor	eax, eax
	jmp	SHORT $LN123@valueToStr
$LN122@valueToStr:
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL127@valueToStr:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL127@valueToStr
	sub	eax, edx
$LN123@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	esi
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 54   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
_buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 4
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z PROC ; Json::valueToString, COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 59   :    char buffer[32];
; 60   :    char *current = buffer + sizeof(buffer);
; 61   :    uintToString( value, current );

	mov	ebx, DWORD PTR _value$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]

; 33   :    *--current = 0;

	lea	esi, DWORD PTR _buffer$[ebp+31]
	mov	DWORD PTR $T1[ebp], 0
	mov	BYTE PTR _buffer$[ebp+31], 0
$LL8@valueToStr:

; 34   :    do
; 35   :    {
; 36   :       *--current = (value % 10) + '0';

	mov	eax, -858993459				; cccccccdH
	dec	esi
	mul	ebx
	shr	edx, 3
	mov	al, dl
	shl	al, 2
	lea	ecx, DWORD PTR [eax+edx]
	add	cl, cl
	sub	bl, cl
	add	bl, 48					; 00000030H
	mov	BYTE PTR [esi], bl

; 37   :       value /= 10;

	mov	ebx, edx

; 38   :    }
; 39   :    while ( value != 0 );

	test	ebx, ebx
	jne	SHORT $LL8@valueToStr
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], dl

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [esi], dl
	jne	SHORT $LN120@valueToStr
	xor	eax, eax
	jmp	SHORT $LN121@valueToStr
$LN120@valueToStr:
	mov	eax, esi
	lea	edx, DWORD PTR [eax+1]
$LL125@valueToStr:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL125@valueToStr
	sub	eax, edx
$LN121@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	eax
	push	esi
	mov	ecx, edi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 64   : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, edi
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z
_TEXT	SEGMENT
$T1 = -40						; size = 4
_buffer$ = -36						; size = 32
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 8
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z PROC ; Json::valueToString, COMDAT

; 67   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 68   :    char buffer[32];
; 69   : #if defined(_MSC_VER) && defined(__STDC_SECURE_LIB__) // Use secure version with visual studio 2005 to avoid warning. 
; 70   :    sprintf_s(buffer, sizeof(buffer), "%#.16g", value); 

	movsd	xmm0, QWORD PTR _value$[ebp]
	lea	eax, DWORD PTR _buffer$[ebp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	sub	esp, 8
	mov	DWORD PTR $T1[ebp], 0
	movsd	QWORD PTR [esp], xmm0
	push	OFFSET ??_C@_06ECBCCLMB@?$CF?$CD?416g?$AA@
	push	32					; 00000020H
	push	eax
	call	_sprintf_s

; 71   : #else	
; 72   :    sprintf(buffer, "%#.16g", value); 
; 73   : #endif
; 74   :    char* ch = buffer + strlen(buffer) - 1;

	lea	ecx, DWORD PTR _buffer$[ebp]
	add	esp, 20					; 00000014H
	lea	edx, DWORD PTR [ecx+1]
$LL472@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL472@valueToStr
	sub	ecx, edx

; 75   :    if (*ch != '0') return buffer; // nothing to truncate, so save time

	cmp	BYTE PTR _buffer$[ebp+ecx-1], 48	; 00000030H
	lea	eax, DWORD PTR _buffer$[ebp+ecx-1]
	je	SHORT $LN463@valueToStr
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR _buffer$[ebp], 0
	je	SHORT $LN479@valueToStr
	lea	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+1]
$LL473@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL473@valueToStr
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 75   :    if (*ch != '0') return buffer; // nothing to truncate, so save time

	jmp	$LN478@valueToStr
$LN463@valueToStr:

; 76   :    while(ch > buffer && *ch == '0'){

	lea	ecx, DWORD PTR _buffer$[ebp]
	cmp	eax, ecx
	jbe	SHORT $LN477@valueToStr
$LL2@valueToStr:
	cmp	BYTE PTR [eax], 48			; 00000030H
	jne	SHORT $LN477@valueToStr

; 77   :      --ch;

	dec	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	cmp	eax, ecx
	ja	SHORT $LL2@valueToStr
$LN477@valueToStr:

; 78   :    }
; 79   :    char* last_nonzero = ch;
; 80   :    while(ch >= buffer){

	lea	ecx, DWORD PTR _buffer$[ebp]
	mov	edx, eax
	cmp	eax, ecx
	jb	SHORT $LN5@valueToStr
	npad	5
$LL4@valueToStr:

; 81   :      switch(*ch){

	mov	cl, BYTE PTR [eax]
	cmp	cl, 46					; 0000002eH
	je	SHORT $LN10@valueToStr
	sub	cl, 48					; 00000030H
	cmp	cl, 9
	ja	SHORT $LN465@valueToStr

; 82   :      case '0':
; 83   :      case '1':
; 84   :      case '2':
; 85   :      case '3':
; 86   :      case '4':
; 87   :      case '5':
; 88   :      case '6':
; 89   :      case '7':
; 90   :      case '8':
; 91   :      case '9':
; 92   :        --ch;

	dec	eax
	lea	ecx, DWORD PTR _buffer$[ebp]
	cmp	eax, ecx
	jae	SHORT $LL4@valueToStr
$LN5@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR _buffer$[ebp], 0
	jne	SHORT $LN461@valueToStr
$LN479@valueToStr:
	xor	ecx, ecx
	jmp	SHORT $LN462@valueToStr
$LN465@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR _buffer$[ebp], 0
	je	SHORT $LN479@valueToStr
	lea	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	1
$LL474@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL474@valueToStr
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 99   :        return buffer;

	jmp	SHORT $LN478@valueToStr
$LN10@valueToStr:

; 93   :        continue;
; 94   :      case '.':
; 95   :        // Truncate zeroes to save bytes in output, but keep one.
; 96   :        *(last_nonzero+2) = '\0';

	mov	BYTE PTR [edx+2], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR _buffer$[ebp], 0
	je	SHORT $LN479@valueToStr
	lea	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL475@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL475@valueToStr
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 97   :        return buffer;

	jmp	SHORT $LN478@valueToStr
$LN461@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	lea	ecx, DWORD PTR _buffer$[ebp]
	lea	edx, DWORD PTR [ecx+1]
	npad	1
$LL476@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL476@valueToStr
$LN478@valueToStr:
	sub	ecx, edx
$LN462@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	lea	eax, DWORD PTR _buffer$[ebp]
	mov	ecx, esi
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 103  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 1
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z PROC ; Json::valueToString, COMDAT

; 107  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 108  :    return value ? "true" : "false";

	cmp	BYTE PTR _value$[ebp], 0
	mov	edx, OFFSET ??_C@_04LOAJBDKD@true?$AA@
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 108  :    return value ? "true" : "false";

	mov	eax, OFFSET ??_C@_05LAPONLG@false?$AA@
	cmove	edx, eax
	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN115@valueToStr
	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 108  :    return value ? "true" : "false";

	mov	eax, esi
	pop	esi

; 109  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN115@valueToStr:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	ecx, edx
	push	edi
	lea	edi, DWORD PTR [ecx+1]
	npad	2
$LL117@valueToStr:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL117@valueToStr
	sub	ecx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 108  :    return value ? "true" : "false";

	mov	eax, esi
	pop	esi

; 109  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ENDP ; Json::valueToString
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
_TEXT	SEGMENT
_oss$279 = -276						; size = 152
_this$ = -124						; size = 4
___$ReturnUdt$GSCopy$1$ = -120				; size = 4
$T1 = -116						; size = 4
$T126 = -112						; size = 24
$T31 = -88						; size = 24
$T4 = -64						; size = 24
$T125 = -56						; size = 16
_result$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_value$ = 12						; size = 4
?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z PROC ; Json::valueToQuotedString, COMDAT

; 112  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 264				; 00000108H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR _value$[ebp]
	mov	ebx, DWORD PTR ___$ReturnUdt$[ebp]

; 113  :    // Not sure how to handle unicode...
; 114  :    if (strpbrk(value, "\"\\\b\f\n\r\t") == NULL && !containsControlCharacter( value ))

	push	OFFSET ??_C@_07FKPPGBGM@?$CC?2?$AI?$AM?6?$AN?7?$AA@
	push	esi
	mov	DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp], ebx
	mov	DWORD PTR $T1[ebp], 0
	call	DWORD PTR __imp__strpbrk
	add	esp, 8
	test	eax, eax
	jne	$LN7@valueToQuo
	mov	ecx, esi

; 23   :    while ( *str ) 

	cmp	BYTE PTR [esi], al
	je	SHORT $LN28@valueToQuo
	npad	5
$LL27@valueToQuo:

; 24   :    {
; 25   :       if ( isControlCharacter( *(str++) ) )

	mov	al, BYTE PTR [ecx]
	lea	ecx, DWORD PTR [ecx+1]

; 18   :    return ch > 0 && ch <= 0x1F;

	dec	al
	mov	dl, 30					; 0000001eH
	cmp	dl, al
	sbb	eax, eax
	inc	eax

; 25   :       if ( isControlCharacter( *(str++) ) )

	test	al, al
	jne	$LN7@valueToQuo

; 19   : }
; 20   : 
; 21   : static bool containsControlCharacter( const char* str )
; 22   : {
; 23   :    while ( *str ) 

	cmp	BYTE PTR [ecx], al
	jne	SHORT $LL27@valueToQuo
$LN28@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	ecx, DWORD PTR $T4[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T4[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T4[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T4[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 115  :       return std::string("\"") + value + "\"";

	push	esi
	lea	edx, DWORD PTR $T4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T31[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	mov	edx, eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, ebx
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QAV10@PBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T31[ebp+20]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 115  :       return std::string("\"") + value + "\"";

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN153@valueToQuo

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T31[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN153@valueToQuo:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR $T4[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T31[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T31[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T31[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	$LN254@valueToQuo

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
	push	DWORD PTR $T4[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 115  :       return std::string("\"") + value + "\"";

	jmp	$LN254@valueToQuo
$LN7@valueToQuo:

; 119  :    unsigned maxsize = strlen(value)*2 + 3; // allescaped+quotes+NULL

	mov	ecx, esi
	lea	edx, DWORD PTR [ecx+1]
$LL1213@valueToQuo:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL1213@valueToQuo
	sub	ecx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _result$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _result$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _result$[ebp], al
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 119  :    unsigned maxsize = strlen(value)*2 + 3; // allescaped+quotes+NULL

	lea	ecx, DWORD PTR [ecx*2+3]

; 120  :    std::string result;

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	cmp	ecx, 15					; 0000000fH
	je	SHORT $LN510@valueToQuo

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	ecx
	lea	ecx, DWORD PTR _result$[ebp]
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN510@valueToQuo

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR _result$[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR _result$[ebp]

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _result$[ebp+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmovae	eax, DWORD PTR _result$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
$LN510@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 123  :    for (const char* c=value; *c != 0; ++c)

	cmp	BYTE PTR [esi], 0
	je	$LN743@valueToQuo
	mov	ebx, DWORD PTR $T1[ebp]
$LL4@valueToQuo:

; 124  :    {
; 125  :       switch(*c)

	mov	cl, BYTE PTR [esi]
	movsx	eax, cl
	add	eax, -8					; fffffff8H
	cmp	eax, 84					; 00000054H
	ja	$LN15@valueToQuo
	movzx	eax, BYTE PTR $LN1214@valueToQuo[eax]
	jmp	DWORD PTR $LN1216@valueToQuo[eax*4]
$LN8@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02MCKKLHBJ@?2?$CC?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 129  :             break;

	jmp	$LN2@valueToQuo
$LN9@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02HDBGODGB@?2?2?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 132  :             break;

	jmp	$LN2@valueToQuo
$LN10@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02DCNDPIBM@?2b?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 135  :             break;

	jmp	$LN2@valueToQuo
$LN11@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02FGLPDNBI@?2f?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 138  :             break;

	jmp	$LN2@valueToQuo
$LN12@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02JOGGLHBA@?2n?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 141  :             break;

	jmp	$LN2@valueToQuo
$LN13@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02HIBBOKEN@?2r?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 144  :             break;

	jmp	$LN2@valueToQuo
$LN566@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02COELENML@?2t?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 147  :             break;

	jmp	$LN2@valueToQuo
$LN15@valueToQuo:

; 18   :    return ch > 0 && ch <= 0x1F;

	mov	al, cl
	mov	dl, 30					; 0000001eH
	dec	al
	cmp	dl, al
	sbb	eax, eax
	inc	eax

; 148  :          //case '/':
; 149  :             // Even though \/ is considered a legal escape in JSON, a bare
; 150  :             // slash is also legal, so I see no reason to escape it.
; 151  :             // (I hope I am not misunderstanding something.
; 152  :             // blep notes: actually escaping \/ may be useful in javascript to avoid </ 
; 153  :             // sequence.
; 154  :             // Should add a flag to allow this compatibility mode and prevent this 
; 155  :             // sequence from occurring.
; 156  :          default:
; 157  :             if ( isControlCharacter( *c ) )

	test	al, al
	je	$LN16@valueToQuo
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 492  : 		{	// construct empty writable character buffer

	lea	ecx, DWORD PTR _oss$279[ebp+80]
	mov	DWORD PTR _oss$279[ebp], OFFSET ??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	call	DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
	push	0
	push	0
	lea	eax, DWORD PTR _oss$279[ebp+4]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	or	ebx, 2

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(_Mysb::eback(),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	enum
; 350  : 		{	// constant for minimum buffer size
; 351  : 		_MINSIZE = 32};
; 352  : 
; 353  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 354  : 		{	// convert open mode to stream state bits
; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))
; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)
; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)
; 363  : 			_State |= _Atend;
; 364  : 		return (_State);
; 365  : 		}
; 366  : 
; 367  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 368  : 	_Strstate _Mystate;	// the stream state
; 369  : 	allocator_type _Al;	// the allocator object
; 370  : 	};
; 371  : 
; 372  : 	// basic_stringbuf TEMPLATE OPERATORS
; 373  : template<class _Elem,
; 374  : 	class _Traits,
; 375  : 	class _Alloc> inline
; 376  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 377  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 378  : 	{	// swap _Left and _Right basic_stringbufs
; 379  : 	_Left.swap(_Right);
; 380  : 	}
; 381  : 
; 382  : 		// TEMPLATE CLASS basic_istringstream
; 383  : template<class _Elem,
; 384  : 	class _Traits,
; 385  : 	class _Alloc>
; 386  : 	class basic_istringstream
; 387  : 		: public basic_istream<_Elem, _Traits>
; 388  : 	{	// input stream associated with a character array
; 389  : public:
; 390  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 391  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 392  : 	typedef _Alloc allocator_type;
; 393  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 394  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 395  : 
; 396  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 397  : 		: _Mybase(&_Stringbuffer),
; 398  : 			_Stringbuffer(_Mode | ios_base::in)
; 399  : 		{	// construct empty readable character buffer
; 400  : 		}
; 401  : 
; 402  : 	explicit basic_istringstream(const _Mystr& _Str,
; 403  : 		ios_base::openmode _Mode = ios_base::in)
; 404  : 		: _Mybase(&_Stringbuffer),
; 405  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 406  : 		{	// construct readable character buffer from NTCS
; 407  : 		}
; 408  : 
; 409  : 	basic_istringstream(_Myt&& _Right)
; 410  : 		: _Mybase(&_Stringbuffer)
; 411  : 		{	// construct by moving _Right
; 412  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 413  : 		}
; 414  : 
; 415  : 	_Myt& operator=(_Myt&& _Right)
; 416  : 		{	// move from _Right
; 417  : 		_Assign_rv(_STD forward<_Myt>(_Right));
; 418  : 		return (*this);
; 419  : 		}
; 420  : 
; 421  : 	void _Assign_rv(_Myt&& _Right)
; 422  : 		{	// assign by moving _Right
; 423  : 		if (this != &_Right)
; 424  : 			{	// different, worth moving
; 425  : 			_Stringbuffer.str(_Mystr());
; 426  : 			this->swap(_Right);
; 427  : 			}
; 428  : 		}
; 429  : 
; 430  : 	void swap(_Myt& _Right)
; 431  : 		{	// swap with _Right
; 432  : 		if (this != &_Right)
; 433  : 			{	// different, swap base and buffer
; 434  : 			_Mybase::swap(_Right);
; 435  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 436  : 			}
; 437  : 		}
; 438  : 
; 439  : 	basic_istringstream(const _Myt&) = delete;
; 440  : 	_Myt& operator=(const _Myt&) = delete;
; 441  : 
; 442  : 	virtual ~basic_istringstream() _NOEXCEPT
; 443  : 		{	// destroy the object
; 444  : 		}
; 445  : 
; 446  : 	_Mysb *rdbuf() const
; 447  : 		{	// return pointer to file buffer
; 448  : 		return ((_Mysb *)&_Stringbuffer);
; 449  : 		}
; 450  : 
; 451  : 	_Mystr str() const
; 452  : 		{	// return string copy of character array
; 453  : 		return (_Stringbuffer.str());
; 454  : 		}
; 455  : 
; 456  : 	void str(const _Mystr& _Newstr)
; 457  : 		{	// replace character array from string
; 458  : 		_Stringbuffer.str(_Newstr);
; 459  : 		}
; 460  : 
; 461  : private:
; 462  : 	_Mysb _Stringbuffer;	// the string buffer
; 463  : 	};
; 464  : 
; 465  : 	// basic_istringstream TEMPLATE OPERATORS
; 466  : template<class _Elem,
; 467  : 	class _Traits,
; 468  : 	class _Alloc> inline
; 469  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 470  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 471  : 	{	// swap _Left and _Right basic_istringstreams
; 472  : 	_Left.swap(_Right);
; 473  : 	}
; 474  : 
; 475  : 		// TEMPLATE CLASS basic_ostringstream
; 476  : template<class _Elem,
; 477  : 	class _Traits,
; 478  : 	class _Alloc>
; 479  : 	class basic_ostringstream
; 480  : 		: public basic_ostream<_Elem, _Traits>
; 481  : 	{	// output stream associated with a character array
; 482  : public:
; 483  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 484  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 485  : 	typedef _Alloc allocator_type;
; 486  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 487  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 488  : 
; 489  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 490  : 		: _Mybase(&_Stringbuffer),

	lea	ecx, DWORD PTR _oss$279[ebp]
	push	eax
	mov	DWORD PTR $T1[ebp], ebx
	call	DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 492  : 		{	// construct empty writable character buffer

	mov	eax, DWORD PTR _oss$279[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _oss$279[ebp+eax], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR _oss$279[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-80]
	mov	DWORD PTR _oss$279[ebp+ecx-4], eax
	lea	eax, DWORD PTR _oss$279[ebp+4]

; 30   : 		{	// construct empty character buffer from mode

	mov	ecx, eax

; 491  : 			_Stringbuffer(_Mode | ios_base::out)

	mov	DWORD PTR _this$[ebp], eax

; 30   : 		{	// construct empty character buffer from mode

	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	DWORD PTR _oss$279[ebp+4], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 311  : 		_Seekhigh = 0;

	mov	DWORD PTR _oss$279[ebp+60], 0

; 312  : 		_Mystate = _State;

	mov	DWORD PTR _oss$279[ebp+64], 4
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 160  :                oss << "\\u" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << static_cast<int>(*c);

	push	OFFSET ?uppercase@std@@YAAAVios_base@1@AAV21@@Z ; std::uppercase
	push	OFFSET ?hex@std@@YAAAVios_base@1@AAV21@@Z ; std::hex
	mov	edx, OFFSET ??_C@_02DHFAHMIK@?2u?$AA@
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR _oss$279[ebp]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
	mov	ecx, eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@P6AAAVios_base@1@AAV21@@Z@Z
	mov	edi, eax
	lea	eax, DWORD PTR $T125[ebp]
	push	0
	push	4
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip

; 62   : 	_Ostr.fill(_Manip._Fill);

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 119  : 		_Fillch = _Newfill;

	mov	BYTE PTR [ecx+edi+64], 48		; 00000030H
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 160  :                oss << "\\u" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << static_cast<int>(*c);

	call	DWORD PTR __imp_?setw@std@@YA?AU?$_Smanip@_J@1@_J@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip

; 527  : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	mov	ecx, DWORD PTR [edi]
	push	DWORD PTR [eax+12]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax]
	add	ecx, edi
	push	ecx
	call	eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 160  :                oss << "\\u" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << static_cast<int>(*c);

	movsx	eax, BYTE PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip

; 527  : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	add	esp, 24					; 00000018H
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 160  :                oss << "\\u" << std::hex << std::uppercase << std::setfill('0') << std::setw(4) << static_cast<int>(*c);

	mov	ecx, edi
	push	eax
	call	DWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV01@H@Z

; 161  :                result += oss.str();

	lea	eax, DWORD PTR $T126[ebp]
	push	eax
	lea	ecx, DWORD PTR _oss$279[ebp]
	call	?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR _result$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 161  :                result += oss.str();

	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T126[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN633@valueToQuo

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T126[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN633@valueToQuo:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 162  :             }

	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 536  : 		{	// destroy the object

	mov	eax, DWORD PTR _oss$279[ebp]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _oss$279[ebp+eax], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR _oss$279[ebp]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-80]
	mov	DWORD PTR _oss$279[ebp+ecx-4], eax

; 76   : 		_Tidy();

	lea	ecx, DWORD PTR _oss$279[ebp+4]
	mov	DWORD PTR _oss$279[ebp+4], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	lea	ecx, DWORD PTR _oss$279[ebp+4]
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ

; 537  : 		}

	lea	ecx, DWORD PTR _oss$279[ebp+8]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	lea	ecx, DWORD PTR _oss$279[ebp+80]
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 163  :             else

	jmp	SHORT $LN2@valueToQuo
$LN16@valueToQuo:

; 164  :             {
; 165  :                result += *c;

	push	ecx
	lea	ecx, DWORD PTR _result$[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN2@valueToQuo:

; 123  :    for (const char* c=value; *c != 0; ++c)

	inc	esi
	cmp	BYTE PTR [esi], 0
	jne	$LL4@valueToQuo
	mov	ebx, DWORD PTR ___$ReturnUdt$GSCopy$1$[ebp]
$LN743@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01BJJEKLCA@?$CC?$AA@
	lea	ecx, DWORD PTR _result$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ebx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ebx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ebx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

	mov	ecx, DWORD PTR _result$[ebp+20]
	cmp	ecx, 16					; 00000010H
	jae	SHORT $LN871@valueToQuo

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

	mov	eax, DWORD PTR _result$[ebp+16]
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN872@valueToQuo
	push	eax
	lea	eax, DWORD PTR _result$[ebp]
	push	eax
	push	ebx
	call	DWORD PTR __imp__memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	mov	ecx, DWORD PTR _result$[ebp+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	jmp	SHORT $LN872@valueToQuo
$LN871@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR [ebx], eax
$LN872@valueToQuo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 970  : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR _result$[ebp+16]
	mov	DWORD PTR [ebx+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

	mov	DWORD PTR [ebx+20], ecx
$LN254@valueToQuo:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 171  :    return result;

	mov	eax, ebx

; 172  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN1216@valueToQuo:
	DD	$LN10@valueToQuo
	DD	$LN566@valueToQuo
	DD	$LN12@valueToQuo
	DD	$LN11@valueToQuo
	DD	$LN13@valueToQuo
	DD	$LN8@valueToQuo
	DD	$LN9@valueToQuo
	DD	$LN15@valueToQuo
$LN1214@valueToQuo:
	DB	0
	DB	1
	DB	2
	DB	7
	DB	3
	DB	4
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	5
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	7
	DB	6
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$0:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$1:
	lea	ecx, DWORD PTR $T31[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$3:
	lea	ecx, DWORD PTR _result$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$125:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 2
	je	$LN576@valueToQuo
	and	DWORD PTR $T1[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR _oss$279[ebp+80]
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN576@valueToQuo:
	ret	0
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$126:
	lea	ecx, DWORD PTR _oss$279[ebp+8]
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$128:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$4:
	lea	ecx, DWORD PTR _oss$279[ebp]
	jmp	??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
__unwindfunclet$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z$5:
	lea	ecx, DWORD PTR $T126[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-280]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ENDP ; Json::valueToQuotedString
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ
_TEXT	SEGMENT
??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
; _this$ = ecx

; 536  : 		{	// destroy the object

	mov	eax, DWORD PTR [ecx]
	push	esi
	push	edi
	lea	edi, DWORD PTR [ecx+80]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+edi-80], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR [edi-80]
	mov	ecx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [ecx-80]
	mov	DWORD PTR [ecx+edi-84], eax

; 76   : 		_Tidy();

	lea	ecx, DWORD PTR [edi-76]
	mov	DWORD PTR [edi-76], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	lea	ecx, DWORD PTR [edi-76]
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ

; 537  : 		}

	lea	ecx, DWORD PTR [edi-72]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, edi
	pop	edi
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
??_D?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXXZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ??0FastWriter@Json@@QAE@XZ
_TEXT	SEGMENT
??0FastWriter@Json@@QAE@XZ PROC				; Json::FastWriter::FastWriter, COMDAT
; _this$ = ecx

; 186  : {

	mov	DWORD PTR [ecx], OFFSET ??_7FastWriter@Json@@6B@

; 187  : }

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+24], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+4], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 185  :    : yamlCompatiblityEnabled_( false )

	mov	BYTE PTR [ecx+28], 0

; 187  : }

	ret	0
??0FastWriter@Json@@QAE@XZ ENDP				; Json::FastWriter::FastWriter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ
_TEXT	SEGMENT
?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ PROC	; Json::FastWriter::enableYAMLCompatibility, COMDAT
; _this$ = ecx

; 193  :    yamlCompatiblityEnabled_ = true;

	mov	BYTE PTR [ecx+28], 1

; 194  : }

	ret	0
?enableYAMLCompatibility@FastWriter@Json@@QAEXXZ ENDP	; Json::FastWriter::enableYAMLCompatibility
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
tv952 = -72						; size = 4
_size$1$ = -72						; size = 4
$T75 = -72						; size = 1
tv956 = -68						; size = 4
$T36 = -64						; size = 24
$T10 = -40						; size = 24
$T8 = -40						; size = 24
$T5 = -40						; size = 24
$T3 = -40						; size = 24
$T1 = -40						; size = 24
_members$97 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z PROC	; Json::FastWriter::writeValue, COMDAT
; _this$ = ecx

; 209  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	edi, DWORD PTR _value$[ebp]

; 210  :    switch ( value.type() )

	movsx	eax, BYTE PTR [edi+8]
	cmp	eax, 7
	ja	$LN310@writeValue
	jmp	DWORD PTR $LN420@writeValue[eax*4]
$LN10@writeValue:

; 211  :    {
; 212  :    case nullValue:
; 213  :       document_ += "null";

	push	OFFSET ??_C@_04MLLLIHIP@null?$AA@
	lea	ecx, DWORD PTR [ebx+4]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 214  :       break;

	jmp	$LN310@writeValue
$LN11@writeValue:

; 216  :       document_ += valueToString( value.asInt() );

	mov	ecx, edi
	call	?asInt@Value@Json@@QBEHXZ		; Json::Value::asInt
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 0
$LN419@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 216  :       document_ += valueToString( value.asInt() );

	lea	ecx, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 216  :       document_ += valueToString( value.asInt() );

	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 217  :       break;

	jmp	$LN310@writeValue
$LN12@writeValue:

; 218  :    case uintValue:
; 219  :       document_ += valueToString( value.asUInt() );

	mov	ecx, edi
	call	?asUInt@Value@Json@@QBEIXZ		; Json::Value::asUInt
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 220  :       break;

	jmp	SHORT $LN419@writeValue
$LN13@writeValue:

; 221  :    case realValue:
; 222  :       document_ += valueToString( value.asDouble() );

	mov	ecx, edi
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	lea	eax, DWORD PTR $T5[ebp]
	fstp	QWORD PTR [esp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 223  :       break;

	jmp	SHORT $LN419@writeValue
$LN14@writeValue:

; 224  :    case stringValue:
; 225  :       document_ += valueToQuotedString( value.asCString() );

	push	DWORD PTR [edi]
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 226  :       break;

	jmp	SHORT $LN419@writeValue
$LN15@writeValue:

; 227  :    case booleanValue:
; 228  :       document_ += valueToString( value.asBool() );

	mov	ecx, edi
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	movzx	eax, al
	push	eax
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 229  :       break;

	jmp	$LN419@writeValue
$LN16@writeValue:

; 230  :    case arrayValue:
; 231  :       {
; 232  :          document_ += "[";

	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	lea	ecx, DWORD PTR [ebx+4]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=

; 233  :          int size = value.size();

	mov	ecx, edi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size

; 234  :          for ( int index =0; index < size; ++index )

	xor	esi, esi
	mov	DWORD PTR _size$1$[ebp], eax
	test	eax, eax
	jle	SHORT $LN66@writeValue
$LL6@writeValue:

; 235  :          {
; 236  :             if ( index > 0 )

	test	esi, esi
	jle	SHORT $LN17@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR [ebx+4]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN17@writeValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 238  :             writeValue( value[index] );

	push	esi
	mov	ecx, edi
	call	??AValue@Json@@QBEABV01@I@Z		; Json::Value::operator[]
	push	eax
	mov	ecx, ebx
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue
	inc	esi
	cmp	esi, DWORD PTR _size$1$[ebp]
	jl	SHORT $LL6@writeValue
$LN66@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	lea	ecx, DWORD PTR [ebx+4]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 242  :       break;

	jmp	$LN310@writeValue
$LN18@writeValue:

; 243  :    case objectValue:
; 244  :       {
; 245  :          Value::Members members( value.getMemberNames() );

	lea	eax, DWORD PTR _members$97[ebp]
	mov	ecx, edi
	push	eax
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames

; 246  :          document_ += "{";

	lea	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	mov	ecx, eax
	mov	DWORD PTR tv956[ebp], eax
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR _members$97[ebp]
	mov	esi, eax

; 214  : 		return (_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR _members$97[ebp+4]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 248  :                it != members.end(); 

	je	$LN304@writeValue
$LL9@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 214  : 		return (_Ptr == _Right._Ptr);

	cmp	esi, eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 252  :             if ( it != members.begin() )

	je	SHORT $LN19@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR [ebx+4]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN19@writeValue:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN181@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN182@writeValue
$LN181@writeValue:
	mov	eax, esi
$LN182@writeValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 254  :             document_ += valueToQuotedString( name.c_str() );

	push	eax
	lea	eax, DWORD PTR $T36[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR [ebx+4]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 254  :             document_ += valueToQuotedString( name.c_str() );

	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 254  :             document_ += valueToQuotedString( name.c_str() );

	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T36[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN195@writeValue

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T36[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN195@writeValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 255  :             document_ += yamlCompatiblityEnabled_ ? ": " 

	cmp	BYTE PTR [ebx+28], 0
	mov	edx, OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
	mov	eax, OFFSET ??_C@_01JLIPDDHJ@?3?$AA@
	cmove	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN296@writeValue
	xor	ecx, ecx
	jmp	SHORT $LN297@writeValue
$LN296@writeValue:
	mov	ecx, edx
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR tv952[ebp], eax
$LL417@writeValue:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL417@writeValue
	sub	ecx, DWORD PTR tv952[ebp]
$LN297@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	lea	ecx, DWORD PTR [ebx+4]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 257  :             writeValue( value[name] );

	push	esi
	mov	ecx, edi
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	push	eax
	mov	ecx, ebx
	call	?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ; Json::FastWriter::writeValue
	mov	eax, DWORD PTR _members$97[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 113  : 		++_Ptr;

	add	esi, 24					; 00000018H

; 214  : 		return (_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR _members$97[ebp+4]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 248  :                it != members.end(); 

	jne	$LL9@writeValue
$LN304@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, DWORD PTR tv956[ebp]
	push	1
	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	esi, DWORD PTR _members$97[ebp]
	test	esi, esi
	je	SHORT $LN310@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T75[ebp]
	mov	edx, DWORD PTR _members$97[ebp+4]
	push	ecx
	mov	ecx, esi
	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	ecx, DWORD PTR _members$97[ebp+8]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	push	esi
	call	?deallocate@?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@QAEXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@I@Z ; std::_Wrap_alloc<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::deallocate
$LN310@writeValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 263  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	2
$LN420@writeValue:
	DD	$LN10@writeValue
	DD	$LN11@writeValue
	DD	$LN12@writeValue
	DD	$LN13@writeValue
	DD	$LN14@writeValue
	DD	$LN15@writeValue
	DD	$LN16@writeValue
	DD	$LN18@writeValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T5[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$5:
	lea	ecx, DWORD PTR _members$97[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z$6:
	lea	ecx, DWORD PTR $T36[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeValue@FastWriter@Json@@AAEXABVValue@2@@Z ENDP	; Json::FastWriter::writeValue
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
_value$GSCopy$1$ = -68					; size = 4
$T66 = -64						; size = 24
$T32 = -64						; size = 24
$T21 = -64						; size = 24
$T20 = -64						; size = 24
$T11 = -40						; size = 24
$T9 = -40						; size = 24
$T6 = -40						; size = 24
$T4 = -40						; size = 24
$T2 = -40						; size = 24
$T1 = -40						; size = 24
_members$68 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC	; Json::StyledWriter::writeValue, COMDAT
; _this$ = ecx

; 292  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	ebx, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$GSCopy$1$[ebp], ebx

; 293  :    switch ( value.type() )

	movsx	eax, BYTE PTR [ebx+8]
	cmp	eax, 7
	ja	$LN2@writeValue
	jmp	DWORD PTR $LN303@writeValue[eax*4]
$LN6@writeValue:

; 296  :       pushValue( "null" );

	push	OFFSET ??_C@_04MLLLIHIP@null?$AA@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 439  :       childValues_.push_back( value );

	lea	eax, DWORD PTR $T1[ebp]
$LN302@writeValue:

; 349  : 
; 350  : 
; 351  : void 
; 352  : StyledWriter::writeArrayValue( const Value &value )
; 353  : {
; 354  :    unsigned size = value.size();
; 355  :    if ( size == 0 )
; 356  :       pushValue( "[]" );
; 357  :    else
; 358  :    {
; 359  :       bool isArrayMultiLine = isMultineArray( value );
; 360  :       if ( isArrayMultiLine )
; 361  :       {
; 362  :          writeWithIndent( "[" );
; 363  :          indent();
; 364  :          bool hasChildValue = !childValues_.empty();
; 365  :          unsigned index =0;
; 366  :          while ( true )
; 367  :          {
; 368  :             const Value &childValue = value[index];
; 369  :             writeCommentBeforeValue( childValue );
; 370  :             if ( hasChildValue )
; 371  :                writeWithIndent( childValues_[index] );
; 372  :             else
; 373  :             {
; 374  :                writeIndent();
; 375  :                writeValue( childValue );
; 376  :             }
; 377  :             if ( ++index == size )
; 378  :             {
; 379  :                writeCommentAfterValueOnSameLine( childValue );
; 380  :                break;
; 381  :             }
; 382  :             document_ += ",";
; 383  :             writeCommentAfterValueOnSameLine( childValue );
; 384  :          }
; 385  :          unindent();
; 386  :          writeWithIndent( "]" );
; 387  :       }
; 388  :       else // output on a single line
; 389  :       {
; 390  :          assert( childValues_.size() == size );
; 391  :          document_ += "[ ";
; 392  :          for ( unsigned index =0; index < size; ++index )
; 393  :          {
; 394  :             if ( index > 0 )
; 395  :                document_ += ", ";
; 396  :             document_ += childValues_[index];
; 397  :          }
; 398  :          document_ += " ]";
; 399  :       }
; 400  :    }
; 401  : }
; 402  : 
; 403  : 
; 404  : bool 
; 405  : StyledWriter::isMultineArray( const Value &value )
; 406  : {
; 407  :    int size = value.size();
; 408  :    bool isMultiLine = size*3 >= rightMargin_ ;
; 409  :    childValues_.clear();
; 410  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )
; 411  :    {
; 412  :       const Value &childValue = value[index];
; 413  :       isMultiLine = isMultiLine  ||
; 414  :                      ( (childValue.isArray()  ||  childValue.isObject())  &&  
; 415  :                         childValue.size() > 0 );
; 416  :    }
; 417  :    if ( !isMultiLine ) // check if line length > max line length
; 418  :    {
; 419  :       childValues_.reserve( size );
; 420  :       addChildValues_ = true;
; 421  :       int lineLength = 4 + (size-1)*2; // '[ ' + ', '*n + ' ]'
; 422  :       for ( int index =0; index < size  &&  !isMultiLine; ++index )
; 423  :       {
; 424  :          writeValue( value[index] );
; 425  :          lineLength += int( childValues_[index].length() );
; 426  :          isMultiLine = isMultiLine  &&  hasCommentForValue( value[index] );
; 427  :       }
; 428  :       addChildValues_ = false;
; 429  :       isMultiLine = isMultiLine  ||  lineLength >= rightMargin_;
; 430  :    }
; 431  :    return isMultiLine;
; 432  : }
; 433  : 
; 434  : 
; 435  : void 
; 436  : StyledWriter::pushValue( const std::string &value )
; 437  : {
; 438  :    if ( addChildValues_ )

	cmp	BYTE PTR [edi+72], 0
	je	SHORT $LN32@writeValue

; 439  :       childValues_.push_back( value );

	push	eax
	lea	ecx, DWORD PTR [edi+4]
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 296  :       pushValue( "null" );

	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 297  :       break;

	jmp	$LN2@writeValue
$LN32@writeValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 441  :       document_ += value;

	lea	ecx, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 296  :       pushValue( "null" );

	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 297  :       break;

	jmp	$LN2@writeValue
$LN7@writeValue:

; 298  :    case intValue:
; 299  :       pushValue( valueToString( value.asInt() ) );

	mov	ecx, ebx
	call	?asInt@Value@Json@@QBEHXZ		; Json::Value::asInt
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 440  :    else

	jmp	SHORT $LN302@writeValue
$LN8@writeValue:

; 300  :       break;
; 301  :    case uintValue:
; 302  :       pushValue( valueToString( value.asUInt() ) );

	mov	ecx, ebx
	call	?asUInt@Value@Json@@QBEIXZ		; Json::Value::asUInt
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 2

; 440  :    else

	jmp	SHORT $LN302@writeValue
$LN9@writeValue:

; 303  :       break;
; 304  :    case realValue:
; 305  :       pushValue( valueToString( value.asDouble() ) );

	mov	ecx, ebx
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	lea	eax, DWORD PTR $T6[ebp]
	fstp	QWORD PTR [esp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 440  :    else

	jmp	$LN302@writeValue
$LN10@writeValue:

; 306  :       break;
; 307  :    case stringValue:
; 308  :       pushValue( valueToQuotedString( value.asCString() ) );

	push	DWORD PTR [ebx]
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 440  :    else

	jmp	$LN302@writeValue
$LN11@writeValue:

; 309  :       break;
; 310  :    case booleanValue:
; 311  :       pushValue( valueToString( value.asBool() ) );

	mov	ecx, ebx
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	movzx	eax, al
	push	eax
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 440  :    else

	jmp	$LN302@writeValue
$LN12@writeValue:

; 312  :       break;
; 313  :    case arrayValue:
; 314  :       writeArrayValue( value);

	push	ebx
	call	?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeArrayValue

; 315  :       break;

	jmp	$LN2@writeValue
$LN13@writeValue:

; 316  :    case objectValue:
; 317  :       {
; 318  :          Value::Members members( value.getMemberNames() );

	lea	eax, DWORD PTR _members$68[ebp]
	mov	ecx, ebx
	push	eax
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 320  :             pushValue( "{}" );

	lea	ecx, DWORD PTR $T20[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	esi, DWORD PTR _members$68[ebp]
	cmp	esi, DWORD PTR _members$68[ebp+4]
	sete	al
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 319  :          if ( members.empty() )

	test	al, al
	je	SHORT $LN14@writeValue

; 320  :             pushValue( "{}" );

	push	OFFSET ??_C@_02MCILKGOH@?$HL?$HN?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T20[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	push	eax
	mov	ecx, edi
	call	?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::pushValue

; 321  :          else

	jmp	$LN301@writeValue
$LN14@writeValue:

; 322  :          {
; 323  :             writeWithIndent( "{" );

	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T21[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	push	eax
	mov	ecx, edi
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	lea	ecx, DWORD PTR $T21[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 324  :             indent();

	mov	ecx, edi
	call	?indent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::indent
$LL4@writeValue:

; 325  :             Value::Members::iterator it = members.begin();
; 326  :             while ( true )
; 327  :             {
; 328  :                const std::string &name = *it;
; 329  :                const Value &childValue = value[name];

	push	esi
	mov	ecx, ebx
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]
	mov	ebx, eax

; 330  :                writeCommentBeforeValue( childValue );

	mov	ecx, edi
	push	ebx
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN143@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN144@writeValue
$LN143@writeValue:
	mov	eax, esi
$LN144@writeValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 331  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	push	eax
	lea	eax, DWORD PTR $T32[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	push	eax
	mov	ecx, edi
	mov	BYTE PTR __$EHRec$[ebp+8], 9
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T32[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN153@writeValue

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T32[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN153@writeValue:

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	3
	push	OFFSET ??_C@_03MCPBMLDJ@?5?3?5?$AA@
	lea	ecx, DWORD PTR [edi+16]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 333  :                writeValue( childValue );

	push	ebx
	mov	ecx, edi
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 113  : 		++_Ptr;

	add	esi, 24					; 00000018H

; 214  : 		return (_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR _members$68[ebp+4]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 334  :                if ( ++it == members.end() )

	je	SHORT $LN297@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	lea	ecx, DWORD PTR [edi+16]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 340  :                writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	mov	ecx, edi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 341  :             }

	mov	ebx, DWORD PTR _value$GSCopy$1$[ebp]
	jmp	$LL4@writeValue
$LN297@writeValue:

; 335  :                {
; 336  :                   writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	mov	ecx, edi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 342  :             unindent();

	mov	ecx, edi
	call	?unindent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::unindent

; 343  :             writeWithIndent( "}" );

	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	lea	ecx, DWORD PTR $T66[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	eax, DWORD PTR $T66[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	push	eax
	mov	ecx, edi
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
$LN301@writeValue:
	lea	ecx, DWORD PTR $T66[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 344  :          }
; 345  :       }

	lea	ecx, DWORD PTR _members$68[ebp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN2@writeValue:

; 346  :       break;
; 347  :    }
; 348  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
	npad	1
$LN303@writeValue:
	DD	$LN6@writeValue
	DD	$LN7@writeValue
	DD	$LN8@writeValue
	DD	$LN9@writeValue
	DD	$LN10@writeValue
	DD	$LN11@writeValue
	DD	$LN12@writeValue
	DD	$LN13@writeValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$5:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$6:
	lea	ecx, DWORD PTR _members$68[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$7:
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$8:
	lea	ecx, DWORD PTR $T21[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$9:
	lea	ecx, DWORD PTR $T32[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$10:
	lea	ecx, DWORD PTR $T66[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP	; Json::StyledWriter::writeValue
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T114 = -104						; size = 4
_key$221 = -100						; size = 8
tv2267 = -92						; size = 4
tv2256 = -88						; size = 4
_value$GSCopy$1$ = -84					; size = 4
_size$1$ = -80						; size = 4
tv2249 = -76						; size = 4
_value$1$ = -76						; size = 4
_index$1$ = -72						; size = 4
tv2238 = -68						; size = 4
$T164 = -64						; size = 24
$T54 = -40						; size = 24
$T1 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeArrayValue, COMDAT
; _this$ = ecx

; 353  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _value$[ebp]

; 354  :    unsigned size = value.size();

	mov	ecx, esi
	mov	DWORD PTR _value$GSCopy$1$[ebp], esi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	ebx, eax
	mov	DWORD PTR _size$1$[ebp], ebx

; 355  :    if ( size == 0 )

	test	ebx, ebx
	jne	SHORT $LN7@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02GPECMEKF@?$FL?$FN?$AA@
	lea	ecx, DWORD PTR $T1[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T1[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T1[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T1[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 356  :       pushValue( "[]" );

	mov	DWORD PTR __$EHRec$[ebp+8], ebx

; 439  :       childValues_.push_back( value );

	lea	eax, DWORD PTR $T1[ebp]
	cmp	BYTE PTR [edi+72], bl
	je	SHORT $LN132@writeArray
	lea	ecx, DWORD PTR [edi+4]
	push	eax
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 440  :    else

	jmp	SHORT $LN133@writeArray
$LN132@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 441  :       document_ += value;

	lea	ecx, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN133@writeArray:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T1[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	$LN10@writeArray

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T1[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 357  :    else

	jmp	$LN10@writeArray
$LN7@writeArray:

; 358  :    {
; 359  :       bool isArrayMultiLine = isMultineArray( value );

	push	esi
	mov	ecx, edi
	call	?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledWriter::isMultineArray

; 360  :       if ( isArrayMultiLine )

	test	al, al
	je	$LN923@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	lea	ecx, DWORD PTR $T54[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T54[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T54[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T54[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 362  :          writeWithIndent( "[" );

	lea	eax, DWORD PTR $T54[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	eax
	mov	ecx, edi
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T54[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN358@writeArray

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T54[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN358@writeArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 363  :          indent();

	mov	ecx, edi
	call	?indent@StyledWriter@Json@@AAEXXZ	; Json::StyledWriter::indent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR tv2267[ebp], eax
	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR tv2256[ebp], eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 365  :          unsigned index =0;

	xor	eax, eax
	xor	esi, esi
	mov	DWORD PTR _index$1$[ebp], eax
	mov	DWORD PTR tv2238[ebp], esi
$LL2@writeArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 999  :    if ( type_ == nullValue )

	mov	ecx, DWORD PTR _value$GSCopy$1$[ebp]
	cmp	BYTE PTR [ecx+8], 0
	jne	SHORT $LN475@writeArray

; 1000 :       return null;

	mov	ebx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN474@writeArray
$LN475@writeArray:

; 1001 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1002 :    CZString key( index );
; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	mov	esi, DWORD PTR [ecx]
	mov	ecx, esi

; 176  :    , index_( index )

	mov	DWORD PTR _key$221[ebp+4], eax

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	lea	eax, DWORD PTR _key$221[ebp]
	push	eax
	lea	eax, DWORD PTR $T114[ebp]

; 175  :    : cstr_( 0 )

	mov	DWORD PTR _key$221[ebp], 0

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	push	eax
	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1004 :    if ( it == value_.map_->end() )

	jne	SHORT $LN476@writeArray

; 1005 :       return null;

	mov	ebx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN965@writeArray
$LN476@writeArray:

; 1006 :    return (*it).second;

	lea	ebx, DWORD PTR [eax+24]
$LN965@writeArray:
	mov	esi, DWORD PTR tv2238[ebp]

; 200  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN474@writeArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 369  :             writeCommentBeforeValue( childValue );

	push	ebx
	mov	ecx, edi
	call	?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentBeforeValue
	mov	eax, DWORD PTR tv2256[ebp]
	cmp	DWORD PTR tv2267[ebp], eax

; 370  :             if ( hasChildValue )

	je	SHORT $LN11@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [edi+4]
	add	eax, esi
	cmp	DWORD PTR [edi+32], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 320  : 		return (_Myval2);

	lea	esi, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	DWORD PTR _value$1$[ebp], eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 448  :    if ( !document_.empty() )

	je	SHORT $LN542@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1760 : 		return (this->_Mysize());

	mov	ecx, DWORD PTR [edi+32]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN580@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN581@writeArray
$LN580@writeArray:
	mov	eax, esi
$LN581@writeArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 450  :       char last = document_[document_.length()-1];

	mov	al, BYTE PTR [ecx+eax-1]

; 451  :       if ( last == ' ' )     // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN539@writeArray

; 452  :          return;
; 453  :       if ( last != '\n' )    // Comments may add new-line

	cmp	al, 10					; 0000000aH
	je	SHORT $LN542@writeArray

; 454  :          document_ += '\n';

	push	10					; 0000000aH
	mov	ecx, esi
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN542@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 456  :    document_ += indentString_;

	lea	eax, DWORD PTR [edi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	mov	ecx, esi
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN539@writeArray:
	push	-1
	push	0
	push	DWORD PTR _value$1$[ebp]
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 372  :             else

	jmp	SHORT $LN12@writeArray
$LN11@writeArray:
	cmp	DWORD PTR [edi+32], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 320  : 		return (_Myval2);

	lea	esi, DWORD PTR [edi+16]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 448  :    if ( !document_.empty() )

	je	SHORT $LN595@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 1760 : 		return (this->_Mysize());

	mov	ecx, DWORD PTR [edi+32]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN633@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN634@writeArray
$LN633@writeArray:
	mov	eax, esi
$LN634@writeArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 450  :       char last = document_[document_.length()-1];

	mov	al, BYTE PTR [ecx+eax-1]

; 451  :       if ( last == ' ' )     // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN592@writeArray

; 452  :          return;
; 453  :       if ( last != '\n' )    // Comments may add new-line

	cmp	al, 10					; 0000000aH
	je	SHORT $LN595@writeArray

; 454  :          document_ += '\n';

	push	10					; 0000000aH
	mov	ecx, esi
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN595@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 456  :    document_ += indentString_;

	lea	eax, DWORD PTR [edi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	mov	ecx, esi
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN592@writeArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 375  :                writeValue( childValue );

	push	ebx
	mov	ecx, edi
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
$LN12@writeArray:

; 376  :             }
; 377  :             if ( ++index == size )

	mov	eax, DWORD PTR _index$1$[ebp]
	add	DWORD PTR tv2238[ebp], 24		; 00000018H
	inc	eax
	mov	DWORD PTR _index$1$[ebp], eax
	cmp	eax, DWORD PTR _size$1$[ebp]
	je	SHORT $LN958@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 383  :             writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	mov	ecx, edi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine

; 384  :          }

	mov	eax, DWORD PTR _index$1$[ebp]
	mov	esi, DWORD PTR tv2238[ebp]
	jmp	$LL2@writeArray
$LN958@writeArray:

; 378  :             {
; 379  :                writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	mov	ecx, edi
	call	?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeCommentAfterValueOnSameLine
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1765 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [edi+56]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 479  :    indentString_.resize( indentString_.size() - indentSize_ );

	lea	ecx, DWORD PTR [edi+40]
	sub	eax, DWORD PTR [edi+68]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	cmp	eax, edx
	ja	SHORT $LN666@writeArray

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN689@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN689@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN667@writeArray
$LN666@writeArray:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	push	0
	sub	eax, edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN667@writeArray:

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	lea	ecx, DWORD PTR $T164[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T164[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T164[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T164[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 386  :          writeWithIndent( "]" );

	lea	eax, DWORD PTR $T164[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	push	eax
	mov	ecx, edi
	call	?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::StyledWriter::writeWithIndent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T164[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN10@writeArray

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T164[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 388  :       else // output on a single line

	jmp	SHORT $LN10@writeArray
$LN923@writeArray:

; 391  :          document_ += "[ ";

	lea	eax, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02PFNDMDBO@?$FL?5?$AA@
	mov	ecx, eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 391  :          document_ += "[ ";

	mov	DWORD PTR tv2249[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 392  :          for ( unsigned index =0; index < size; ++index )

	xor	esi, esi
	test	ebx, ebx
	je	SHORT $LN954@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	xor	ebx, ebx
	npad	6
$LL6@writeArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 394  :             if ( index > 0 )

	test	esi, esi
	je	SHORT $LN14@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	lea	ecx, DWORD PTR [edi+16]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN14@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [edi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	lea	ecx, DWORD PTR [edi+16]
	push	-1
	push	0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 392  :          for ( unsigned index =0; index < size; ++index )

	inc	esi
	add	ebx, 24					; 00000018H
	cmp	esi, DWORD PTR _size$1$[ebp]
	jb	SHORT $LL6@writeArray
$LN954@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, DWORD PTR tv2249[ebp]
	push	2
	push	OFFSET ??_C@_02DHOGEDBE@?5?$FN?$AA@
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN10@writeArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 401  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T54[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$124:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$125:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T164[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-108]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeArrayValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeArrayValue
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
_key$75 = -44						; size = 8
_key$76 = -36						; size = 8
$T42 = -32						; size = 4
tv1055 = -28						; size = 4
$T16 = -28						; size = 4
_this$1$ = -24						; size = 4
_this$1$ = -20						; size = 4
_lineLength$1$ = -16					; size = 4
_size$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T9 = 8							; size = 1
_value$ = 8						; size = 4
?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledWriter::isMultineArray, COMDAT
; _this$ = ecx

; 406  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 407  :    int size = value.size();

	mov	esi, DWORD PTR _value$[ebp]
	mov	ecx, esi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T9[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 407  :    int size = value.size();

	mov	DWORD PTR _size$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	ecx
	mov	ecx, DWORD PTR [edi+4]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 408  :    bool isMultiLine = size*3 >= rightMargin_ ;

	lea	edx, DWORD PTR [eax+eax*2]
	cmp	edx, DWORD PTR [edi+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	edx, DWORD PTR [edi+8]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 408  :    bool isMultiLine = size*3 >= rightMargin_ ;

	setge	bl

; 409  :    childValues_.clear();

	add	edi, 4
	mov	DWORD PTR _this$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [edi+4], eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 410  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	xor	edi, edi
	cmp	DWORD PTR _size$1$[ebp], edi
	jle	SHORT $LN3@isMultineA
$LL4@isMultineA:
	test	bl, bl
	jne	$LN16@isMultineA
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 999  :    if ( type_ == nullValue )

	cmp	BYTE PTR [esi+8], bl
	jne	SHORT $LN68@isMultineA

; 1000 :       return null;

	mov	ecx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN325@isMultineA
$LN68@isMultineA:

; 1001 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1002 :    CZString key( index );
; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	mov	esi, DWORD PTR [esi]
	lea	eax, DWORD PTR _key$76[ebp]
	push	eax
	lea	eax, DWORD PTR $T16[ebp]

; 175  :    : cstr_( 0 )

	mov	DWORD PTR _key$76[ebp], 0

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	push	eax
	mov	ecx, esi

; 176  :    , index_( index )

	mov	DWORD PTR _key$76[ebp+4], edi

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1004 :    if ( it == value_.map_->end() )

	jne	SHORT $LN69@isMultineA

; 1005 :       return null;

	mov	ecx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN329@isMultineA
$LN69@isMultineA:

; 1006 :    return (*it).second;

	lea	ecx, DWORD PTR [eax+24]
$LN329@isMultineA:

; 200  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, DWORD PTR _value$[ebp]
$LN325@isMultineA:

; 1315 :    return type_ == nullValue  ||  type_ == arrayValue;

	mov	al, BYTE PTR [ecx+8]
	test	al, al
	je	SHORT $LN125@isMultineA
	cmp	al, 6
	je	SHORT $LN125@isMultineA

; 1322 :    return type_ == nullValue  ||  type_ == objectValue;

	cmp	al, 7
	jne	SHORT $LN11@isMultineA
$LN125@isMultineA:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 413  :       isMultiLine = isMultiLine  ||

	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	test	eax, eax
	jne	SHORT $LN12@isMultineA
$LN11@isMultineA:
	xor	bl, bl
	jmp	SHORT $LN13@isMultineA
$LN12@isMultineA:
	mov	bl, 1
$LN13@isMultineA:

; 410  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	inc	edi
	cmp	edi, DWORD PTR _size$1$[ebp]
	jl	SHORT $LL4@isMultineA
$LN3@isMultineA:

; 414  :                      ( (childValue.isArray()  ||  childValue.isObject())  &&  
; 415  :                         childValue.size() > 0 );
; 416  :    }
; 417  :    if ( !isMultiLine ) // check if line length > max line length

	test	bl, bl
	jne	$LN16@isMultineA
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edi, DWORD PTR _this$1$[ebp]
	mov	eax, 715827883				; 2aaaaaabH

; 1033 : 		if (capacity() < _Count)

	mov	ebx, DWORD PTR _size$1$[ebp]

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi]
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1033 : 		if (capacity() < _Count)

	cmp	eax, ebx
	jae	SHORT $LN128@isMultineA

; 1034 : 			{	// something to do, check and reallocate
; 1035 : 			if (max_size() < _Count)

	cmp	ebx, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN129@isMultineA

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN331@isMultineA:
$LN129@isMultineA:

; 1037 : 			_Reallocate(_Count);

	push	ebx
	mov	ecx, edi
	call	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN128@isMultineA:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 420  :       addChildValues_ = true;

	mov	eax, DWORD PTR _this$1$[ebp]

; 421  :       int lineLength = 4 + (size-1)*2; // '[ ' + ', '*n + ' ]'

	lea	edx, DWORD PTR [ebx*2+2]

; 422  :       for ( int index =0; index < size  &&  !isMultiLine; ++index )

	xor	edi, edi
	mov	DWORD PTR _lineLength$1$[ebp], edx
	mov	BYTE PTR [eax+72], 1
	test	ebx, ebx
	jle	SHORT $LN6@isMultineA

; 420  :       addChildValues_ = true;

	mov	DWORD PTR tv1055[ebp], edi
$LL7@isMultineA:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 999  :    if ( type_ == nullValue )

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN175@isMultineA

; 1000 :       return null;

	mov	eax, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN174@isMultineA
$LN175@isMultineA:

; 1001 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1002 :    CZString key( index );
; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	mov	esi, DWORD PTR [esi]
	lea	eax, DWORD PTR _key$75[ebp]
	push	eax
	lea	eax, DWORD PTR $T42[ebp]

; 175  :    : cstr_( 0 )

	mov	DWORD PTR _key$75[ebp], 0

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	push	eax
	mov	ecx, esi

; 176  :    , index_( index )

	mov	DWORD PTR _key$75[ebp+4], edi

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1004 :    if ( it == value_.map_->end() )

	jne	SHORT $LN176@isMultineA

; 1005 :       return null;

	mov	eax, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN330@isMultineA
$LN176@isMultineA:

; 1006 :    return (*it).second;

	add	eax, 24					; 00000018H
$LN330@isMultineA:

; 200  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, DWORD PTR _value$[ebp]
$LN174@isMultineA:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 424  :          writeValue( value[index] );

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	eax
	call	?writeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledWriter::writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR _this$1$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 422  :       for ( int index =0; index < size  &&  !isMultiLine; ++index )

	inc	edi

; 425  :          lineLength += int( childValues_[index].length() );

	mov	edx, DWORD PTR _lineLength$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1055[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 425  :          lineLength += int( childValues_[index].length() );

	add	edx, DWORD PTR [eax+ecx+16]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR _lineLength$1$[ebp], edx
	mov	DWORD PTR tv1055[ebp], ecx
	cmp	edi, ebx
	jl	SHORT $LL7@isMultineA
	mov	eax, DWORD PTR _this$1$[ebp]
$LN6@isMultineA:

; 426  :          isMultiLine = isMultiLine  &&  hasCommentForValue( value[index] );
; 427  :       }
; 428  :       addChildValues_ = false;
; 429  :       isMultiLine = isMultiLine  ||  lineLength >= rightMargin_;

	cmp	edx, DWORD PTR [eax+64]
	mov	BYTE PTR [eax+72], 0
	setge	bl
$LN16@isMultineA:

; 430  :    }
; 431  :    return isMultiLine;

	mov	al, bl

; 432  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN328@isMultineA:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z$23:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z$24:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z$46:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z$47:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?isMultineArray@StyledWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledWriter::isMultineArray
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledWriter::pushValue, COMDAT
; _this$ = ecx

; 437  : {

	push	ebp
	mov	ebp, esp

; 438  :    if ( addChildValues_ )

	cmp	BYTE PTR [ecx+72], 0
	je	SHORT $LN2@pushValue

; 439  :       childValues_.push_back( value );

	add	ecx, 4

; 442  : }

	pop	ebp

; 439  :       childValues_.push_back( value );

	jmp	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
$LN2@pushValue:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR _value$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 441  :       document_ += value;

	add	ecx, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 442  : }

	pop	ebp
	ret	4
?pushValue@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledWriter::pushValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeIndent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?writeIndent@StyledWriter@Json@@AAEXXZ PROC		; Json::StyledWriter::writeIndent, COMDAT
; _this$ = ecx

; 447  : {

	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1804 : 		return (this->_Mysize() == 0);

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 448  :    if ( !document_.empty() )

	je	SHORT $LN4@writeInden
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+36], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 315  : 		return (_Myval2);

	lea	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN42@writeInden
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN43@writeInden
$LN42@writeInden:
	mov	edx, ecx
$LN43@writeInden:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 450  :       char last = document_[document_.length()-1];

	mov	al, BYTE PTR [edx+eax-1]

; 451  :       if ( last == ' ' )     // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN1@writeInden

; 452  :          return;
; 453  :       if ( last != '\n' )    // Comments may add new-line

	cmp	al, 10					; 0000000aH
	je	SHORT $LN4@writeInden

; 454  :          document_ += '\n';

	push	10					; 0000000aH
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN4@writeInden:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 456  :    document_ += indentString_;

	lea	eax, DWORD PTR [esi+40]
	lea	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN1@writeInden:
	pop	esi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 457  : }

	ret	0
?writeIndent@StyledWriter@Json@@AAEXXZ ENDP		; Json::StyledWriter::writeIndent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledWriter::writeWithIndent, COMDAT
; _this$ = ecx

; 462  : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1804 : 		return (this->_Mysize() == 0);

	mov	eax, DWORD PTR [edi+32]
	test	eax, eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 448  :    if ( !document_.empty() )

	je	SHORT $LN6@writeWithI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+36], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 315  : 		return (_Myval2);

	lea	esi, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN44@writeWithI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN45@writeWithI
$LN44@writeWithI:
	mov	ecx, esi
$LN45@writeWithI:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 450  :       char last = document_[document_.length()-1];

	mov	al, BYTE PTR [ecx+eax-1]

; 451  :       if ( last == ' ' )     // already indented

	cmp	al, 32					; 00000020H
	je	SHORT $LN3@writeWithI

; 452  :          return;
; 453  :       if ( last != '\n' )    // Comments may add new-line

	cmp	al, 10					; 0000000aH
	je	SHORT $LN6@writeWithI

; 454  :          document_ += '\n';

	push	10					; 0000000aH
	mov	ecx, esi
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
$LN6@writeWithI:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 456  :    document_ += indentString_;

	lea	eax, DWORD PTR [edi+40]
	lea	esi, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN3@writeWithI:
	push	-1
	push	0
	push	DWORD PTR _value$[ebp]
	mov	ecx, esi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	pop	edi
	pop	esi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 465  : }

	pop	ebp
	ret	4
?writeWithIndent@StyledWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledWriter::writeWithIndent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?indent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
$T1 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?indent@StyledWriter@Json@@AAEXXZ PROC			; Json::StyledWriter::indent, COMDAT
; _this$ = ecx

; 470  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?indent@StyledWriter@Json@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 852  : 		assign(_Count, _Ch);

	push	ecx
	push	DWORD PTR [esi+68]
	lea	ecx, DWORD PTR $T1[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T1[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T1[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 852  : 		assign(_Count, _Ch);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	lea	eax, DWORD PTR $T1[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 471  :    indentString_ += std::string( indentSize_, ' ' );

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 471  :    indentString_ += std::string( indentSize_, ' ' );

	lea	ecx, DWORD PTR [esi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T1[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN120@indent

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T1[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN120@indent:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 472  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?indent@StyledWriter@Json@@AAEXXZ$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?indent@StyledWriter@Json@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?indent@StyledWriter@Json@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?indent@StyledWriter@Json@@AAEXXZ ENDP			; Json::StyledWriter::indent
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?unindent@StyledWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?unindent@StyledWriter@Json@@AAEXXZ PROC		; Json::StyledWriter::unindent, COMDAT
; _this$ = ecx

; 478  :    assert( int(indentString_.size()) >= indentSize_ );
; 479  :    indentString_.resize( indentString_.size() - indentSize_ );

	mov	eax, DWORD PTR [ecx+56]
	sub	eax, DWORD PTR [ecx+68]
	add	ecx, 40					; 00000028H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	cmp	eax, edx
	ja	SHORT $LN18@unindent

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN41@unindent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN41@unindent:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 480  : }

	ret	0
$LN18@unindent:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	push	0
	sub	eax, edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 480  : }

	ret	0
?unindent@StyledWriter@Json@@AAEXXZ ENDP		; Json::StyledWriter::unindent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 24
$T2 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeCommentBeforeValue, COMDAT
; _this$ = ecx

; 485  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ecx, DWORD PTR _root$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1347 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	$LN1@writeComme
	cmp	DWORD PTR [eax], 0
	je	$LN1@writeComme
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 488  :    document_ += normalizeEOL( root.getComment( commentBefore ) );

	push	0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR [esi+16]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 488  :    document_ += normalizeEOL( root.getComment( commentBefore ) );

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN20@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T2[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN20@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 488  :    document_ += normalizeEOL( root.getComment( commentBefore ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T1[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN121@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T1[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN121@writeComme:

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	lea	ecx, DWORD PTR [esi+16]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T1[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T1[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN1@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 490  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentBeforeValue@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentBeforeValue
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T1 = -140						; size = 24
$T83 = -116						; size = 24
$T84 = -92						; size = 24
$T2 = -68						; size = 24
$T3 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledWriter::writeCommentAfterValueOnSameLine, COMDAT
; _this$ = ecx

; 495  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _root$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1347 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	$LN226@writeComme
	cmp	DWORD PTR [eax+4], 0
	je	$LN226@writeComme
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 497  :       document_ += " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	push	1
	lea	eax, DWORD PTR $T1[ebp]
	mov	ecx, esi
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	push	eax
	mov	edx, OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 497  :       document_ += " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	lea	ecx, DWORD PTR [edi+16]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN24@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T3[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN24@writeComme:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN125@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T2[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN125@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 497  :       document_ += " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T1[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN226@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T1[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN226@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1347 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	$LN3@writeComme
	cmp	DWORD PTR [eax+8], 0
	je	$LN3@writeComme
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 501  :       document_ += "\n";

	add	edi, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, edi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 502  :       document_ += normalizeEOL( root.getComment( commentAfter ) );

	push	2
	lea	eax, DWORD PTR $T83[ebp]
	mov	ecx, esi
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T84[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	push	eax
	call	?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledWriter::normalizeEOL
	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, edi
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 502  :       document_ += normalizeEOL( root.getComment( commentAfter ) );

	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T84[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN343@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T84[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN343@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 502  :       document_ += normalizeEOL( root.getComment( commentAfter ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T83[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T84[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T84[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T84[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN444@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T83[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN444@writeComme:

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	mov	ecx, edi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T83[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T83[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T83[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1107 : 		return (append(_Ptr, _Traits::length(_Ptr)));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN3@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 505  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T83[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T84[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentAfterValueOnSameLine@StyledWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledWriter::writeCommentAfterValueOnSameLine
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledWriter::hasCommentForValue, COMDAT
; _this$ = ecx

; 510  : {

	push	ebp
	mov	ebp, esp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1347 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	mov	eax, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN15@hasComment
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@hasComment
	test	eax, eax
	je	SHORT $LN15@hasComment
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@hasComment
	test	eax, eax
	je	SHORT $LN15@hasComment
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN15@hasComment
$LN3@hasComment:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 511  :    return value.hasComment( commentBefore )

	mov	al, 1

; 512  :           ||  value.hasComment( commentAfterOnSameLine )
; 513  :           ||  value.hasComment( commentAfter );
; 514  : }

	pop	ebp
	ret	4
$LN15@hasComment:

; 511  :    return value.hasComment( commentBefore )

	xor	al, al

; 512  :           ||  value.hasComment( commentAfterOnSameLine )
; 513  :           ||  value.hasComment( commentAfter );
; 514  : }

	pop	ebp
	ret	4
?hasCommentForValue@StyledWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledWriter::hasCommentForValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
_TEXT	SEGMENT
_end$1$ = -24						; size = 4
_c$52 = -20						; size = 1
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
tv667 = 12						; size = 4
tv663 = 12						; size = 4
_text$ = 12						; size = 4
?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z PROC ; Json::StyledWriter::normalizeEOL, COMDAT

; 519  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edi+16], 0

; 497  : 		_Myres(0)

	mov	DWORD PTR [edi+20], 0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN110@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN111@normalizeE
$LN110@normalizeE:
	mov	eax, edi
$LN111@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	esi, DWORD PTR _text$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 537  :    return normalized;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	lea	ecx, DWORD PTR [esi+16]

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx]

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR $T1[ebp], 1

; 729  : 		return (_Get_data()._Mysize);

	mov	DWORD PTR tv663[ebp], ecx

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	cmp	ebx, eax
	ja	SHORT $LN175@normalizeE
	cmp	DWORD PTR [edi+20], eax
	je	SHORT $LN175@normalizeE

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	mov	ecx, edi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN210@normalizeE

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN170@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN171@normalizeE
$LN170@normalizeE:
	mov	eax, edi
$LN171@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
$LN210@normalizeE:
	mov	ecx, DWORD PTR tv663[ebp]
$LN175@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN191@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN191@normalizeE:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 523  :    const char *end = begin + text.length();

	mov	eax, DWORD PTR [ecx]
	add	eax, esi
	mov	DWORD PTR _end$1$[ebp], eax

; 524  :    const char *current = begin;
; 525  :    while ( current != end )

	cmp	esi, eax
	je	SHORT $LN209@normalizeE
	npad	7
$LL2@normalizeE:

; 526  :    {
; 527  :       char c = *current++;

	mov	al, BYTE PTR [esi]
	mov	ebx, esi
	mov	DWORD PTR tv667[ebp], esi

; 528  :       if ( c == '\r' ) // mac or dos EOL
; 529  :       {
; 530  :          if ( *current == '\n' ) // convert dos EOL
; 531  :             ++current;
; 532  :          normalized += '\n';

	mov	ecx, edi
	inc	esi
	mov	BYTE PTR _c$52[ebp], al
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN4@normalizeE
	mov	bl, BYTE PTR [esi]
	push	10					; 0000000aH
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	cmp	bl, 10					; 0000000aH
	cmovne	esi, DWORD PTR tv667[ebp]

; 533  :       }
; 534  :       else // handle unix EOL & other char

	jmp	SHORT $LN5@normalizeE
$LN4@normalizeE:

; 535  :          normalized += c;

	push	DWORD PTR _c$52[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	esi, ebx
$LN5@normalizeE:

; 524  :    const char *current = begin;
; 525  :    while ( current != end )

	inc	esi
	cmp	esi, DWORD PTR _end$1$[ebp]
	jne	SHORT $LL2@normalizeE
$LN209@normalizeE:

; 537  :    return normalized;

	mov	eax, edi

; 538  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN9@normalizeE
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN9@normalizeE:
	ret	0
__ehhandler$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?normalizeEOL@StyledWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ENDP ; Json::StyledWriter::normalizeEOL
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
_root$ = 12						; size = 4
?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z PROC ; Json::StyledStreamWriter::write, COMDAT
; _this$ = ecx

; 554  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H

; 555  :    document_ = &out;

	mov	eax, DWORD PTR _out$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	0
	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 557  :    indentString_ = "";

	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+12], eax
	mov	BYTE PTR [edi+68], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 558  :    writeCommentBeforeValue( root );

	mov	esi, DWORD PTR _root$[ebp]
	mov	ecx, edi
	push	esi
	call	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue

; 559  :    writeValue( root );

	push	esi
	mov	ecx, edi
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue

; 560  :    writeCommentAfterValueOnSameLine( root );

	push	esi
	mov	ecx, edi
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 561  :    *document_ << "\n";

	mov	ecx, DWORD PTR [edi+12]
	mov	edx, OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 562  :    document_ = NULL; // Forget the stream, for safety.

	mov	DWORD PTR [edi+12], 0

; 563  : }

	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
?write@StyledStreamWriter@Json@@QAEXAAV?$basic_ostream@DU?$char_traits@D@std@@@std@@ABVValue@2@@Z ENDP ; Json::StyledStreamWriter::write
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
_value$GSCopy$1$ = -72					; size = 4
_childValue$1$ = -68					; size = 4
$T67 = -64						; size = 24
$T32 = -64						; size = 24
$T21 = -64						; size = 24
$T20 = -64						; size = 24
$T11 = -40						; size = 24
$T9 = -40						; size = 24
$T6 = -40						; size = 24
$T4 = -40						; size = 24
$T2 = -40						; size = 24
$T1 = -40						; size = 24
_members$69 = -28					; size = 12
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeValue, COMDAT
; _this$ = ecx

; 568  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 60					; 0000003cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	edi, DWORD PTR _value$[ebp]
	mov	DWORD PTR _value$GSCopy$1$[ebp], edi

; 569  :    switch ( value.type() )

	movsx	eax, BYTE PTR [edi+8]
	cmp	eax, 7
	ja	$LN2@writeValue
	jmp	DWORD PTR $LN286@writeValue[eax*4]
$LN6@writeValue:

; 570  :    {
; 571  :    case nullValue:
; 572  :       pushValue( "null" );

	push	OFFSET ??_C@_04MLLLIHIP@null?$AA@
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 714  :    if ( addChildValues_ )

	cmp	BYTE PTR [ebx+68], 0
	je	SHORT $LN32@writeValue

; 715  :       childValues_.push_back( value );

	lea	eax, DWORD PTR $T1[ebp]
$LN284@writeValue:
	push	eax
	mov	ecx, ebx
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 570  :    {
; 571  :    case nullValue:
; 572  :       pushValue( "null" );

	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 573  :       break;

	jmp	$LN2@writeValue
$LN32@writeValue:

; 717  :       *document_ << value;

	lea	edx, DWORD PTR $T1[ebp]
$LN283@writeValue:
	mov	ecx, DWORD PTR [ebx+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 570  :    {
; 571  :    case nullValue:
; 572  :       pushValue( "null" );

	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 573  :       break;

	jmp	$LN2@writeValue
$LN7@writeValue:

; 574  :    case intValue:
; 575  :       pushValue( valueToString( value.asInt() ) );

	mov	ecx, edi
	call	?asInt@Value@Json@@QBEHXZ		; Json::Value::asInt
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 714  :    if ( addChildValues_ )

	cmp	BYTE PTR [ebx+68], 0
	jne	SHORT $LN284@writeValue
$LN36@writeValue:

; 717  :       *document_ << value;

	mov	edx, eax

; 576  :       break;

	jmp	SHORT $LN283@writeValue
$LN8@writeValue:

; 577  :    case uintValue:
; 578  :       pushValue( valueToString( value.asUInt() ) );

	mov	ecx, edi
	call	?asUInt@Value@Json@@QBEIXZ		; Json::Value::asUInt
	push	eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@I@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 2
$LN285@writeValue:

; 714  :    if ( addChildValues_ )

	cmp	BYTE PTR [ebx+68], 0
	je	SHORT $LN36@writeValue

; 715  :       childValues_.push_back( value );

	push	eax
	mov	ecx, ebx
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 570  :    {
; 571  :    case nullValue:
; 572  :       pushValue( "null" );

	lea	ecx, DWORD PTR $T1[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 573  :       break;

	jmp	$LN2@writeValue
$LN9@writeValue:

; 579  :       break;
; 580  :    case realValue:
; 581  :       pushValue( valueToString( value.asDouble() ) );

	mov	ecx, edi
	call	?asDouble@Value@Json@@QBENXZ		; Json::Value::asDouble
	sub	esp, 8
	lea	eax, DWORD PTR $T6[ebp]
	fstp	QWORD PTR [esp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@N@Z ; Json::valueToString
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __$EHRec$[ebp+8], 3

; 716  :    else

	jmp	SHORT $LN285@writeValue
$LN10@writeValue:

; 582  :       break;
; 583  :    case stringValue:
; 584  :       pushValue( valueToQuotedString( value.asCString() ) );

	push	DWORD PTR [edi]
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 716  :    else

	jmp	SHORT $LN285@writeValue
$LN11@writeValue:

; 585  :       break;
; 586  :    case booleanValue:
; 587  :       pushValue( valueToString( value.asBool() ) );

	mov	ecx, edi
	call	?asBool@Value@Json@@QBE_NXZ		; Json::Value::asBool
	movzx	eax, al
	push	eax
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	call	?valueToString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@_N@Z ; Json::valueToString
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 716  :    else

	jmp	SHORT $LN285@writeValue
$LN12@writeValue:

; 588  :       break;
; 589  :    case arrayValue:
; 590  :       writeArrayValue( value);

	push	edi
	call	?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeArrayValue

; 591  :       break;

	jmp	$LN2@writeValue
$LN13@writeValue:

; 592  :    case objectValue:
; 593  :       {
; 594  :          Value::Members members( value.getMemberNames() );

	lea	eax, DWORD PTR _members$69[ebp]
	mov	ecx, edi
	push	eax
	call	?getMemberNames@Value@Json@@QBE?AV?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@XZ ; Json::Value::getMemberNames
	mov	DWORD PTR __$EHRec$[ebp+8], 6

; 596  :             pushValue( "{}" );

	lea	ecx, DWORD PTR $T20[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	esi, DWORD PTR _members$69[ebp]
	cmp	esi, DWORD PTR _members$69[ebp+4]
	sete	al
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 595  :          if ( members.empty() )

	test	al, al
	je	SHORT $LN14@writeValue

; 596  :             pushValue( "{}" );

	push	OFFSET ??_C@_02MCILKGOH@?$HL?$HN?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	BYTE PTR __$EHRec$[ebp+8], 7

; 714  :    if ( addChildValues_ )

	cmp	BYTE PTR [ebx+68], 0
	je	$LN79@writeValue

; 715  :       childValues_.push_back( value );

	lea	eax, DWORD PTR $T20[ebp]
	mov	ecx, ebx
	push	eax
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 716  :    else

	jmp	$LN80@writeValue
$LN14@writeValue:

; 597  :          else
; 598  :          {
; 599  :             writeWithIndent( "{" );

	push	OFFSET ??_C@_01HCONENDN@?$HL?$AA@
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 743  :    writeIndent();

	mov	ecx, ebx

; 597  :          else
; 598  :          {
; 599  :             writeWithIndent( "{" );

	mov	BYTE PTR __$EHRec$[ebp+8], 8

; 743  :    writeIndent();

	call	?writeIndent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::writeIndent

; 744  :    *document_ << value;

	mov	ecx, DWORD PTR [ebx+12]
	lea	edx, DWORD PTR $T21[ebp]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 597  :          else
; 598  :          {
; 599  :             writeWithIndent( "{" );

	lea	ecx, DWORD PTR $T21[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 751  :    indentString_ += indentation_;

	lea	eax, DWORD PTR [ebx+44]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 751  :    indentString_ += indentation_;

	lea	ecx, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LL4@writeValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 605  :                const Value &childValue = value[name];

	push	esi
	mov	ecx, edi
	call	??AValue@Json@@QBEABV01@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Json::Value::operator[]

; 606  :                writeCommentBeforeValue( childValue );

	push	eax
	mov	ecx, ebx
	mov	DWORD PTR _childValue$1$[ebp], eax
	call	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN133@writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN134@writeValue
$LN133@writeValue:
	mov	eax, esi
$LN134@writeValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 607  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	push	eax
	lea	eax, DWORD PTR $T32[ebp]
	push	eax
	call	?valueToQuotedString@Json@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PBD@Z ; Json::valueToQuotedString
	add	esp, 8
	mov	edi, eax

; 743  :    writeIndent();

	mov	ecx, ebx

; 607  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	mov	BYTE PTR __$EHRec$[ebp+8], 9

; 743  :    writeIndent();

	call	?writeIndent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::writeIndent

; 744  :    *document_ << value;

	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, edi
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 607  :                writeWithIndent( valueToQuotedString( name.c_str() ) );

	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T32[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN147@writeValue

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T32[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN147@writeValue:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 608  :                *document_ << " : ";

	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, OFFSET ??_C@_03MCPBMLDJ@?5?3?5?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 609  :                writeValue( childValue );

	mov	edi, DWORD PTR _childValue$1$[ebp]
	mov	ecx, ebx
	push	edi
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 113  : 		++_Ptr;

	add	esi, 24					; 00000018H

; 214  : 		return (_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR _members$69[ebp+4]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 610  :                if ( ++it == members.end() )

	je	SHORT $LN279@writeValue

; 613  :                   break;
; 614  :                }
; 615  :                *document_ << ",";

	mov	ecx, DWORD PTR [ebx+12]
	mov	edx, OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 616  :                writeCommentAfterValueOnSameLine( childValue );

	push	edi
	mov	ecx, ebx
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 617  :             }

	mov	edi, DWORD PTR _value$GSCopy$1$[ebp]
	jmp	$LL4@writeValue
$LN279@writeValue:

; 611  :                {
; 612  :                   writeCommentAfterValueOnSameLine( childValue );

	push	edi
	mov	ecx, ebx
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 618  :             unindent();

	mov	ecx, ebx
	call	?unindent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::unindent

; 619  :             writeWithIndent( "}" );

	push	OFFSET ??_C@_01CELHOKLL@?$HN?$AA@
	lea	ecx, DWORD PTR $T67[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >

; 743  :    writeIndent();

	mov	ecx, ebx

; 619  :             writeWithIndent( "}" );

	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH

; 743  :    writeIndent();

	call	?writeIndent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::writeIndent
$LN79@writeValue:

; 744  :    *document_ << value;

	mov	ecx, DWORD PTR [ebx+12]
	lea	edx, DWORD PTR $T67[ebp]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN80@writeValue:

; 619  :             writeWithIndent( "}" );

	lea	ecx, DWORD PTR $T67[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 620  :          }
; 621  :       }

	lea	ecx, DWORD PTR _members$69[ebp]
	call	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
$LN2@writeValue:

; 622  :       break;
; 623  :    }
; 624  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
$LN286@writeValue:
	DD	$LN6@writeValue
	DD	$LN7@writeValue
	DD	$LN8@writeValue
	DD	$LN9@writeValue
	DD	$LN10@writeValue
	DD	$LN11@writeValue
	DD	$LN12@writeValue
	DD	$LN13@writeValue
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$5:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$6:
	lea	ecx, DWORD PTR _members$69[ebp]
	jmp	??1?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE@XZ ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::~vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$7:
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$8:
	lea	ecx, DWORD PTR $T21[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$9:
	lea	ecx, DWORD PTR $T32[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$10:
	lea	ecx, DWORD PTR $T67[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-76]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeValue
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T114 = -100						; size = 4
_key$203 = -96						; size = 8
tv1915 = -88						; size = 4
tv1919 = -84						; size = 4
_value$GSCopy$1$ = -80					; size = 4
_size$1$ = -76						; size = 4
tv1904 = -72						; size = 4
_index$1$ = -68						; size = 4
$T146 = -64						; size = 24
$T54 = -40						; size = 24
$T1 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_value$ = 8						; size = 4
?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeArrayValue, COMDAT
; _this$ = ecx

; 629  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 88					; 00000058H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	edi, DWORD PTR _value$[ebp]

; 630  :    unsigned size = value.size();

	mov	ecx, edi
	mov	DWORD PTR _value$GSCopy$1$[ebp], edi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	mov	ebx, eax
	mov	DWORD PTR _size$1$[ebp], ebx

; 631  :    if ( size == 0 )

	test	ebx, ebx
	jne	SHORT $LN7@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	2
	push	OFFSET ??_C@_02GPECMEKF@?$FL?$FN?$AA@
	lea	ecx, DWORD PTR $T1[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T1[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T1[ebp+16], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T1[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 632  :       pushValue( "[]" );

	mov	DWORD PTR __$EHRec$[ebp+8], ebx

; 714  :    if ( addChildValues_ )

	cmp	BYTE PTR [esi+68], bl
	je	SHORT $LN132@writeArray

; 715  :       childValues_.push_back( value );

	lea	eax, DWORD PTR $T1[ebp]
	mov	ecx, esi
	push	eax
	call	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back

; 716  :    else

	jmp	SHORT $LN133@writeArray
$LN132@writeArray:

; 717  :       *document_ << value;

	mov	ecx, DWORD PTR [esi+12]
	lea	edx, DWORD PTR $T1[ebp]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
$LN133@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T1[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	$LN10@writeArray

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T1[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 633  :    else

	jmp	$LN10@writeArray
$LN7@writeArray:

; 634  :    {
; 635  :       bool isArrayMultiLine = isMultineArray( value );

	push	edi
	mov	ecx, esi
	call	?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ; Json::StyledStreamWriter::isMultineArray

; 636  :       if ( isArrayMultiLine )

	test	al, al
	je	$LN9@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01OHGJGJJP@?$FL?$AA@
	lea	ecx, DWORD PTR $T54[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T54[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T54[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T54[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 743  :    writeIndent();

	mov	ecx, esi

; 637  :       {
; 638  :          writeWithIndent( "[" );

	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 743  :    writeIndent();

	call	?writeIndent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::writeIndent

; 744  :    *document_ << value;

	mov	ecx, DWORD PTR [esi+12]
	lea	edx, DWORD PTR $T54[ebp]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 637  :       {
; 638  :          writeWithIndent( "[" );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T54[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN358@writeArray

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T54[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN358@writeArray:

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
	push	0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 751  :    indentString_ += indentation_;

	lea	eax, DWORD PTR [esi+44]
	lea	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	eax, DWORD PTR [esi]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 641  :          unsigned index =0;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1190 : 		return (this->_Myfirst() == this->_Mylast());

	mov	DWORD PTR tv1915[ebp], eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR tv1919[ebp], eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 641  :          unsigned index =0;

	mov	DWORD PTR _index$1$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	mov	DWORD PTR tv1904[ebp], edi
$LL2@writeArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 999  :    if ( type_ == nullValue )

	mov	eax, DWORD PTR _value$GSCopy$1$[ebp]
	cmp	BYTE PTR [eax+8], 0
	jne	SHORT $LN481@writeArray

; 1000 :       return null;

	mov	ebx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN480@writeArray
$LN481@writeArray:

; 176  :    , index_( index )

	mov	DWORD PTR _key$203[ebp+4], edi

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	mov	edi, DWORD PTR [eax]
	lea	eax, DWORD PTR _key$203[ebp]
	push	eax
	lea	eax, DWORD PTR $T114[ebp]

; 175  :    : cstr_( 0 )

	mov	DWORD PTR _key$203[ebp], 0

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	push	eax
	mov	ecx, edi
	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [edi]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1004 :    if ( it == value_.map_->end() )

	jne	SHORT $LN482@writeArray

; 1005 :       return null;

	mov	ebx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN853@writeArray
$LN482@writeArray:

; 1006 :    return (*it).second;

	lea	ebx, DWORD PTR [eax+24]
$LN853@writeArray:
	mov	edi, DWORD PTR _index$1$[ebp]

; 200  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN480@writeArray:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 645  :             writeCommentBeforeValue( childValue );

	push	ebx
	mov	ecx, esi
	call	?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentBeforeValue
	mov	eax, DWORD PTR tv1919[ebp]

; 743  :    writeIndent();

	mov	ecx, esi
	cmp	DWORD PTR tv1915[ebp], eax

; 646  :             if ( hasChildValue )

	je	SHORT $LN11@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	edi, DWORD PTR [esi]
	add	edi, DWORD PTR tv1904[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 743  :    writeIndent();

	call	?writeIndent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::writeIndent

; 744  :    *document_ << value;

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, edi
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 647  :                writeWithIndent( childValues_[index] );
; 648  :             else

	mov	edi, DWORD PTR _index$1$[ebp]
	jmp	SHORT $LN12@writeArray
$LN11@writeArray:

; 649  :             {
; 650  : 	       writeIndent();

	call	?writeIndent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::writeIndent

; 651  :                writeValue( childValue );

	push	ebx
	mov	ecx, esi
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue
$LN12@writeArray:

; 652  :             }
; 653  :             if ( ++index == size )

	add	DWORD PTR tv1904[ebp], 24		; 00000018H
	inc	edi
	mov	DWORD PTR _index$1$[ebp], edi
	cmp	edi, DWORD PTR _size$1$[ebp]
	je	SHORT $LN846@writeArray

; 656  :                break;
; 657  :             }
; 658  :             *document_ << ",";

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, OFFSET ??_C@_01IHBHIGKO@?0?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 659  :             writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	mov	ecx, esi
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine

; 660  :          }

	jmp	$LL2@writeArray
$LN846@writeArray:

; 654  :             {
; 655  :                writeCommentAfterValueOnSameLine( childValue );

	push	ebx
	mov	ecx, esi
	call	?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1765 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [esi+32]

; 1781 : 		if (_Newsize <= this->_Mysize())

	lea	ecx, DWORD PTR [esi+16]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 759  :    indentString_.resize( indentString_.size() - indentation_.size() );

	sub	eax, DWORD PTR [esi+60]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	cmp	eax, edx
	ja	SHORT $LN578@writeArray

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN601@writeArray
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN601@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1783 : 		else

	jmp	SHORT $LN579@writeArray
$LN578@writeArray:

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	push	0
	sub	eax, edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN579@writeArray:

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	1
	push	OFFSET ??_C@_01LBDDMOBJ@?$FN?$AA@
	lea	ecx, DWORD PTR $T146[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T146[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T146[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T146[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 743  :    writeIndent();

	mov	ecx, esi

; 661  :          unindent();
; 662  :          writeWithIndent( "]" );

	mov	DWORD PTR __$EHRec$[ebp+8], 4

; 743  :    writeIndent();

	call	?writeIndent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::writeIndent

; 744  :    *document_ << value;

	mov	ecx, DWORD PTR [esi+12]
	lea	edx, DWORD PTR $T146[ebp]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T146[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN10@writeArray

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T146[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 664  :       else // output on a single line

	jmp	SHORT $LN10@writeArray
$LN9@writeArray:

; 665  :       {
; 666  :          assert( childValues_.size() == size );
; 667  :          *document_ << "[ ";

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, OFFSET ??_C@_02PFNDMDBO@?$FL?5?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 668  :          for ( unsigned index =0; index < size; ++index )

	xor	edi, edi
	test	ebx, ebx
	je	SHORT $LN5@writeArray

; 665  :       {
; 666  :          assert( childValues_.size() == size );
; 667  :          *document_ << "[ ";

	xor	ebx, ebx
	npad	6
$LL6@writeArray:

; 669  :          {
; 670  :             if ( index > 0 )

	test	edi, edi
	je	SHORT $LN14@writeArray

; 671  :                *document_ << ", ";

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, OFFSET ??_C@_02KEGNLNML@?0?5?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
$LN14@writeArray:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	edx, DWORD PTR [esi]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 672  :             *document_ << childValues_[index];

	mov	ecx, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	add	edx, ebx
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 672  :             *document_ << childValues_[index];

	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	inc	edi
	add	ebx, 24					; 00000018H
	cmp	edi, DWORD PTR _size$1$[ebp]
	jb	SHORT $LL6@writeArray
$LN5@writeArray:

; 673  :          }
; 674  :          *document_ << " ]";

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, OFFSET ??_C@_02DHOGEDBE@?5?$FN?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
$LN10@writeArray:

; 675  :       }
; 676  :    }
; 677  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T54[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$124:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$125:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T146[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-104]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeArrayValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeArrayValue
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
_key$75 = -40						; size = 8
_key$76 = -32						; size = 8
$T42 = -28						; size = 4
tv1061 = -24						; size = 4
$T16 = -24						; size = 4
_lineLength$1$ = -20					; size = 4
_size$1$ = -20						; size = 4
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T9 = 8							; size = 1
_value$ = 8						; size = 4
?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledStreamWriter::isMultineArray, COMDAT
; _this$ = ecx

; 682  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 683  :    int size = value.size();

	mov	esi, DWORD PTR _value$[ebp]
	mov	ecx, esi
	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	DWORD PTR $T9[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 683  :    int size = value.size();

	mov	DWORD PTR _size$1$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	push	ecx
	mov	ecx, DWORD PTR [edi]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 684  :    bool isMultiLine = size*3 >= rightMargin_ ;

	lea	edx, DWORD PTR [eax+eax*2]
	cmp	edx, DWORD PTR [edi+40]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	mov	edx, DWORD PTR [edi+4]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 684  :    bool isMultiLine = size*3 >= rightMargin_ ;

	setge	bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	call	??$_Destroy_range1@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@std@@YAXPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0AAU?$_Wrap_alloc@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@0@U?$integral_constant@_N$0A@@0@@Z ; std::_Destroy_range1<std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::basic_string<char,std::char_traits<char>,std::allocator<char> > *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	DWORD PTR [edi+4], eax
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 686  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	xor	edi, edi
	cmp	DWORD PTR _size$1$[ebp], edi
	jle	SHORT $LN3@isMultineA
$LL4@isMultineA:
	test	bl, bl
	jne	$LN16@isMultineA
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 999  :    if ( type_ == nullValue )

	cmp	BYTE PTR [esi+8], bl
	jne	SHORT $LN68@isMultineA

; 1000 :       return null;

	mov	ecx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN325@isMultineA
$LN68@isMultineA:

; 1001 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1002 :    CZString key( index );
; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	mov	esi, DWORD PTR [esi]
	lea	eax, DWORD PTR _key$76[ebp]
	push	eax
	lea	eax, DWORD PTR $T16[ebp]

; 175  :    : cstr_( 0 )

	mov	DWORD PTR _key$76[ebp], 0

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	push	eax
	mov	ecx, esi

; 176  :    , index_( index )

	mov	DWORD PTR _key$76[ebp+4], edi

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1004 :    if ( it == value_.map_->end() )

	jne	SHORT $LN69@isMultineA

; 1005 :       return null;

	mov	ecx, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN329@isMultineA
$LN69@isMultineA:

; 1006 :    return (*it).second;

	lea	ecx, DWORD PTR [eax+24]
$LN329@isMultineA:

; 200  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, DWORD PTR _value$[ebp]
$LN325@isMultineA:

; 1315 :    return type_ == nullValue  ||  type_ == arrayValue;

	mov	al, BYTE PTR [ecx+8]
	test	al, al
	je	SHORT $LN125@isMultineA
	cmp	al, 6
	je	SHORT $LN125@isMultineA

; 1322 :    return type_ == nullValue  ||  type_ == objectValue;

	cmp	al, 7
	jne	SHORT $LN11@isMultineA
$LN125@isMultineA:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 689  :       isMultiLine = isMultiLine  ||

	call	?size@Value@Json@@QBEIXZ		; Json::Value::size
	test	eax, eax
	jne	SHORT $LN12@isMultineA
$LN11@isMultineA:
	xor	bl, bl
	jmp	SHORT $LN13@isMultineA
$LN12@isMultineA:
	mov	bl, 1
$LN13@isMultineA:

; 686  :    for ( int index =0; index < size  &&  !isMultiLine; ++index )

	inc	edi
	cmp	edi, DWORD PTR _size$1$[ebp]
	jl	SHORT $LL4@isMultineA
$LN3@isMultineA:

; 690  :                      ( (childValue.isArray()  ||  childValue.isObject())  &&  
; 691  :                         childValue.size() > 0 );
; 692  :    }
; 693  :    if ( !isMultiLine ) // check if line length > max line length

	test	bl, bl
	jne	$LN16@isMultineA
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	edi, DWORD PTR _this$1$[ebp]
	mov	eax, 715827883				; 2aaaaaabH

; 1033 : 		if (capacity() < _Count)

	mov	ebx, DWORD PTR _size$1$[ebp]

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi+8]
	sub	ecx, DWORD PTR [edi]
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 1033 : 		if (capacity() < _Count)

	cmp	eax, ebx
	jae	SHORT $LN128@isMultineA

; 1034 : 			{	// something to do, check and reallocate
; 1035 : 			if (max_size() < _Count)

	cmp	ebx, 178956970				; 0aaaaaaaH
	jbe	SHORT $LN129@isMultineA

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN331@isMultineA:
$LN129@isMultineA:

; 1037 : 			_Reallocate(_Count);

	push	ebx
	mov	ecx, edi
	call	?_Reallocate@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reallocate
$LN128@isMultineA:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 696  :       addChildValues_ = true;

	mov	BYTE PTR [edi+68], 1

; 697  :       int lineLength = 4 + (size-1)*2; // '[ ' + ', '*n + ' ]'

	lea	edx, DWORD PTR [ebx*2+2]

; 698  :       for ( int index =0; index < size  &&  !isMultiLine; ++index )

	xor	edi, edi
	mov	DWORD PTR _lineLength$1$[ebp], edx
	test	ebx, ebx
	jle	SHORT $LN6@isMultineA

; 696  :       addChildValues_ = true;

	mov	DWORD PTR tv1061[ebp], edi
$LL7@isMultineA:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 999  :    if ( type_ == nullValue )

	cmp	BYTE PTR [esi+8], 0
	jne	SHORT $LN175@isMultineA

; 1000 :       return null;

	mov	eax, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN174@isMultineA
$LN175@isMultineA:

; 1001 : #ifndef JSON_VALUE_USE_INTERNAL_MAP
; 1002 :    CZString key( index );
; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	mov	esi, DWORD PTR [esi]
	lea	eax, DWORD PTR _key$75[ebp]
	push	eax
	lea	eax, DWORD PTR $T42[ebp]

; 175  :    : cstr_( 0 )

	mov	DWORD PTR _key$75[ebp], 0

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	push	eax
	mov	ecx, esi

; 176  :    , index_( index )

	mov	DWORD PTR _key$75[ebp+4], edi

; 1003 :    ObjectValues::const_iterator it = value_.map_->find( key );

	call	?find@?$_Tree@V?$_Tmap_traits@VCZString@Value@Json@@V23@U?$less@VCZString@Value@Json@@@std@@V?$allocator@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@5@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBVCZString@Value@Json@@V23@@std@@@std@@@std@@@2@ABVCZString@Value@Json@@@Z ; std::_Tree<std::_Tmap_traits<Json::Value::CZString,Json::Value,std::less<Json::Value::CZString>,std::allocator<std::pair<Json::Value::CZString const ,Json::Value> >,0> >::find
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1004 :    if ( it == value_.map_->end() )

	jne	SHORT $LN176@isMultineA

; 1005 :       return null;

	mov	eax, OFFSET ?null@Value@Json@@2V12@B	; Json::Value::null
	jmp	SHORT $LN330@isMultineA
$LN176@isMultineA:

; 1006 :    return (*it).second;

	add	eax, 24					; 00000018H
$LN330@isMultineA:

; 200  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, DWORD PTR _value$[ebp]
$LN174@isMultineA:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 700  :          writeValue( value[index] );

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	eax
	call	?writeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ; Json::StyledStreamWriter::writeValue
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR _this$1$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 698  :       for ( int index =0; index < size  &&  !isMultiLine; ++index )

	inc	edi

; 701  :          lineLength += int( childValues_[index].length() );

	mov	edx, DWORD PTR _lineLength$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR tv1061[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 701  :          lineLength += int( childValues_[index].length() );

	add	edx, DWORD PTR [eax+ecx+16]
	add	ecx, 24					; 00000018H
	mov	DWORD PTR _lineLength$1$[ebp], edx
	mov	DWORD PTR tv1061[ebp], ecx
	cmp	edi, ebx
	jl	SHORT $LL7@isMultineA
$LN6@isMultineA:

; 702  :          isMultiLine = isMultiLine  &&  hasCommentForValue( value[index] );
; 703  :       }
; 704  :       addChildValues_ = false;

	mov	eax, DWORD PTR _this$1$[ebp]

; 705  :       isMultiLine = isMultiLine  ||  lineLength >= rightMargin_;

	cmp	edx, DWORD PTR [eax+40]
	mov	BYTE PTR [eax+68], 0
	setge	bl
$LN16@isMultineA:

; 706  :    }
; 707  :    return isMultiLine;

	mov	al, bl

; 708  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN328@isMultineA:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z$23:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z$24:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z$46:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z$47:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?isMultineArray@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledStreamWriter::isMultineArray
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledStreamWriter::pushValue, COMDAT
; _this$ = ecx

; 713  : {

	push	ebp
	mov	ebp, esp

; 714  :    if ( addChildValues_ )

	cmp	BYTE PTR [ecx+68], 0
	je	SHORT $LN2@pushValue

; 718  : }

	pop	ebp

; 715  :       childValues_.push_back( value );

	jmp	?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
$LN2@pushValue:

; 716  :    else
; 717  :       *document_ << value;

	mov	edx, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [ecx+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 718  : }

	pop	ebp
	ret	4
?pushValue@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledStreamWriter::pushValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeIndent@StyledStreamWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?writeIndent@StyledStreamWriter@Json@@AAEXXZ PROC	; Json::StyledStreamWriter::writeIndent, COMDAT
; _this$ = ecx

; 723  : {

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	push	ecx
	push	esi

; 724  :   /*
; 725  :     Some comments in this method would have been nice. ;-)
; 726  : 
; 727  :    if ( !document_.empty() )
; 728  :    {
; 729  :       char last = document_[document_.length()-1];
; 730  :       if ( last == ' ' )     // already indented
; 731  :          return;
; 732  :       if ( last != '\n' )    // Comments may add new-line
; 733  :          *document_ << '\n';
; 734  :    }
; 735  :   */
; 736  :    *document_ << '\n' << indentString_;

	lea	esi, DWORD PTR [ecx+16]
	mov	ecx, DWORD PTR [ecx+12]
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ; std::operator<<<std::char_traits<char> >
	mov	edx, esi
	mov	ecx, eax
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >

; 737  : }

	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
?writeIndent@StyledStreamWriter@Json@@AAEXXZ ENDP	; Json::StyledStreamWriter::writeIndent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Json::StyledStreamWriter::writeWithIndent, COMDAT
; _this$ = ecx

; 742  : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 743  :    writeIndent();

	call	?writeIndent@StyledStreamWriter@Json@@AAEXXZ ; Json::StyledStreamWriter::writeIndent

; 744  :    *document_ << value;

	mov	edx, DWORD PTR _value$[ebp]
	mov	ecx, DWORD PTR [esi+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
	pop	esi

; 745  : }

	pop	ebp
	ret	4
?writeWithIndent@StyledStreamWriter@Json@@AAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Json::StyledStreamWriter::writeWithIndent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?indent@StyledStreamWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?indent@StyledStreamWriter@Json@@AAEXXZ PROC		; Json::StyledStreamWriter::indent, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	-1
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 751  :    indentString_ += indentation_;

	lea	eax, DWORD PTR [ecx+44]
	add	ecx, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1065 : 		return (append(_Right, 0, npos));

	push	0
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 752  : }

	ret	0
?indent@StyledStreamWriter@Json@@AAEXXZ ENDP		; Json::StyledStreamWriter::indent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?unindent@StyledStreamWriter@Json@@AAEXXZ
_TEXT	SEGMENT
?unindent@StyledStreamWriter@Json@@AAEXXZ PROC		; Json::StyledStreamWriter::unindent, COMDAT
; _this$ = ecx

; 758  :    assert( indentString_.size() >= indentation_.size() );
; 759  :    indentString_.resize( indentString_.size() - indentation_.size() );

	mov	eax, DWORD PTR [ecx+32]
	sub	eax, DWORD PTR [ecx+60]
	add	ecx, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1781 : 		if (_Newsize <= this->_Mysize())

	mov	edx, DWORD PTR [ecx+16]
	cmp	eax, edx
	ja	SHORT $LN30@unindent

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN53@unindent
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN53@unindent:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+eax], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 760  : }

	ret	0
$LN30@unindent:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1784 : 			append(_Newsize - this->_Mysize(), _Ch);

	push	0
	sub	eax, edx
	push	eax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 760  : }

	ret	0
?unindent@StyledStreamWriter@Json@@AAEXXZ ENDP		; Json::StyledStreamWriter::unindent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T1 = -68						; size = 24
$T2 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeCommentBeforeValue, COMDAT
; _this$ = ecx

; 765  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ecx, DWORD PTR _root$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1347 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	mov	eax, DWORD PTR [ecx+12]
	test	eax, eax
	je	$LN1@writeComme
	cmp	DWORD PTR [eax], 0
	je	$LN1@writeComme
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 768  :    *document_ << normalizeEOL( root.getComment( commentBefore ) );

	push	0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	edx, eax
	mov	ecx, DWORD PTR [esi+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN16@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T2[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN16@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 768  :    *document_ << normalizeEOL( root.getComment( commentBefore ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T1[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN117@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T1[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN117@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 769  :    *document_ << "\n";

	mov	ecx, DWORD PTR [esi+12]
	mov	edx, OFFSET ??_C@_01EEMJAFIK@?6?$AA@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T1[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T1[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T1[ebp], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 769  :    *document_ << "\n";

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
$LN1@writeComme:

; 770  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-64]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentBeforeValue@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeCommentBeforeValue
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
_TEXT	SEGMENT
$T1 = -140						; size = 24
$T82 = -116						; size = 24
$T83 = -92						; size = 24
$T2 = -68						; size = 24
$T3 = -44						; size = 24
__$ArrayPad$ = -20					; size = 4
__$EHRec$ = -12						; size = 12
_root$ = 8						; size = 4
?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z PROC ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine, COMDAT
; _this$ = ecx

; 775  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 132				; 00000084H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	esi, DWORD PTR _root$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1347 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	$LN222@writeComme
	cmp	DWORD PTR [eax+4], 0
	je	$LN222@writeComme
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 777  :       *document_ << " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	push	1
	lea	eax, DWORD PTR $T1[ebp]
	mov	ecx, esi
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
	push	eax
	mov	edx, OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR $T3[ebp]
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	add	esp, 12					; 0000000cH
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, eax
	mov	ecx, DWORD PTR [edi+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN20@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T3[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN20@writeComme:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T3[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T3[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T3[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN121@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T2[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN121@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 777  :       *document_ << " " + normalizeEOL( root.getComment( commentAfterOnSameLine ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T1[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T2[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T2[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T2[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN222@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T1[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN222@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1347 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	$LN3@writeComme
	cmp	DWORD PTR [eax+8], 0
	je	$LN3@writeComme
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 781  :       *document_ << "\n";

	mov	ecx, DWORD PTR [edi+12]
	mov	edx, OFFSET ??_C@_01EEMJAFIK@?6?$AA@
	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >

; 782  :       *document_ << normalizeEOL( root.getComment( commentAfter ) );

	push	2
	lea	eax, DWORD PTR $T82[ebp]
	mov	ecx, esi
	push	eax
	call	?getComment@Value@Json@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@W4CommentPlacement@2@@Z ; Json::Value::getComment
	push	eax
	lea	eax, DWORD PTR $T83[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	push	eax
	call	?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ; Json::StyledStreamWriter::normalizeEOL
	add	esp, 8
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	mov	edx, eax
	mov	ecx, DWORD PTR [edi+12]
	call	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T83[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN327@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T83[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN327@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 782  :       *document_ << normalizeEOL( root.getComment( commentAfter ) );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T82[ebp+20]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T83[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T83[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T83[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN428@writeComme

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
	push	DWORD PTR $T82[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN428@writeComme:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 783  :       *document_ << "\n";

	mov	ecx, DWORD PTR [edi+12]
	mov	edx, OFFSET ??_C@_01EEMJAFIK@?6?$AA@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T82[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T82[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T82[ebp], 0
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 783  :       *document_ << "\n";

	call	??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ; std::operator<<<std::char_traits<char> >
$LN3@writeComme:

; 784  :    }
; 785  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$0:
	lea	ecx, DWORD PTR $T1[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$1:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$2:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$3:
	lea	ecx, DWORD PTR $T82[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z$4:
	lea	ecx, DWORD PTR $T83[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-144]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?writeCommentAfterValueOnSameLine@StyledStreamWriter@Json@@AAEXABVValue@2@@Z ENDP ; Json::StyledStreamWriter::writeCommentAfterValueOnSameLine
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z
_TEXT	SEGMENT
_value$ = 8						; size = 4
?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z PROC ; Json::StyledStreamWriter::hasCommentForValue, COMDAT
; _this$ = ecx

; 790  : {

	push	ebp
	mov	ebp, esp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_value.cpp

; 1347 :    return comments_ != 0  &&  comments_[placement].comment_ != 0;

	mov	eax, DWORD PTR _value$[ebp]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	je	SHORT $LN15@hasComment
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@hasComment
	test	eax, eax
	je	SHORT $LN15@hasComment
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@hasComment
	test	eax, eax
	je	SHORT $LN15@hasComment
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN15@hasComment
$LN3@hasComment:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 791  :    return value.hasComment( commentBefore )

	mov	al, 1

; 792  :           ||  value.hasComment( commentAfterOnSameLine )
; 793  :           ||  value.hasComment( commentAfter );
; 794  : }

	pop	ebp
	ret	4
$LN15@hasComment:

; 791  :    return value.hasComment( commentBefore )

	xor	al, al

; 792  :           ||  value.hasComment( commentAfterOnSameLine )
; 793  :           ||  value.hasComment( commentAfter );
; 794  : }

	pop	ebp
	ret	4
?hasCommentForValue@StyledStreamWriter@Json@@AAE_NABVValue@2@@Z ENDP ; Json::StyledStreamWriter::hasCommentForValue
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp
;	COMDAT ?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
_TEXT	SEGMENT
_end$1$ = -24						; size = 4
_c$52 = -20						; size = 1
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
tv667 = 12						; size = 4
tv663 = 12						; size = 4
_text$ = 12						; size = 4
?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z PROC ; Json::StyledStreamWriter::normalizeEOL, COMDAT

; 799  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	edi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [edi+16], 0

; 497  : 		_Myres(0)

	mov	DWORD PTR [edi+20], 0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN110@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN111@normalizeE
$LN110@normalizeE:
	mov	eax, edi
$LN111@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	esi, DWORD PTR _text$[ebp]
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 817  :    return normalized;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	lea	ecx, DWORD PTR [esi+16]

; 1760 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx]

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	mov	ebx, DWORD PTR [edi+16]
	mov	DWORD PTR $T1[ebp], 1

; 729  : 		return (_Get_data()._Mysize);

	mov	DWORD PTR tv663[ebp], ecx

; 1794 : 		if (this->_Mysize() <= _Newcap && this->_Myres() != _Newcap)

	cmp	ebx, eax
	ja	SHORT $LN175@normalizeE
	cmp	DWORD PTR [edi+20], eax
	je	SHORT $LN175@normalizeE

; 1795 : 			{	// change reservation
; 1796 : 			size_type _Size = this->_Mysize();
; 1797 : 			if (_Grow(_Newcap, true))

	push	1
	push	eax
	mov	ecx, edi
	call	?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
	test	al, al
	je	SHORT $LN210@normalizeE

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN170@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN171@normalizeE
$LN170@normalizeE:
	mov	eax, edi
$LN171@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
$LN210@normalizeE:
	mov	ecx, DWORD PTR tv663[ebp]
$LN175@normalizeE:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN191@normalizeE
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN191@normalizeE:
; File e:\tool\c++incolude\jsoncpp-src-0.5.0\src\lib_json\json_writer.cpp

; 803  :    const char *end = begin + text.length();

	mov	eax, DWORD PTR [ecx]
	add	eax, esi
	mov	DWORD PTR _end$1$[ebp], eax

; 804  :    const char *current = begin;
; 805  :    while ( current != end )

	cmp	esi, eax
	je	SHORT $LN209@normalizeE
	npad	7
$LL2@normalizeE:

; 806  :    {
; 807  :       char c = *current++;

	mov	al, BYTE PTR [esi]
	mov	ebx, esi
	mov	DWORD PTR tv667[ebp], esi

; 808  :       if ( c == '\r' ) // mac or dos EOL
; 809  :       {
; 810  :          if ( *current == '\n' ) // convert dos EOL
; 811  :             ++current;
; 812  :          normalized += '\n';

	mov	ecx, edi
	inc	esi
	mov	BYTE PTR _c$52[ebp], al
	cmp	al, 13					; 0000000dH
	jne	SHORT $LN4@normalizeE
	mov	bl, BYTE PTR [esi]
	push	10					; 0000000aH
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	cmp	bl, 10					; 0000000aH
	cmovne	esi, DWORD PTR tv667[ebp]

; 813  :       }
; 814  :       else // handle unix EOL & other char

	jmp	SHORT $LN5@normalizeE
$LN4@normalizeE:

; 815  :          normalized += c;

	push	DWORD PTR _c$52[ebp]
	call	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
	mov	esi, ebx
$LN5@normalizeE:

; 804  :    const char *current = begin;
; 805  :    while ( current != end )

	inc	esi
	cmp	esi, DWORD PTR _end$1$[ebp]
	jne	SHORT $LL2@normalizeE
$LN209@normalizeE:

; 817  :    return normalized;

	mov	eax, edi

; 818  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN9@normalizeE
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN9@normalizeE:
	ret	0
__ehhandler$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?normalizeEOL@StyledStreamWriter@Json@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV34@@Z ENDP ; Json::StyledStreamWriter::normalizeEOL
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 219  : 		return (!(*this == _Right));
; 220  : 		}

	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 213  : 		_Compat(_Right);
; 214  : 		return (_Ptr == _Right._Ptr);
; 215  : 		}

	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++, COMDAT
; _this$ = ecx

; 113  : 		++_Ptr;

	add	DWORD PTR [ecx], 24			; 00000018H

; 341  : 		++*(_Mybase *)this;
; 342  : 		return (*this);

	mov	eax, ecx

; 343  : 		}

	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*, COMDAT
; _this$ = ecx

; 331  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 332  : 		}

	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Val$ = 8						; size = 4
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	edi, DWORD PTR __Val$[ebp]
	cmp	edi, ecx
	jae	SHORT $LN2@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	cmp	eax, edi
	ja	SHORT $LN2@push_back

; 1277 : 		if (_Inside(_STD addressof(_Val)))
; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	sub	edi, eax
	mov	eax, 715827883				; 2aaaaaabH
	imul	edi
	sar	edx, 2
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx

; 1280 : 			if (this->_Mylast() == this->_Myend())

	cmp	ecx, DWORD PTR [esi+8]
	jne	SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

	push	ecx
	mov	ecx, esi
	call	?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
$LN4@push_back:

; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [edi+edi*2]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	lea	eax, DWORD PTR [eax+ecx*8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edx, edx
	je	SHORT $LN335@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edx+20], 15			; 0000000fH

; 782  : 		assign(_Right, 0, npos);

	mov	ecx, edx

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1287 : 		else

	jmp	SHORT $LN479@push_back
$LN2@push_back:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

	cmp	ecx, DWORD PTR [esi+8]
	jne	SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

	push	ecx
	mov	ecx, esi
	call	?_Reserve@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@IAEXI@Z ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	ecx, ecx
	je	SHORT $LN335@push_back
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	edi
$LN479@push_back:
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN335@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	DWORD PTR [esi+4], 24			; 00000018H

; 1295 : 			}
; 1296 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$33:
	jmp	??3@YAXPAX0@Z				; operator delete
__unwindfunclet$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z$88:
	jmp	??3@YAXPAX0@Z				; operator delete
__ehhandler$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?push_back@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::push_back
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[], COMDAT
; _this$ = ecx

; 1230 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR __Pos$[ebp]
	lea	edx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [ecx]
	lea	eax, DWORD PTR [eax+edx*8]

; 1243 : 		}

	pop	ebp
	ret	4
??A?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAEAAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@I@Z ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end, COMDAT
; _this$ = ecx

; 1067 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], ecx

; 1068 : 		return (iterator(this->_Mylast(), &this->_Get_data()));
; 1069 : 		}

	pop	ebp
	ret	4
?end@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ PROC ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));
; 1059 : 		}

	pop	ebp
	ret	4
?begin@?$vector@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V?$allocator@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@2@XZ ENDP ; std::vector<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::allocator<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$dead$ = 12						; size = 1
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 850  : 		{	// construct from _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 852  : 		assign(_Count, _Ch);

	push	ecx
	push	DWORD PTR __Count$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 852  : 		assign(_Count, _Ch);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 853  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 822  : 		{	// construct from [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	esi

; 824  : 		assign(_Ptr, _Count);

	push	DWORD PTR __Count$[ebp]
	mov	esi, ecx
	push	DWORD PTR __Ptr$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 824  : 		assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 825  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 545  : 		{	// return string copy of character array

	push	ebp
	mov	ebp, esp
	push	ecx

; 546  : 		return (_Stringbuffer.str());

	push	DWORD PTR ___$ReturnUdt$[ebp]
	add	ecx, 4
	mov	DWORD PTR $T1[ebp], 0
	call	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 547  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?str@?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 536  : 		{	// destroy the object

	push	esi
	push	edi
	mov	edi, ecx
	mov	eax, DWORD PTR [edi-80]

; 76   : 		_Tidy();

	lea	ecx, DWORD PTR [edi-76]

; 536  : 		{	// destroy the object

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+edi-80], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR [edi-80]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-80]
	mov	DWORD PTR [edx+edi-84], eax

; 75   : 		{	// destroy the object

	mov	DWORD PTR [edi-76], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 76   : 		_Tidy();

	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	lea	ecx, DWORD PTR [edi-76]
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ

; 537  : 		}

	lea	ecx, DWORD PTR [edi-72]
	pop	edi
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -24						; size = 4
_this$ = -20						; size = 4
$T1 = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$dead$ = 8					; size = 4
_$initVBases$dead$ = 12					; size = 4
??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 492  : 		{	// construct empty writable character buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi
	mov	DWORD PTR $T1[ebp], 0
	lea	ecx, DWORD PTR [edi+80]
	mov	DWORD PTR [edi], OFFSET ??_8?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B@
	call	DWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IAE@XZ
	push	0
	push	0
	lea	esi, DWORD PTR [edi+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	esi
	mov	ecx, edi
	mov	DWORD PTR $T1[ebp], 1
	call	DWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@PAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [edi+eax], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR _this$[ebp], esi
	lea	eax, DWORD PTR [ecx-80]
	mov	DWORD PTR [ecx+edi-4], eax

; 30   : 		{	// construct empty character buffer from mode

	mov	ecx, esi
	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 493  : 		}

	mov	eax, edi

; 311  : 		_Seekhigh = 0;

	mov	DWORD PTR [esi+56], 0

; 312  : 		_Mystate = _State;

	mov	DWORD PTR [esi+60], 4

; 493  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
	mov	eax, DWORD PTR $T1[ebp]
	and	eax, 1
	je	$LN5@basic_ostr
	and	DWORD PTR $T1[ebp], -2			; fffffffeH
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 80					; 00000050H
	jmp	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
$LN5@basic_ostr:
	ret	0
__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 8
	jmp	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
__unwindfunclet$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
tv196 = -12						; size = 4
tv198 = -8						; size = 4
tv214 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Ptr$ = 12						; size = 24
__Mode$ = 36						; size = 4
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT
; _this$ = ecx

; 276  : 		{	// change position to _Pos, according to _Mode

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 12					; 0000000cH
	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

	mov	ebx, DWORD PTR __Ptr$[ebp+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

	mov	esi, DWORD PTR __Ptr$[ebp+8]
	add	esi, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

	adc	ebx, DWORD PTR __Ptr$[ebp+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [edi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN2@seekpos
	cmp	DWORD PTR [edi+56], eax
	jae	SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

	mov	DWORD PTR [edi+56], eax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

	mov	eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR tv196[esp+24], ecx
	mov	DWORD PTR tv198[esp+24], eax
	cmp	esi, ecx
	jne	SHORT $LN55@seekpos
	cmp	ebx, eax
	je	$LN11@seekpos
$LN55@seekpos:

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

	mov	edx, DWORD PTR __Mode$[ebp]
	test	dl, 1
	je	SHORT $LN5@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edi+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv214[esp+24], eax
	test	eax, eax
	je	SHORT $LN60@seekpos

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	ebx, ebx
	jl	SHORT $LN7@seekpos
	jg	SHORT $LN56@seekpos
	test	esi, esi
	jb	SHORT $LN7@seekpos
$LN56@seekpos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+56]
	sub	eax, ecx
	cdq
	cmp	ebx, edx
	jg	SHORT $LN64@seekpos
	jl	SHORT $LN57@seekpos
	cmp	esi, eax
	ja	SHORT $LN64@seekpos
$LN57@seekpos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	mov	eax, DWORD PTR [edi+44]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

	sub	ecx, DWORD PTR tv214[esp+24]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	sub	DWORD PTR [eax], ecx

; 248  : 		*_IGnext += _Off;

	mov	eax, DWORD PTR [edi+28]
	add	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	test	BYTE PTR __Mode$[ebp], 2
	je	SHORT $LN11@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	edx, DWORD PTR [edi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	cmp	DWORD PTR [edx], 0
	je	SHORT $LN11@seekpos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR [edi+48]
	mov	ecx, DWORD PTR [eax]

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edi+28]

; 260  : 		return (*_IPnext + *_IPcount);

	add	ecx, DWORD PTR [edx]

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [eax]

; 303  : 		*_IPcount = (int)(_Last - _Next);

	sub	ecx, eax
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [edi+48]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 292  : 			else

	jmp	SHORT $LN11@seekpos
$LN64@seekpos:
	mov	ecx, DWORD PTR tv196[esp+24]
$LN7@seekpos:

; 293  : 				_Off = _BADOFF;

	mov	ebx, DWORD PTR tv198[esp+24]
	jmp	SHORT $LN65@seekpos
$LN60@seekpos:
	mov	eax, DWORD PTR tv198[esp+24]
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

	test	dl, 2
	je	SHORT $LN10@seekpos
	mov	edx, DWORD PTR [edi+32]
	cmp	DWORD PTR [edx], 0
	je	SHORT $LN10@seekpos

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	ebx, ebx
	jl	SHORT $LN7@seekpos
	jg	SHORT $LN58@seekpos
	test	esi, esi
	jb	SHORT $LN7@seekpos
$LN58@seekpos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [edi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edi+56]
	sub	eax, ecx
	cdq
	cmp	ebx, edx
	jg	SHORT $LN64@seekpos
	jl	SHORT $LN59@seekpos
	cmp	esi, eax
	ja	SHORT $LN64@seekpos
$LN59@seekpos:

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

	mov	eax, DWORD PTR [edi+32]
	sub	ecx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	mov	eax, DWORD PTR [edi+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	sub	DWORD PTR [eax], ecx

; 289  : 		*_IPnext += _Off;

	mov	eax, DWORD PTR [edi+32]
	add	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 300  : 			else

	jmp	SHORT $LN11@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

	mov	ebx, eax
$LN65@seekpos:
	mov	esi, ecx
$LN11@seekpos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	xorps	xmm0, xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 306  : 		}

	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	mov	DWORD PTR [eax], esi
	mov	DWORD PTR [eax+4], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 306  : 		}

	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	movq	QWORD PTR [eax+16], xmm0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 306  : 		}

	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
tv264 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 8
__Way$ = 20						; size = 4
tv268 = 24						; size = 4
__Which$ = 24						; size = 4
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT
; _this$ = ecx

; 227  : 		{	// change position by _Off, according to _Way, _Mode

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	edx, DWORD PTR [ebx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

	mov	eax, DWORD PTR [edx]
	test	eax, eax
	je	SHORT $LN2@seekoff
	cmp	DWORD PTR [ebx+56], eax
	jae	SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

	mov	DWORD PTR [ebx+56], eax
$LN2@seekoff:

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

	mov	ecx, DWORD PTR __Which$[ebp]
	test	cl, 1
	je	$LN3@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [ebx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

	mov	esi, DWORD PTR [eax]
	mov	DWORD PTR tv264[ebp], esi
	test	esi, esi
	je	$LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

	mov	eax, DWORD PTR __Way$[ebp]
	cmp	eax, 2
	jne	SHORT $LN5@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

	mov	eax, DWORD PTR [ebx+56]
	mov	esi, DWORD PTR __Off$[ebp]
	mov	edi, DWORD PTR __Off$[ebp+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	add	esi, eax
	adc	edi, edx

; 235  : 			else if (_Way == ios_base::cur

	jmp	SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

	cmp	eax, 1
	jne	SHORT $LN7@seekoff
	test	cl, 2
	jne	SHORT $LN74@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

	mov	eax, esi
	mov	esi, DWORD PTR __Off$[ebp]
	mov	edi, DWORD PTR __Off$[ebp+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	add	esi, eax
	adc	edi, edx
	jmp	SHORT $LN9@seekoff
$LN7@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

	test	eax, eax
	je	SHORT $LN79@seekoff
$LN74@seekoff:

; 239  : 				_Off = _BADOFF;

	mov	edi, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	esi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi+4]
	jmp	SHORT $LN9@seekoff
$LN79@seekoff:
	mov	edi, DWORD PTR __Off$[ebp+4]
	mov	esi, DWORD PTR __Off$[ebp]
$LN9@seekoff:

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	edi, edi
	jl	$LN10@seekoff
	jg	SHORT $LN75@seekoff
	test	esi, esi
	jb	$LN10@seekoff
$LN75@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+56]
	sub	eax, ecx
	cdq
	cmp	edi, edx
	jg	$LN10@seekoff
	jl	SHORT $LN76@seekoff
	cmp	esi, eax
	ja	$LN10@seekoff
$LN76@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	mov	eax, DWORD PTR [ebx+44]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

	sub	ecx, DWORD PTR tv264[ebp]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	sub	DWORD PTR [eax], ecx

; 248  : 		*_IGnext += _Off;

	mov	eax, DWORD PTR [ebx+28]
	add	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

	test	BYTE PTR __Which$[ebp], 2
	je	$LN22@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	edx, DWORD PTR [ebx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

	cmp	DWORD PTR [edx], 0
	je	$LN22@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR [ebx+48]
	mov	ecx, DWORD PTR [eax]

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [ebx+28]

; 260  : 		return (*_IPnext + *_IPcount);

	add	ecx, DWORD PTR [edx]

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [eax]

; 303  : 		*_IPcount = (int)(_Last - _Next);

	sub	ecx, eax
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ebx+48]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 248  : 			else

	jmp	$LN22@seekoff
$LN3@seekoff:

; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

	test	cl, 2
	je	$LN13@seekoff
	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR tv268[ebp], edx
	test	edx, edx
	je	SHORT $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

	mov	eax, DWORD PTR __Way$[ebp]
	cmp	eax, 2
	jne	SHORT $LN15@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

	mov	eax, DWORD PTR [ebx+56]
	mov	esi, DWORD PTR __Off$[ebp]
	mov	edi, DWORD PTR __Off$[ebp+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	add	esi, eax
	adc	edi, edx
	jmp	SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

	cmp	eax, 1
	jne	SHORT $LN17@seekoff
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

	mov	eax, edx
	mov	esi, DWORD PTR __Off$[ebp]
	mov	edi, DWORD PTR __Off$[ebp+4]
	sub	eax, DWORD PTR [ecx]
	cdq
	add	esi, eax
	adc	edi, edx
	jmp	SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

	test	eax, eax
	je	SHORT $LN80@seekoff

; 258  : 				_Off = _BADOFF;

	mov	edi, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	esi, DWORD PTR [edi]
	mov	edi, DWORD PTR [edi+4]
	jmp	SHORT $LN19@seekoff
$LN80@seekoff:
	mov	edi, DWORD PTR __Off$[ebp+4]
	mov	esi, DWORD PTR __Off$[ebp]
$LN19@seekoff:

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	test	edi, edi
	jl	SHORT $LN10@seekoff
	jg	SHORT $LN77@seekoff
	test	esi, esi
	jb	SHORT $LN10@seekoff
$LN77@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [ebx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR [ebx+56]
	sub	eax, ecx
	cdq
	cmp	edi, edx
	jg	SHORT $LN10@seekoff
	jl	SHORT $LN78@seekoff
	cmp	esi, eax
	ja	SHORT $LN10@seekoff
$LN78@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	mov	eax, DWORD PTR [ebx+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

	sub	ecx, DWORD PTR tv268[ebp]
	add	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 288  : 		*_IPcount -= _Off;

	sub	DWORD PTR [eax], ecx

; 289  : 		*_IPnext += _Off;

	mov	eax, DWORD PTR [ebx+32]
	add	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 263  : 			else

	jmp	SHORT $LN22@seekoff
$LN13@seekoff:

; 264  : 				_Off = _BADOFF;
; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

	mov	esi, DWORD PTR __Off$[ebp]
	mov	eax, esi
	mov	edi, DWORD PTR __Off$[ebp+4]
	or	eax, edi
	je	SHORT $LN22@seekoff
$LN10@seekoff:

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

	mov	eax, DWORD PTR __imp_?_BADOFF@std@@3_JB
	mov	esi, DWORD PTR [eax]
	mov	edi, DWORD PTR [eax+4]
$LN22@seekoff:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
	movq	QWORD PTR [eax+16], xmm0
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 272  : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAE?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ
_TEXT	SEGMENT
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT
; _this$ = ecx

; 207  : 		{	// get an element from stream, but don't point past it

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	esi, DWORD PTR [ecx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 208  : 		if (_Mysb::gptr() == 0)

	mov	edx, DWORD PTR [esi]
	test	edx, edx
	jne	SHORT $LN2@underflow

; 209  : 			return (_Traits::eof());	// no character buffer, fail

	or	eax, -1
	pop	esi

; 222  : 		}

	ret	0
$LN2@underflow:
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

	mov	edi, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [edi]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

	cmp	edx, eax
	jae	SHORT $LN4@underflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 589  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [edx]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 222  : 		}

	ret	0
$LN4@underflow:

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

	test	BYTE PTR [ecx+60], 4
	jne	SHORT $LN8@underflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [ecx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN8@underflow
	cmp	eax, edx
	ja	SHORT $LN6@underflow
	cmp	DWORD PTR [ecx+56], edx
	jbe	SHORT $LN8@underflow
$LN6@underflow:

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

	cmp	DWORD PTR [ecx+56], eax
	jae	SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

	mov	DWORD PTR [ecx+56], eax
$LN9@underflow:

; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

	mov	eax, DWORD PTR [ecx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 255  : 		*_IGcount = (int)(_Last - _Next);

	sub	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [ecx+28]
	pop	edi
	pop	esi
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 589  : 		return ((unsigned char)_Ch);

	movzx	eax, BYTE PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 222  : 		}

	ret	0
$LN8@underflow:
	pop	edi

; 214  : 			return (_Traits::eof());	// can't read, fail

	or	eax, -1
	pop	esi

; 222  : 		}

	ret	0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
__Meta$ = 8						; size = 4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT
; _this$ = ecx

; 190  : 		{	// put an element back to stream

	push	ebp
	mov	ebp, esp
	mov	edx, ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN4@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [edx+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	cmp	esi, DWORD PTR [eax]
	jbe	SHORT $LN4@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	mov	ecx, DWORD PTR __Meta$[ebp]
	cmp	ecx, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN2@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 571  : 		return (_Left == _Right);

	cmp	cl, BYTE PTR [esi-1]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN2@pbackfail
	test	BYTE PTR [edx+60], 2
	jne	SHORT $LN4@pbackfail
$LN2@pbackfail:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 247  : 		*_IGcount -= _Off;

	mov	eax, DWORD PTR [edx+44]
	inc	DWORD PTR [eax]

; 248  : 		*_IGnext += _Off;

	mov	eax, DWORD PTR [edx+28]
	dec	DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	ecx, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

	je	SHORT $LN45@pbackfail
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edx+28]
	pop	esi
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

	mov	BYTE PTR [eax], cl

; 202  : 			return (_Traits::not_eof(_Meta));

	mov	eax, ecx

; 203  : 			}
; 204  : 		}

	pop	ebp
	ret	4
$LN45@pbackfail:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 601  : 		return (_Meta != eof() ? _Meta : !eof());

	xor	ecx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 202  : 			return (_Traits::not_eof(_Meta));

	mov	eax, ecx
	pop	esi

; 203  : 			}
; 204  : 		}

	pop	ebp
	ret	4
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

	or	eax, -1
	pop	esi

; 203  : 			}
; 204  : 		}

	pop	ebp
	ret	4
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z
_TEXT	SEGMENT
tv597 = -8						; size = 4
__Newsize$1$ = -8					; size = 4
__Oldptr$1$ = -4					; size = 4
__Meta$ = 8						; size = 4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT
; _this$ = ecx

; 120  : 		{	// put an element to stream

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	esi
	mov	esi, ecx

; 121  : 		if (_Mystate & _Constant)

	mov	eax, DWORD PTR [esi+60]
	test	al, 2
	je	SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

	or	eax, -1
	pop	esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN4@overflow:
	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	mov	ebx, DWORD PTR __Meta$[ebp]
	cmp	ebx, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

	jne	SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

	pop	ebx
	xor	eax, eax
	pop	esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN6@overflow:
	push	edi

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

	test	al, 8
	je	SHORT $LN7@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN7@overflow
	mov	edi, DWORD PTR [esi+56]
	cmp	edx, edi
	jae	SHORT $LN7@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [eax]

; 302  : 		*_IPnext = _Next;

	mov	eax, DWORD PTR [esi+32]

; 260  : 		return (*_IPnext + *_IPcount);

	add	ecx, edx

; 303  : 		*_IPcount = (int)(_Last - _Next);

	sub	ecx, edi
	mov	DWORD PTR [eax], edi
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], ecx
$LN7@overflow:

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	SHORT $LN119@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	edi, DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [edi]
	lea	eax, DWORD PTR [ecx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

	cmp	edx, eax
	jae	SHORT $LN8@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 308  : 		--*_IPcount;

	dec	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 134  : 			return (_Meta);

	mov	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 308  : 		--*_IPcount;

	mov	DWORD PTR [edi], ecx

; 309  : 		return ((*_IPnext)++);

	mov	edx, DWORD PTR [esi+32]
	pop	edi
	mov	esi, DWORD PTR [edx]
	lea	ecx, DWORD PTR [esi+1]
	mov	DWORD PTR [edx], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 133  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	BYTE PTR [esi], bl
	pop	ebx
	pop	esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN8@overflow:

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

	test	edx, edx
	jne	SHORT $LN20@overflow
$LN119@overflow:
	xor	edi, edi
	jmp	SHORT $LN21@overflow
$LN20@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR [esi+48]

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

	mov	edi, DWORD PTR [eax]
	sub	edi, DWORD PTR [ecx]
	add	edi, edx
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

	mov	ecx, edi
	shr	ecx, 1
	cmp	ecx, 32					; 00000020H
	jae	SHORT $LN22@overflow
	mov	ecx, 32					; 00000020H
	jmp	SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

	test	ecx, ecx
	je	SHORT $LN121@overflow
	npad	4
$LL2@overflow:
	mov	eax, 2147483647				; 7fffffffH
	sub	eax, ecx
	cmp	eax, edi
	jae	SHORT $LN114@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

	shr	ecx, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

	jne	SHORT $LL2@overflow
$LN114@overflow:

; 146  : 			if (_Inc == 0)

	test	ecx, ecx
	jne	SHORT $LN10@overflow
$LN121@overflow:
	pop	edi
	pop	ebx

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

	or	eax, -1
	pop	esi

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN10@overflow:

; 148  : 
; 149  : 			_Newsize += _Inc;

	lea	eax, DWORD PTR [ecx+edi]

; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

	push	eax
	mov	DWORD PTR __Newsize$1$[ebp], eax
	call	?allocate@?$allocator@D@std@@QAEPADI@Z	; std::allocator<char>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 151  : 			_Elem *_Newptr = _Al.allocate(_Newsize);

	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 222  : 		return (*_IGfirst);

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR __Oldptr$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 154  : 			if (0 < _Oldsize)

	test	edi, edi
	je	SHORT $LN123@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	ecx
	push	ebx
	call	_memcpy
	mov	ecx, DWORD PTR __Oldptr$1$[ebp]
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 157  : 			if (_Oldsize == 0)

	test	edi, edi
	jne	SHORT $LN12@overflow
$LN123@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 294  : 		*_IPfirst = _First;

	mov	eax, DWORD PTR [esi+16]

; 296  : 		*_IPcount = (int)(_Last - _First);

	mov	edx, DWORD PTR __Newsize$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 159  : 				_Seekhigh = _Newptr;

	mov	DWORD PTR [esi+56], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 294  : 		*_IPfirst = _First;

	mov	DWORD PTR [eax], ebx

; 295  : 		*_IPnext = _First;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], ebx

; 296  : 		*_IPcount = (int)(_Last - _First);

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], edx

; 253  : 		*_IGfirst = _First;

	mov	eax, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 161  : 				if (_Mystate & _Noread)

	test	BYTE PTR [esi+60], 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	DWORD PTR [eax], ebx

; 254  : 		*_IGnext = _Next;

	mov	eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 161  : 				if (_Mystate & _Noread)

	je	SHORT $LN14@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 254  : 		*_IGnext = _Next;

	mov	DWORD PTR [eax], 0

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 163  : 				else

	jmp	SHORT $LN17@overflow
$LN14@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 254  : 		*_IGnext = _Next;

	mov	DWORD PTR [eax], ebx

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 166  : 			else

	jmp	SHORT $LN17@overflow
$LN12@overflow:

; 167  : 				{	// not first growth, adjust pointers
; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

	mov	eax, ebx
	sub	eax, ecx
	add	DWORD PTR [esi+56], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

	mov	edx, DWORD PTR [eax]
	mov	eax, ebx
	sub	eax, DWORD PTR __Oldptr$1$[ebp]
	sub	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 232  : 		return (*_IPfirst);

	mov	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

	add	edx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 301  : 		*_IPfirst = _First;

	add	DWORD PTR [ecx], eax

; 303  : 		*_IPcount = (int)(_Last - _Next);

	mov	ecx, ebx
	mov	eax, DWORD PTR [esi+32]
	sub	ecx, edx
	add	ecx, DWORD PTR __Newsize$1$[ebp]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 172  : 				if (_Mystate & _Noread)

	test	BYTE PTR [esi+60], 4
	je	SHORT $LN16@overflow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax], ebx

; 254  : 		*_IGnext = _Next;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], 0

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 174  : 				else

	jmp	SHORT $LN17@overflow
$LN16@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [esi+32]
	mov	edx, DWORD PTR [eax]

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [esi+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 175  : 					_Mysb::setg(_Newptr,

	mov	ecx, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	eax, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 175  : 					_Mysb::setg(_Newptr,

	sub	ecx, DWORD PTR __Oldptr$1$[ebp]
	add	ecx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 255  : 		*_IGcount = (int)(_Last - _Next);

	sub	edx, ecx
	mov	DWORD PTR [eax], ebx
	inc	edx
	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], ecx
	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], edx
$LN17@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 180  : 			if (_Mystate & _Allocated)

	test	BYTE PTR [esi+60], 1
	je	SHORT $LN18@overflow

; 181  : 				_Al.deallocate(_Oldptr, _Oldsize);

	push	edi
	push	DWORD PTR __Oldptr$1$[ebp]
	call	?deallocate@?$allocator@D@std@@QAEXPADI@Z ; std::allocator<char>::deallocate
$LN18@overflow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 308  : 		--*_IPcount;

	mov	eax, DWORD PTR [esi+48]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 182  : 			_Mystate |= _Allocated;

	or	DWORD PTR [esi+60], 1
	pop	edi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 308  : 		--*_IPcount;

	dec	DWORD PTR [eax]

; 309  : 		return ((*_IPnext)++);

	mov	ecx, DWORD PTR [esi+32]
	pop	esi
	mov	edx, DWORD PTR [ecx]
	lea	eax, DWORD PTR [edx+1]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 184  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	mov	eax, DWORD PTR __Meta$[ebp]
	mov	BYTE PTR [edx], al

; 185  : 			return (_Meta);
; 186  : 			}
; 187  : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ
_TEXT	SEGMENT
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 75   : 		{	// destroy the object

	push	esi
	mov	esi, ecx
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 76   : 		_Tidy();

	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	mov	ecx, esi
	pop	esi
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAE@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 536  : 		{	// destroy the object

	mov	eax, DWORD PTR [edi-80]
	lea	ebx, DWORD PTR [edi-80]

; 76   : 		_Tidy();

	lea	ecx, DWORD PTR [edi-76]

; 536  : 		{	// destroy the object

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR [eax+edi-80], OFFSET ??_7?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR [edx-80]
	mov	DWORD PTR [edx+edi-84], eax

; 75   : 		{	// destroy the object

	mov	DWORD PTR [edi-76], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 76   : 		_Tidy();

	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	lea	ecx, DWORD PTR [edi-76]
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ

; 537  : 		}

	lea	ecx, DWORD PTR [edi-72]
	call	DWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UAE@XZ
	mov	ecx, edi
	call	DWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN13@scalar
	push	152					; 00000098H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@scalar:
	pop	edi
	pop	esi
	mov	eax, ebx
	pop	ebx
	pop	ebp
	ret	4
??_G?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 75   : 		{	// destroy the object

	mov	DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 76   : 		_Tidy();

	call	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy

; 77   : 		}

	mov	ecx, esi
	call	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN7@scalar
	push	68					; 00000044H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$dead$ = 8					; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Compat, COMDAT
; _this$dead$ = ecx

; 262  : 		}

	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++, COMDAT
; _this$ = ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 98   : 		if (_Mycont == 0
; 99   : 			|| _Ptr == nullptr_t{}
; 100  : 			|| _Mycont->_Mylast <= _Ptr)
; 101  : 			{	// report error
; 102  : 			_DEBUG_ERROR("vector iterator not incrementable");
; 103  : 			_SCL_SECURE_OUT_OF_RANGE;
; 104  : 			}
; 105  : 
; 106  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 107  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 108  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 109  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 110  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 111  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 112  : 
; 113  : 		++_Ptr;

	add	DWORD PTR [ecx], 24			; 00000018H

; 114  : 		return (*this);

	mov	eax, ecx

; 115  : 		}

	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ
_TEXT	SEGMENT
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*, COMDAT
; _this$ = ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)
; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");
; 74   : 			_SCL_SECURE_OUT_OF_RANGE;
; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

	mov	eax, DWORD PTR [ecx]

; 87   : 		}

	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pvector$dead$ = 12					; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base0@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 314  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@@std@@QAE@PAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@PBU_Container_base0@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ
_TEXT	SEGMENT
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT
; _this$ = ecx

; 142  : 			return (_Ok);

	mov	al, BYTE PTR [ecx+4]

; 143  : 			}

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QBE_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
; _this$ = ecx

; 130  : 			{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN2@sentry

; 133  : 				this->_Myostr._Osfx();

	mov	ecx, DWORD PTR [esi]
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN2@sentry:

; 106  : 			{	// destroy after unlocking

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN5@sentry

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN5@sentry:

; 134  : 
; 135  :  #else /* _HAS_EXCEPTIONS */
; 136  : 			this->_Myostr._Osfx();
; 137  :  #endif /* _HAS_EXCEPTIONS */
; 138  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ$0:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Ostr$ = 8						; size = 4
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT
; _this$ = ecx

; 123  : 			{	// construct locking and testing stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 99   : 			: _Myostr(_Ostr)

	mov	esi, DWORD PTR __Ostr$[ebp]
	mov	DWORD PTR [edi], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN6@sentry

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN6@sentry:

; 103  : 			}
; 104  : 
; 105  : 		__CLR_OR_THIS_CALL ~_Sentry_base() _NOEXCEPT
; 106  : 			{	// destroy after unlocking
; 107  : 			if (_Myostr.rdbuf() != 0)
; 108  : 				_Myostr.rdbuf()->_Unlock();
; 109  : 			}
; 110  : 
; 111  : 		_Myt& _Myostr;	// the output stream, for _Unlock call at destruction
; 112  : 
; 113  : 	private:
; 114  : 		_Sentry_base& operator=(const _Sentry_base&);
; 115  : 		};
; 116  : 
; 117  : 	class sentry
; 118  : 		: public _Sentry_base
; 119  : 		{	// stores thread lock and state of stream
; 120  : 	public:
; 121  : 		explicit __CLR_OR_THIS_CALL sentry(_Myt& _Ostr)
; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+esi+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN2@sentry
	mov	ecx, DWORD PTR [eax+esi+60]
	test	ecx, ecx
	je	SHORT $LN2@sentry
	cmp	ecx, esi
	je	SHORT $LN2@sentry

; 125  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN2@sentry:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 339  : 		return (rdstate() == goodbit);

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	cmp	DWORD PTR [eax+esi+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR [edi+4], al

; 127  : 			}

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__ehhandler$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$dead$ = 12						; size = 1
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1186 : 		{	// assign _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 1187 : 		if (_Count == npos)

	mov	edi, DWORD PTR __Count$[ebp]
	mov	esi, ecx
	cmp	edi, -1
	jne	SHORT $LN2@assign

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN250@assign:
$LN2@assign:

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN9@assign

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
$LN251@assign:
$LN9@assign:

; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN10@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1188 : 			_Xlen();	// result too long
; 1189 : 
; 1190 : 		if (_Grow(_Count))

	je	SHORT $LN244@assign
$LN248@assign:

; 2175 : 		if (_Count == 1)

	cmp	edi, 1
	jne	SHORT $LN193@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN206@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2177 : 		else

	jmp	SHORT $LN194@assign
$LN10@assign:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN248@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN185@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1195 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1196 : 		}

	pop	ebp
	ret	8
$LN185@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1196 : 		}

	pop	ebp
	ret	8
$LN206@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2177 : 		else

	jmp	SHORT $LN194@assign
$LN193@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN223@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN224@assign
$LN223@assign:
	mov	eax, esi
$LN224@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	edi
	push	32					; 00000020H
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
$LN194@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN239@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1195 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1196 : 		}

	pop	ebp
	ret	8
$LN239@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN244@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1195 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1196 : 		}

	pop	ebp
	ret	8
$LN249@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 337  : 		{	// discard any allocated buffer and clear pointers

	push	esi
	mov	esi, ecx

; 338  : 		if (_Mystate & _Allocated)

	test	BYTE PTR [esi+60], 1
	je	SHORT $LN25@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [esi+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	mov	ecx, DWORD PTR [eax]
	test	ecx, ecx
	je	SHORT $LN4@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 260  : 		return (*_IPnext + *_IPcount);

	mov	eax, DWORD PTR [esi+48]
	mov	edx, DWORD PTR [eax]
	add	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	jmp	SHORT $LN5@Tidy
$LN4@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

	mov	eax, DWORD PTR [esi+44]
	mov	ecx, DWORD PTR [esi+28]
	mov	edx, DWORD PTR [eax]
	add	edx, DWORD PTR [ecx]
$LN5@Tidy:

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [esi+12]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 339  : 			_Al.deallocate(_Mysb::eback(),

	mov	eax, DWORD PTR [eax]
	sub	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	edx, 4096				; 00001000H
	jb	SHORT $LN20@Tidy

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	je	SHORT $LN21@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN34@Tidy:
$LN21@Tidy:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jb	SHORT $LN22@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN35@Tidy:
$LN22@Tidy:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jae	SHORT $LN23@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN36@Tidy:
$LN23@Tidy:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN24@Tidy
	call	DWORD PTR __imp___invalid_parameter_noinfo_noreturn
$LN37@Tidy:
$LN24@Tidy:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN20@Tidy:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN25@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 253  : 		*_IGfirst = _First;

	mov	eax, DWORD PTR [esi+12]
	mov	DWORD PTR [eax], 0

; 254  : 		*_IGnext = _Next;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [eax], 0

; 255  : 		*_IGcount = (int)(_Last - _Next);

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR [eax], 0

; 294  : 		*_IPfirst = _First;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax], 0

; 295  : 		*_IPnext = _First;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [eax], 0

; 296  : 		*_IPcount = (int)(_Last - _First);

	mov	eax, DWORD PTR [esi+48]
	mov	DWORD PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

	and	DWORD PTR [esi+60], -2			; fffffffeH
	mov	DWORD PTR [esi+56], 0
	pop	esi

; 346  : 		}

	ret	0
$LN33@Tidy:
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
$T1 = -32						; size = 4
__Nul$167 = -28						; size = 24
__Str$168 = -28						; size = 24
__Str$169 = -28						; size = 24
__$ArrayPad$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT
; _this$ = ecx

; 93   : 		{	// return string copy of character array

	push	ebp
	mov	ebp, esp
	and	esp, -8					; fffffff8H
	sub	esp, 32					; 00000020H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, esp
	mov	DWORD PTR __$ArrayPad$[esp+32], eax
	mov	edx, ecx
	mov	DWORD PTR $T1[esp+32], 0
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	push	edi

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

	mov	ecx, DWORD PTR [edx+60]
	test	cl, 2
	jne	SHORT $LN2@str
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 237  : 		return (*_IPnext);

	mov	eax, DWORD PTR [edx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN2@str

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

	mov	ecx, DWORD PTR [edx+56]
	cmp	ecx, eax
	cmovb	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 232  : 		return (*_IPfirst);

	mov	eax, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 824  : 		assign(_Ptr, _Count);

	push	ecx
	push	eax
	lea	ecx, DWORD PTR __Str$169[esp+48]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$169[esp+68], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str$169[esp+64], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR __Str$169[esp+48], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 824  : 		assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 98   : 			return (_Str);

	lea	eax, DWORD PTR __Str$169[esp+40]
	mov	ecx, esi
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR __Str$169[esp+60]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN559@str

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 98   : 			return (_Str);

	jmp	SHORT $LN654@str
$LN2@str:

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

	test	cl, 4
	jne	SHORT $LN4@str
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 227  : 		return (*_IGnext);

	mov	eax, DWORD PTR [edx+28]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN4@str
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\streambuf

; 242  : 		return (*_IGnext + *_IGcount);

	mov	eax, DWORD PTR [edx+44]
	mov	ecx, DWORD PTR [eax]

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [edx+12]

; 242  : 		return (*_IGnext + *_IGcount);

	add	ecx, edi

; 222  : 		return (*_IGfirst);

	mov	eax, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

	sub	ecx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 824  : 		assign(_Ptr, _Count);

	push	ecx
	push	eax
	lea	ecx, DWORD PTR __Str$168[esp+48]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Str$168[esp+68], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Str$168[esp+64], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR __Str$168[esp+48], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 824  : 		assign(_Ptr, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 103  : 			return (_Str);

	jmp	SHORT $LN657@str
$LN4@str:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR __Nul$167[esp+60], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR __Nul$167[esp+56], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR __Nul$167[esp+40], 0
$LN657@str:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 108  : 			return (_Nul);

	lea	eax, DWORD PTR __Nul$167[esp+40]
	mov	ecx, esi
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR __Nul$167[esp+60]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN559@str

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;
; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)
; 2256 : 				_Traits::copy(this->_Bx()._Buf,
; 2257 : 					_Unfancy(_Ptr), _Newsize);
; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
	push	eax
$LN654@str:
	push	DWORD PTR __Nul$167[esp+44]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::deallocate
$LN559@str:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream

; 110  : 		}

	mov	ecx, DWORD PTR __$ArrayPad$[esp+40]
	mov	eax, esi
	pop	edi
	pop	esi
	xor	ecx, esp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
_TEXT	SEGMENT
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
__Mode$dead$ = 8					; size = 4
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

	call	DWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IAE@XZ
	mov	DWORD PTR [esi], OFFSET ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@

; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}

	mov	eax, esi

; 311  : 		_Seekhigh = 0;

	mov	DWORD PTR [esi+56], 0

; 312  : 		_Mystate = _State;

	mov	DWORD PTR [esi+60], 4

; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	DWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UAE@XZ
__ehhandler$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ
_TEXT	SEGMENT
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT
; _this$ = ecx

; 68   : 		return ((streamoff)(_Myoff + _FPOSOFF(_Fpos)));

	mov	eax, DWORD PTR [ecx+8]
	add	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [ecx+12]
	adc	edx, DWORD PTR [ecx+4]

; 69   : 		}

	ret	0
??B?$fpos@U_Mbstatet@@@std@@QBE_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT
; _this$ = ecx

; 43   : 		{	// construct with stream offset

	push	ebp
	mov	ebp, esp

; 42   : 		: _Myoff(_Off), _Fpos(_Fpz), _Mystate()

	mov	eax, DWORD PTR __Off$[ebp]
	xorps	xmm0, xmm0
	mov	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR __Off$[ebp+4]
	mov	DWORD PTR [ecx+4], eax

; 44   : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0
	movq	QWORD PTR [ecx+16], xmm0
	pop	ebp
	ret	8
??0?$fpos@U_Mbstatet@@@std@@QAE@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT
; _this$ = ecx

; 106  : 			{	// destroy after unlocking

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+ecx+56]
	test	ecx, ecx
	je	SHORT $LN2@Sentry_bas

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN2@Sentry_bas:

; 109  : 			}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z
_TEXT	SEGMENT
__Ostr$ = 8						; size = 4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT
; _this$ = ecx

; 100  : 			{	// lock the stream buffer, if there

	push	ebp
	mov	ebp, esp

; 99   : 			: _Myostr(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	esi

; 100  : 			{	// lock the stream buffer, if there

	mov	esi, ecx
	mov	DWORD PTR [esi], edx

; 101  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edx+56]
	test	ecx, ecx
	je	SHORT $LN8@Sentry_bas

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN8@Sentry_bas:

; 103  : 			}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@AAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z
_TEXT	SEGMENT
__Mode$dead$ = 8					; size = 4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT
; _this$dead$ = ecx

; 355  : 		_Strstate _State = (_Strstate)0;
; 356  : 		if (!(_Mode & ios_base::in))
; 357  : 			_State |= _Noread;
; 358  : 		if (!(_Mode & ios_base::out))
; 359  : 			_State |= _Constant;
; 360  : 		if (_Mode & ios_base::app)
; 361  : 			_State |= _Append;
; 362  : 		if (_Mode & ios_base::ate)
; 363  : 			_State |= _Atend;
; 364  : 		return (_State);

	mov	eax, 4

; 365  : 		}

	ret	4
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAEHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z
_TEXT	SEGMENT
__Ptr$dead$ = 8						; size = 4
__Count$dead$ = 12					; size = 4
__State$ = 16						; size = 4
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init, COMDAT
; _this$ = ecx

; 310  : 		{	// initialize buffer to [_Ptr, _Ptr + _Count), set state

	push	ebp
	mov	ebp, esp

; 311  : 		_Seekhigh = 0;
; 312  : 		_Mystate = _State;

	mov	eax, DWORD PTR __State$[ebp]
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], eax

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Al.allocate(_Count);
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IAEXPBDIH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
_TEXT	SEGMENT
__Ok$ = -48						; size = 8
__Pad$ = -48						; size = 8
__State$ = -36						; size = 4
__Val$1$ = -32						; size = 4
$T19 = -32						; size = 1
$T13 = -28						; size = 1
__Ostr$ = -24						; size = 4
__Count$2$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Val$ = edx

; 780  : 	{	// insert NTBS into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	eax, edx
	mov	DWORD PTR __Val$1$[ebp], eax
	mov	ebx, ecx
	mov	DWORD PTR __Ostr$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 783  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	jne	SHORT $LN26@operator
	xor	ecx, ecx
	jmp	SHORT $LN121@operator
$LN26@operator:
	mov	ecx, eax
	lea	edx, DWORD PTR [ecx+1]
	npad	6
$LL108@operator:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL108@operator
	sub	ecx, edx
$LN121@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	DWORD PTR __Count$2$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	eax, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+ebx+36]
	mov	esi, DWORD PTR [eax+ebx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 785  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN110@operator
	test	esi, esi
	je	SHORT $LN17@operator
	test	edi, edi
	jl	SHORT $LN17@operator
	jg	SHORT $LN110@operator
	cmp	esi, ecx
	jbe	SHORT $LN17@operator
$LN110@operator:
	sub	esi, ecx
	sbb	edi, 0
	jmp	SHORT $LN18@operator
$LN17@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$[ebp], xmm0
	mov	edi, DWORD PTR __Pad$[ebp+4]
	mov	esi, DWORD PTR __Pad$[ebp]
$LN18@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [eax+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 99   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], ebx

; 100  : 			{	// lock the stream buffer, if there
; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN39@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN39@operator:

; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+ebx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN35@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [eax+ebx+60]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN35@operator
	cmp	ecx, ebx
	je	SHORT $LN35@operator

; 125  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN35@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+ebx+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al

; 786  : 		? 0 : _Ostr.width() - _Count;
; 787  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 788  : 
; 789  : 	if (!_Ok)

	test	al, al
	jne	SHORT $LN8@operator

; 790  : 		_State |= ios_base::badbit;

	mov	ecx, 4

; 791  : 	else

	jmp	$LN22@operator
$LN8@operator:

; 792  : 		{	// state okay, insert
; 793  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+ebx+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 794  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN105@operator
	npad	2
$LL4@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	edi, edi
	jl	SHORT $LN3@operator
	jg	SHORT $LN111@operator
	test	esi, esi
	je	SHORT $LN3@operator
$LN111@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T13[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T13[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 796  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN2@operator
$LN112@operator:

; 797  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 798  : 					{	// insertion failed, quit
; 799  : 					_State |= ios_base::badbit;

	mov	ecx, 4

; 800  : 					break;

	jmp	SHORT $LN6@operator
$LN2@operator:

; 795  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL4@operator
$LN3@operator:
	xor	ecx, ecx

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	jne	SHORT $LN6@operator
$LN105@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	0
	push	DWORD PTR __Count$2$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 804  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

	push	DWORD PTR __Val$1$[ebp]
	mov	ecx, DWORD PTR [eax+ebx+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	eax, DWORD PTR __Count$2$[ebp]
	jne	SHORT $LN112@operator
	test	edx, edx
	jne	SHORT $LN112@operator
$LL114@operator:

; 805  : 			_State |= ios_base::badbit;
; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	edi, edi
	jl	SHORT $LN118@operator
	jg	SHORT $LN113@operator
	test	esi, esi
	je	SHORT $LN118@operator
$LN113@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T19[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T19[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 809  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN5@operator

; 810  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 811  : 					{	// insertion failed, quit
; 812  : 					_State |= ios_base::badbit;

	xor	ecx, ecx
	or	ecx, 4

; 813  : 					break;

	jmp	SHORT $LN6@operator
$LN5@operator:

; 805  : 			_State |= ios_base::badbit;
; 806  : 
; 807  : 		if (_State == ios_base::goodbit)
; 808  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	add	esi, -1
	adc	edi, -1
	jmp	SHORT $LL114@operator
$LN118@operator:
	xor	ecx, ecx
$LN6@operator:

; 814  : 					}
; 815  : 		_Ostr.width(0);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
	jmp	SHORT $LN124@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$0:

; 816  : 		_CATCH_IO_(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	ebx, DWORD PTR __Ostr$[ebp]
	mov	ecx, DWORD PTR __State$[ebp]
$LN124@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 817  : 		}
; 818  : 
; 819  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	ecx
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 130  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 133  : 				this->_Myostr._Osfx();

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN88@operator
	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN88@operator:

; 106  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN115@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN115@operator:

; 820  : 	return (_Ostr);

	mov	eax, ebx

; 821  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$8:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z$9:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@PBD@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
_TEXT	SEGMENT
__Ok$ = -40						; size = 8
__Pad$30 = -32						; size = 8
$T21 = -28						; size = 1
$T12 = -28						; size = 1
__State$ = -24						; size = 4
__Ostr$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT
; __Ostr$ = ecx
; __Ch$dead$ = dl

; 826  : 	{	// insert a char into char stream

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Ostr$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 829  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	esi, esi

; 99   : 			: _Myostr(_Ostr)

	mov	edi, ecx

; 829  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], esi

; 99   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
	mov	edx, DWORD PTR [eax+ecx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 101  : 			if (_Myostr.rdbuf() != 0)

	test	edx, edx
	je	SHORT $LN27@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [edx]
	mov	ecx, edx
	call	DWORD PTR [eax+4]
	mov	ecx, edi
$LN27@operator:

; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+ecx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN23@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

	mov	eax, DWORD PTR [eax+ecx+60]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	eax, eax
	je	SHORT $LN23@operator
	cmp	eax, ecx
	je	SHORT $LN23@operator

; 125  : 				_Ostr.tie()->flush();

	mov	ecx, eax
	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
	mov	ecx, DWORD PTR __Ostr$[ebp]
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR [eax+4]
	add	edx, ecx

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [edx+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al

; 830  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 831  : 
; 832  : 	if (_Ok)

	test	al, al
	je	$LN20@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	ebx, DWORD PTR [edx+36]
	mov	edi, DWORD PTR [edx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 834  : 		streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

	test	ebx, ebx
	jg	SHORT $LN15@operator
	jl	SHORT $LN108@operator
	cmp	edi, 1
	ja	SHORT $LN15@operator
$LN108@operator:
	xorps	xmm0, xmm0
	movlpd	QWORD PTR __Pad$30[ebp], xmm0
	mov	ebx, DWORD PTR __Pad$30[ebp+4]
	mov	edi, DWORD PTR __Pad$30[ebp]
	jmp	SHORT $LN16@operator
$LN15@operator:
	sub	edi, 1
	sbb	ebx, 0
$LN16@operator:

; 835  : 
; 836  : 		_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [edx+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 837  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN106@operator
$LL4@operator:

; 838  : 			for (; _State == ios_base::goodbit && 0 < _Pad;

	test	esi, esi
	jne	$LN6@operator
	test	ebx, ebx
	jl	SHORT $LN106@operator
	jg	SHORT $LN109@operator
	test	edi, edi
	je	SHORT $LN106@operator
$LN109@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	mov	al, BYTE PTR [ecx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 840  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T12[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 840  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T12[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
	mov	ecx, DWORD PTR __Ostr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 840  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	eax, 4
	cmove	esi, eax
	add	edi, -1
	mov	DWORD PTR __State$[ebp], esi
	adc	ebx, -1
	jmp	SHORT $LL4@operator
$LN106@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 845  : 			&& _Traits::eq_int_type(_Traits::eof(),

	push	10					; 0000000aH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 845  : 			&& _Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [eax+ecx+56]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 845  : 			&& _Traits::eq_int_type(_Traits::eof(),

	test	al, al
	mov	eax, 4
	cmovne	esi, eax
$LN114@operator:
	mov	DWORD PTR __State$[ebp], esi

; 846  : 				_Ostr.rdbuf()->sputc(_Ch)))
; 847  : 			_State |= ios_base::badbit;
; 848  : 
; 849  : 		for (; _State == ios_base::goodbit && 0 < _Pad;

	test	esi, esi
	jne	SHORT $LN6@operator
	test	ebx, ebx
	jl	SHORT $LN6@operator
	jg	SHORT $LN110@operator
	test	edi, edi
	je	SHORT $LN6@operator
$LN110@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	ecx, DWORD PTR __Ostr$[ebp]
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	add	ecx, eax
	mov	al, BYTE PTR [ecx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 851  : 			if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T21[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 851  : 			if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T21[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 851  : 			if (_Traits::eq_int_type(_Traits::eof(),

	mov	eax, 4
	cmove	esi, eax
	add	edi, -1
	adc	ebx, -1
	jmp	SHORT $LN114@operator
__catch$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$0:

; 852  : 				_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 853  : 				_State |= ios_base::badbit;
; 854  : 		_CATCH_IO_(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN21@operator
	ret	0
$LN21@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	esi, DWORD PTR __State$[ebp]
$LN6@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
	mov	edi, DWORD PTR __Ok$[ebp]
$LN20@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 855  : 		}
; 856  : 
; 857  : 	_Ostr.width(0);

	mov	ebx, DWORD PTR __Ostr$[ebp]

; 858  : 	_Ostr.setstate(_State);

	push	0
	push	esi
	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 858  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z

; 130  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN86@operator

; 133  : 				this->_Myostr._Osfx();

	mov	ecx, edi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN86@operator:

; 106  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+edi+56]
	test	ecx, ecx
	je	SHORT $LN111@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN111@operator:

; 859  : 	return (_Ostr);

	mov	eax, ebx

; 860  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$3:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$10:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z$11:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6U?$char_traits@D@std@@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@D@Z ENDP ; std::operator<<<std::char_traits<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
;	COMDAT ??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z
_TEXT	SEGMENT
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z PROC		; std::setfill<char>, COMDAT
; ___$ReturnUdt$ = ecx
; __Ch$dead$ = dl

; 24   : 		: _Fill(_Ch)

	mov	BYTE PTR [ecx], 48			; 00000030H

; 35   : 	return (_Fillobj<_Elem>(_Ch));

	mov	eax, ecx

; 36   : 	}

	ret	0
??$setfill@D@std@@YA?AU?$_Fillobj@D@0@D@Z ENDP		; std::setfill<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
;	COMDAT ??$?6DU?$char_traits@D@std@@D@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z
_TEXT	SEGMENT
??$?6DU?$char_traits@D@std@@D@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,char>, COMDAT
; __Ostr$ = ecx
; __Manip$ = edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 119  : 		_Fillch = _Newfill;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [eax+4]
	mov	al, BYTE PTR [edx]
	mov	BYTE PTR [esi+ecx+64], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip

; 63   : 	return (_Ostr);

	mov	eax, ecx
	pop	esi

; 64   : 	}

	ret	0
??$?6DU?$char_traits@D@std@@D@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Fillobj@D@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
;	COMDAT ??$?6DU?$char_traits@D@std@@_J@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@_J@0@@Z
_TEXT	SEGMENT
??$?6DU?$char_traits@D@std@@_J@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@_J@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,__int64>, COMDAT
; __Ostr$ = ecx
; __Manip$ = edx

; 526  : 	{	// insert by calling function with output stream and argument

	push	esi
	mov	esi, ecx

; 527  : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	test	esi, esi
	jne	SHORT $LN3@operator
	push	DWORD PTR [edx+12]
	xor	eax, eax
	push	DWORD PTR [edx+8]
	push	eax
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 12					; 0000000cH

; 528  : 	return (_Ostr);

	mov	eax, esi
	pop	esi

; 529  : 	}

	ret	0
$LN3@operator:

; 527  : 	(*_Manip._Pfun)(_Ostr, _Manip._Manarg);

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [edx+12]
	push	DWORD PTR [edx+8]
	mov	eax, DWORD PTR [eax+4]
	add	eax, esi
	push	eax
	mov	eax, DWORD PTR [edx]
	call	eax
	add	esp, 12					; 0000000cH

; 528  : 	return (_Ostr);

	mov	eax, esi
	pop	esi

; 529  : 	}

	ret	0
??$?6DU?$char_traits@D@std@@_J@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABU?$_Smanip@_J@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,__int64>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
$T6 = -48						; size = 8
$T5 = -48						; size = 8
__Ok$ = -48						; size = 8
__Str$1$ = -36						; size = 4
$T26 = -36						; size = 1
$T16 = -32						; size = 1
__State$ = -28						; size = 4
__Ostr$ = -24						; size = 4
__Size$1$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; __Ostr$ = ecx
; __Str$ = edx

; 170  : 	{	// insert a string

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 36					; 00000024H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR __Str$1$[ebp], edx
	mov	ebx, ecx
	mov	DWORD PTR __Ostr$[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 175  : 	ios_base::iostate _State = ios_base::goodbit;

	xor	edi, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1765 : 		return (this->_Mysize());

	mov	edx, DWORD PTR [edx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 175  : 	ios_base::iostate _State = ios_base::goodbit;

	mov	DWORD PTR __State$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1765 : 		return (this->_Mysize());

	mov	DWORD PTR __Size$1$[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx+ebx+36]
	mov	esi, DWORD PTR [ecx+ebx+32]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 177  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size

	test	eax, eax
	jl	SHORT $LN17@operator
	jg	SHORT $LN135@operator
	test	esi, esi
	je	SHORT $LN17@operator
$LN135@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	DWORD PTR $T5[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 177  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size

	cmp	esi, edx
	jbe	SHORT $LN17@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 423  : 		return (_Wide);

	mov	DWORD PTR $T6[ebp+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 177  : 	_Mysizt _Pad = _Ostr.width() <= 0 || (_Mysizt)_Ostr.width() <= _Size

	sub	esi, edx
	jmp	SHORT $LN18@operator
$LN17@operator:
	xor	esi, esi
$LN18@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 99   : 			: _Myostr(_Ostr)

	mov	DWORD PTR __Ok$[ebp], ebx

; 100  : 			{	// lock the stream buffer, if there
; 101  : 			if (_Myostr.rdbuf() != 0)

	test	ecx, ecx
	je	SHORT $LN47@operator

; 102  : 				_Myostr.rdbuf()->_Lock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+4]
$LN47@operator:

; 122  : 			: _Sentry_base(_Ostr)

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [eax+ebx+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	jne	SHORT $LN43@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 80   : 		return (_Tiestr);

	mov	ecx, DWORD PTR [eax+ebx+60]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 124  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

	test	ecx, ecx
	je	SHORT $LN43@operator
	cmp	ecx, ebx
	je	SHORT $LN43@operator

; 125  : 				_Ostr.tie()->flush();

	call	DWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEAAV12@XZ
$LN43@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 315  : 		return (_Mystate);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]

; 339  : 		return (rdstate() == goodbit);

	cmp	DWORD PTR [ecx+ebx+12], 0
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 126  : 			_Ok = _Ostr.good();	// store test only after flushing tie

	mov	BYTE PTR __Ok$[ebp+4], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 179  : 	const typename _Myos::sentry _Ok(_Ostr);

	mov	DWORD PTR __$EHRec$[ebp+12], 1

; 180  : 
; 181  : 	if (!_Ok)

	test	al, al
	jne	SHORT $LN8@operator

; 182  : 		_State |= ios_base::badbit;

	mov	edi, 4

; 183  : 	else

	jmp	$LN22@operator
$LN8@operator:

; 184  : 		{	// state okay, insert characters
; 185  : 	_TRY_IO_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 378  : 		return (_Fmtfl);

	mov	eax, DWORD PTR [ecx+ebx+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 186  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN132@operator
$LL4@operator:

; 187  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	test	esi, esi
	je	SHORT $LN3@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 188  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T16[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 188  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T16[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 188  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN2@operator

; 189  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 190  : 					{	// insertion failed, quit
; 191  : 					_State |= ios_base::badbit;

	mov	edi, 4
	mov	DWORD PTR __State$[ebp], edi

; 192  : 					break;

	jmp	SHORT $LL137@operator
$LN2@operator:

; 187  : 			for (; 0 < _Pad; --_Pad)	// pad on left

	dec	esi
	jmp	SHORT $LL4@operator
$LN3@operator:
	test	edi, edi

; 196  : 			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)

	jne	SHORT $LL137@operator
$LN132@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR __Str$1$[ebp]
	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN95@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN95@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 196  : 			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)

	push	0
	push	DWORD PTR __Size$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 92   : 		return (_Mystrbuf);

	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 196  : 			&& _Ostr.rdbuf()->sputn(_Str.c_str(), (streamsize)_Size)

	push	ecx
	mov	ecx, DWORD PTR [eax+ebx+56]
	call	DWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAE_JPBD_J@Z
	cmp	eax, DWORD PTR __Size$1$[ebp]
	jne	SHORT $LN136@operator
	test	edx, edx
	jne	SHORT $LN136@operator
$LL137@operator:

; 199  : 		else
; 200  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	test	esi, esi
	je	SHORT $LN6@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+4]
	mov	al, BYTE PTR [ecx+ebx+64]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 201  : 				if (_Traits::eq_int_type(_Traits::eof(),

	mov	ecx, DWORD PTR [ecx+ebx+56]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios

; 113  : 		return (_Fillch);

	mov	BYTE PTR $T26[ebp], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 201  : 				if (_Traits::eq_int_type(_Traits::eof(),

	push	DWORD PTR $T26[ebp]
	call	DWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QAEHD@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 595  : 		return (_Left == _Right);

	cmp	eax, -1
	sete	al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 201  : 				if (_Traits::eq_int_type(_Traits::eof(),

	test	al, al
	je	SHORT $LN5@operator

; 202  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 203  : 					{	// insertion failed, quit
; 204  : 					_State |= ios_base::badbit;

	or	edi, 4

; 205  : 					break;

	jmp	SHORT $LN6@operator
$LN5@operator:

; 199  : 		else
; 200  : 			for (; 0 < _Pad; --_Pad)	// pad on right

	dec	esi
	jmp	SHORT $LL137@operator
$LN136@operator:

; 197  : 				!= (streamsize)_Size)
; 198  : 				_State |= ios_base::badbit;

	mov	edi, 4
$LN6@operator:

; 206  : 					}
; 207  : 		_Ostr.width(0);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xiosbase

; 429  : 		_Wide = _Newwidth;

	mov	DWORD PTR [eax+ebx+32], 0
	mov	DWORD PTR [eax+ebx+36], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string
	jmp	SHORT $LN142@operator
__catch$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:

; 208  : 		_CATCH_IO_(_Ostr)

	mov	edx, DWORD PTR __Ostr$[ebp]
	push	1
	push	4
	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, edx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
	mov	eax, $LN23@operator
	ret	0
$LN23@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ios
	mov	ebx, DWORD PTR __Ostr$[ebp]
	mov	edi, DWORD PTR __State$[ebp]
$LN142@operator:
	mov	DWORD PTR __$EHRec$[ebp+12], 1
$LN22@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 209  : 		}
; 210  : 
; 211  : 	_Ostr.setstate(_State);

	mov	eax, DWORD PTR [ebx]
	push	0
	push	edi
	mov	ecx, DWORD PTR [eax+4]
	add	ecx, ebx
	call	DWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QAEXH_N@Z
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\ostream

; 130  : 			{	// destroy the object

	mov	DWORD PTR __$EHRec$[ebp+12], 4

; 131  :  #if _HAS_EXCEPTIONS
; 132  : 			if (!_XSTD uncaught_exception())

	call	DWORD PTR __imp_?uncaught_exception@std@@YA_NXZ

; 133  : 				this->_Myostr._Osfx();

	mov	esi, DWORD PTR __Ok$[ebp]
	test	al, al
	jne	SHORT $LN113@operator
	mov	ecx, esi
	call	DWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAEXXZ
$LN113@operator:

; 106  : 			{	// destroy after unlocking

	mov	BYTE PTR __$EHRec$[ebp+12], 5

; 107  : 			if (_Myostr.rdbuf() != 0)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+esi+56]
	test	ecx, ecx
	je	SHORT $LN138@operator

; 108  : 				_Myostr.rdbuf()->_Unlock();

	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
$LN138@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\string

; 212  : 	return (_Ostr);

	mov	eax, ebx

; 213  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$7:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$2:
	lea	ecx, DWORD PTR __Ok$[ebp]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QAE@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$15:
	call	DWORD PTR __imp____std_terminate
	ret	0
__unwindfunclet$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$16:
	call	DWORD PTR __imp____std_terminate
	ret	0
__ehhandler$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAAV?$basic_ostream@DU?$char_traits@D@std@@@0@AAV10@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT
; __Val$ = ecx

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, ecx

; 726  : 	}

	ret	0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iomanip
;	COMDAT ??0?$_Fillobj@D@std@@QAE@D@Z
_TEXT	SEGMENT
__Ch$dead$ = 8						; size = 1
??0?$_Fillobj@D@std@@QAE@D@Z PROC			; std::_Fillobj<char>::_Fillobj<char>, COMDAT
; _this$ = ecx

; 24   : 		: _Fill(_Ch)

	mov	BYTE PTR [ecx], 48			; 00000030H

; 26   : 		}

	mov	eax, ecx
	ret	4
??0?$_Fillobj@D@std@@QAE@D@Z ENDP			; std::_Fillobj<char>::_Fillobj<char>
_TEXT	ENDS
; Function compile flags: /Odsp
;	COMDAT ??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z
_TEXT	SEGMENT
??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z PROC ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
	sub	ecx, DWORD PTR [ecx-4]
	jmp	??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UAEPAXI@Z
??_E?$basic_ostringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@AEPAXI@Z ENDP ; std::basic_ostringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
END
